define(['dart_sdk', 'packages/flutter/src/foundation/object.dart', 'packages/flutter/src/foundation/node.dart', 'packages/flutter/src/foundation/debug.dart', 'packages/vector_math/vector_math_64.dart', 'packages/flutter/src/gestures/events.dart', 'packages/flutter/src/painting/matrix_utils.dart', 'packages/flutter/src/painting/colors.dart', 'packages/flutter/src/gestures/hit_test.dart', 'packages/flutter/src/services/system_chrome.dart', 'packages/flutter/src/foundation/_platform_web.dart', 'packages/flutter/src/foundation/print.dart', 'packages/flutter/src/semantics/semantics.dart', 'packages/flutter/src/animation/curves.dart', 'packages/flutter/src/semantics/semantics_event.dart', 'packages/flutter/src/foundation/change_notifier.dart', 'packages/flutter/src/services/system_channels.dart', 'packages/flutter/src/painting/debug.dart', 'packages/flutter/src/scheduler/binding.dart', 'packages/flutter/src/semantics/binding.dart', 'packages/flutter/src/gestures/binding.dart', 'packages/flutter/src/foundation/binding.dart', 'packages/flutter/src/painting/binding.dart', 'packages/flutter/src/painting/clip.dart', 'packages/flutter/src/painting/edge_insets.dart'], (function load__packages__flutter__src__rendering__layer_dart(dart_sdk, packages__flutter__src__foundation__object$46dart, packages__flutter__src__foundation__node$46dart, packages__flutter__src__foundation__debug$46dart, packages__vector_math__vector_math_64$46dart, packages__flutter__src__gestures__events$46dart, packages__flutter__src__painting__matrix_utils$46dart, packages__flutter__src__painting__colors$46dart, packages__flutter__src__gestures__hit_test$46dart, packages__flutter__src__services__system_chrome$46dart, packages__flutter__src__foundation___platform_web$46dart, packages__flutter__src__foundation__print$46dart, packages__flutter__src__semantics__semantics$46dart, packages__flutter__src__animation__curves$46dart, packages__flutter__src__semantics__semantics_event$46dart, packages__flutter__src__foundation__change_notifier$46dart, packages__flutter__src__services__system_channels$46dart, packages__flutter__src__painting__debug$46dart, packages__flutter__src__scheduler__binding$46dart, packages__flutter__src__semantics__binding$46dart, packages__flutter__src__gestures__binding$46dart, packages__flutter__src__foundation__binding$46dart, packages__flutter__src__painting__binding$46dart, packages__flutter__src__painting__clip$46dart, packages__flutter__src__painting__edge_insets$46dart) {
  'use strict';
  const core = dart_sdk.core;
  const ui = dart_sdk.ui;
  const _interceptors = dart_sdk._interceptors;
  const _js_helper = dart_sdk._js_helper;
  const async = dart_sdk.async;
  const developer = dart_sdk.developer;
  const _internal = dart_sdk._internal;
  const io = dart_sdk.io;
  const collection = dart_sdk.collection;
  const typed_data = dart_sdk.typed_data;
  const math = dart_sdk.math;
  const dart = dart_sdk.dart;
  const dartx = dart_sdk.dartx;
  const object = packages__flutter__src__foundation__object$46dart.src__foundation__object;
  const node = packages__flutter__src__foundation__node$46dart.src__foundation__node;
  const diagnostics = packages__flutter__src__foundation__debug$46dart.src__foundation__diagnostics;
  const assertions = packages__flutter__src__foundation__debug$46dart.src__foundation__assertions;
  const debug = packages__flutter__src__foundation__debug$46dart.src__foundation__debug;
  const vector_math_64 = packages__vector_math__vector_math_64$46dart.vector_math_64;
  const events = packages__flutter__src__gestures__events$46dart.src__gestures__events;
  const matrix_utils = packages__flutter__src__painting__matrix_utils$46dart.src__painting__matrix_utils;
  const colors = packages__flutter__src__painting__colors$46dart.src__painting__colors;
  const hit_test = packages__flutter__src__gestures__hit_test$46dart.src__gestures__hit_test;
  const system_chrome = packages__flutter__src__services__system_chrome$46dart.src__services__system_chrome;
  const platform = packages__flutter__src__foundation___platform_web$46dart.src__foundation__platform;
  const print = packages__flutter__src__foundation__print$46dart.src__foundation__print;
  const semantics = packages__flutter__src__semantics__semantics$46dart.src__semantics__semantics;
  const curves = packages__flutter__src__animation__curves$46dart.src__animation__curves;
  const semantics_event = packages__flutter__src__semantics__semantics_event$46dart.src__semantics__semantics_event;
  const change_notifier = packages__flutter__src__foundation__change_notifier$46dart.src__foundation__change_notifier;
  const system_channels = packages__flutter__src__services__system_channels$46dart.src__services__system_channels;
  const platform_channel = packages__flutter__src__services__system_channels$46dart.src__services__platform_channel;
  const message_codecs = packages__flutter__src__services__system_channels$46dart.src__services__message_codecs;
  const binding = packages__flutter__src__services__system_channels$46dart.src__services__binding;
  const debug$ = packages__flutter__src__painting__debug$46dart.src__painting__debug;
  const binding$ = packages__flutter__src__scheduler__binding$46dart.src__scheduler__binding;
  const binding$0 = packages__flutter__src__semantics__binding$46dart.src__semantics__binding;
  const binding$1 = packages__flutter__src__gestures__binding$46dart.src__gestures__binding;
  const binding$2 = packages__flutter__src__foundation__binding$46dart.src__foundation__binding;
  const binding$3 = packages__flutter__src__painting__binding$46dart.src__painting__binding;
  const clip = packages__flutter__src__painting__clip$46dart.src__painting__clip;
  const edge_insets = packages__flutter__src__painting__edge_insets$46dart.src__painting__edge_insets;
  var layer$ = Object.create(dart.library);
  var view = Object.create(dart.library);
  var mouse_cursor = Object.create(dart.library);
  var mouse_tracking = Object.create(dart.library);
  var binding$4 = Object.create(dart.library);
  var object$ = Object.create(dart.library);
  var debug$0 = Object.create(dart.library);
  var box = Object.create(dart.library);
  var $add = dartx.add;
  var $runtimeType = dartx.runtimeType;
  var $isEmpty = dartx.isEmpty;
  var $first = dartx.first;
  var $whereType = dartx.whereType;
  var $toList = dartx.toList;
  var $length = dartx.length;
  var $_get = dartx._get;
  var $any = dartx.any;
  var $addAll = dartx.addAll;
  var $isNotEmpty = dartx.isNotEmpty;
  var $_equals = dartx._equals;
  var $ceil = dartx.ceil;
  var $isFinite = dartx.isFinite;
  var $every = dartx.every;
  var $modulo = dartx['%'];
  var $split = dartx.split;
  var $matchAsPrefix = dartx.matchAsPrefix;
  var $trim = dartx.trim;
  var $single = dartx.single;
  var $clear = dartx.clear;
  var $putIfAbsent = dartx.putIfAbsent;
  var $map = dartx.map;
  var $remove = dartx.remove;
  var $keys = dartx.keys;
  var $_set = dartx._set;
  var $containsKey = dartx.containsKey;
  var $values = dartx.values;
  var $hashCode = dartx.hashCode;
  var $forEach = dartx.forEach;
  var $where = dartx.where;
  var $reversed = dartx.reversed;
  var $sort = dartx.sort;
  var $last = dartx.last;
  var $skip = dartx.skip;
  var $clamp = dartx.clamp;
  var $truncate = dartx.truncate;
  var $toDouble = dartx.toDouble;
  var $isNaN = dartx.isNaN;
  var $removeLast = dartx.removeLast;
  var $join = dartx.join;
  var $isInfinite = dartx.isInfinite;
  var $toStringAsFixed = dartx.toStringAsFixed;
  dart._checkModuleNullSafetyMode(false);
  var T$ = {
    ContainerLayerN: () => (T$.ContainerLayerN = dart.constFn(dart.nullable(layer$.ContainerLayer)))(),
    VoidTobool: () => (T$.VoidTobool = dart.constFn(dart.fnType(core.bool, [])))(),
    DiagnosticsPropertyOfObject: () => (T$.DiagnosticsPropertyOfObject = dart.constFn(diagnostics.DiagnosticsProperty$(core.Object)))(),
    DiagnosticsPropertyOfString: () => (T$.DiagnosticsPropertyOfString = dart.constFn(diagnostics.DiagnosticsProperty$(core.String)))(),
    DiagnosticsPropertyOfRect: () => (T$.DiagnosticsPropertyOfRect = dart.constFn(diagnostics.DiagnosticsProperty$(ui.Rect)))(),
    JSArrayOfDiagnosticsNode: () => (T$.JSArrayOfDiagnosticsNode = dart.constFn(_interceptors.JSArray$(diagnostics.DiagnosticsNode)))(),
    ListOfDiagnosticsNode: () => (T$.ListOfDiagnosticsNode = dart.constFn(core.List$(diagnostics.DiagnosticsNode)))(),
    VoidToListOfDiagnosticsNode: () => (T$.VoidToListOfDiagnosticsNode = dart.constFn(dart.fnType(T$.ListOfDiagnosticsNode(), [])))(),
    JSArrayOfPictureLayer: () => (T$.JSArrayOfPictureLayer = dart.constFn(_interceptors.JSArray$(layer$.PictureLayer)))(),
    PathMetricTobool: () => (T$.PathMetricTobool = dart.constFn(dart.fnType(core.bool, [ui.PathMetric])))(),
    JSArrayOfLayer: () => (T$.JSArrayOfLayer = dart.constFn(_interceptors.JSArray$(layer$.Layer)))(),
    OffsetEngineLayerN: () => (T$.OffsetEngineLayerN = dart.constFn(dart.nullable(ui.OffsetEngineLayer)))(),
    DiagnosticsPropertyOfOffset: () => (T$.DiagnosticsPropertyOfOffset = dart.constFn(diagnostics.DiagnosticsProperty$(ui.Offset)))(),
    ClipRectEngineLayerN: () => (T$.ClipRectEngineLayerN = dart.constFn(dart.nullable(ui.ClipRectEngineLayer)))(),
    DiagnosticsPropertyOfClip: () => (T$.DiagnosticsPropertyOfClip = dart.constFn(diagnostics.DiagnosticsProperty$(ui.Clip)))(),
    ClipRRectEngineLayerN: () => (T$.ClipRRectEngineLayerN = dart.constFn(dart.nullable(ui.ClipRRectEngineLayer)))(),
    DiagnosticsPropertyOfRRect: () => (T$.DiagnosticsPropertyOfRRect = dart.constFn(diagnostics.DiagnosticsProperty$(ui.RRect)))(),
    ClipPathEngineLayerN: () => (T$.ClipPathEngineLayerN = dart.constFn(dart.nullable(ui.ClipPathEngineLayer)))(),
    ColorFilterEngineLayerN: () => (T$.ColorFilterEngineLayerN = dart.constFn(dart.nullable(ui.ColorFilterEngineLayer)))(),
    DiagnosticsPropertyOfColorFilter: () => (T$.DiagnosticsPropertyOfColorFilter = dart.constFn(diagnostics.DiagnosticsProperty$(ui.ColorFilter)))(),
    ImageFilterEngineLayerN: () => (T$.ImageFilterEngineLayerN = dart.constFn(dart.nullable(ui.ImageFilterEngineLayer)))(),
    DiagnosticsPropertyOfImageFilter: () => (T$.DiagnosticsPropertyOfImageFilter = dart.constFn(diagnostics.DiagnosticsProperty$(ui.ImageFilter)))(),
    doubleTobool: () => (T$.doubleTobool = dart.constFn(dart.fnType(core.bool, [core.double])))(),
    TransformEngineLayerN: () => (T$.TransformEngineLayerN = dart.constFn(dart.nullable(ui.TransformEngineLayer)))(),
    OpacityEngineLayerN: () => (T$.OpacityEngineLayerN = dart.constFn(dart.nullable(ui.OpacityEngineLayer)))(),
    ShaderMaskEngineLayerN: () => (T$.ShaderMaskEngineLayerN = dart.constFn(dart.nullable(ui.ShaderMaskEngineLayer)))(),
    DiagnosticsPropertyOfShader: () => (T$.DiagnosticsPropertyOfShader = dart.constFn(diagnostics.DiagnosticsProperty$(ui.Shader)))(),
    DiagnosticsPropertyOfBlendMode: () => (T$.DiagnosticsPropertyOfBlendMode = dart.constFn(diagnostics.DiagnosticsProperty$(ui.BlendMode)))(),
    BackdropFilterEngineLayerN: () => (T$.BackdropFilterEngineLayerN = dart.constFn(dart.nullable(ui.BackdropFilterEngineLayer)))(),
    PhysicalShapeEngineLayerN: () => (T$.PhysicalShapeEngineLayerN = dart.constFn(dart.nullable(ui.PhysicalShapeEngineLayer)))(),
    DiagnosticsPropertyOfLayerLink: () => (T$.DiagnosticsPropertyOfLayerLink = dart.constFn(diagnostics.DiagnosticsProperty$(layer$.LayerLink)))(),
    JSArrayOfContainerLayer: () => (T$.JSArrayOfContainerLayer = dart.constFn(_interceptors.JSArray$(layer$.ContainerLayer)))(),
    DiagnosticsPropertyOfSize: () => (T$.DiagnosticsPropertyOfSize = dart.constFn(diagnostics.DiagnosticsProperty$(ui.Size)))(),
    DiagnosticsPropertyOfbool: () => (T$.DiagnosticsPropertyOfbool = dart.constFn(diagnostics.DiagnosticsProperty$(core.bool)))(),
    DiagnosticsPropertyOfViewConfiguration: () => (T$.DiagnosticsPropertyOfViewConfiguration = dart.constFn(diagnostics.DiagnosticsProperty$(view.ViewConfiguration)))(),
    RenderObjectTovoid: () => (T$.RenderObjectTovoid = dart.constFn(dart.fnType(dart.void, [object$.RenderObject])))(),
    SyncIterableOfDiagnosticsNode: () => (T$.SyncIterableOfDiagnosticsNode = dart.constFn(_js_helper.SyncIterable$(diagnostics.DiagnosticsNode)))(),
    IterableOfDiagnosticsNode: () => (T$.IterableOfDiagnosticsNode = dart.constFn(core.Iterable$(diagnostics.DiagnosticsNode)))(),
    VoidToIterableOfDiagnosticsNode: () => (T$.VoidToIterableOfDiagnosticsNode = dart.constFn(dart.fnType(T$.IterableOfDiagnosticsNode(), [])))(),
    boolTodynamic: () => (T$.boolTodynamic = dart.constFn(dart.fnType(dart.dynamic, [core.bool])))(),
    PipelineOwnerN: () => (T$.PipelineOwnerN = dart.constFn(dart.nullable(object$.PipelineOwner)))(),
    VoidTovoid: () => (T$.VoidTovoid = dart.constFn(dart.fnType(dart.void, [])))(),
    JSArrayOfRenderObject: () => (T$.JSArrayOfRenderObject = dart.constFn(_interceptors.JSArray$(object$.RenderObject)))(),
    RenderObjectN: () => (T$.RenderObjectN = dart.constFn(dart.nullable(object$.RenderObject)))(),
    JSArrayOfSemanticsNode: () => (T$.JSArrayOfSemanticsNode = dart.constFn(_interceptors.JSArray$(semantics.SemanticsNode)))(),
    JSArrayOf_InterestingSemanticsFragment: () => (T$.JSArrayOf_InterestingSemanticsFragment = dart.constFn(_interceptors.JSArray$(object$._InterestingSemanticsFragment)))(),
    LinkedHashSetOf_InterestingSemanticsFragment: () => (T$.LinkedHashSetOf_InterestingSemanticsFragment = dart.constFn(collection.LinkedHashSet$(object$._InterestingSemanticsFragment)))(),
    ListOfSemanticsNode: () => (T$.ListOfSemanticsNode = dart.constFn(core.List$(semantics.SemanticsNode)))(),
    ObjectN: () => (T$.ObjectN = dart.constFn(dart.nullable(core.Object)))(),
    DiagnosticsPropertyOfObjectN: () => (T$.DiagnosticsPropertyOfObjectN = dart.constFn(diagnostics.DiagnosticsProperty$(T$.ObjectN())))(),
    DiagnosticsPropertyOfParentData: () => (T$.DiagnosticsPropertyOfParentData = dart.constFn(diagnostics.DiagnosticsProperty$(object$.ParentData)))(),
    DiagnosticsPropertyOfConstraints: () => (T$.DiagnosticsPropertyOfConstraints = dart.constFn(diagnostics.DiagnosticsProperty$(object$.Constraints)))(),
    DiagnosticsPropertyOfContainerLayer: () => (T$.DiagnosticsPropertyOfContainerLayer = dart.constFn(diagnostics.DiagnosticsProperty$(layer$.ContainerLayer)))(),
    DiagnosticsPropertyOfSemanticsNode: () => (T$.DiagnosticsPropertyOfSemanticsNode = dart.constFn(diagnostics.DiagnosticsProperty$(semantics.SemanticsNode)))(),
    LinkedMapOf_IntrinsicDimensionsCacheEntry$double: () => (T$.LinkedMapOf_IntrinsicDimensionsCacheEntry$double = dart.constFn(_js_helper.LinkedMap$(box._IntrinsicDimensionsCacheEntry, core.double)))(),
    VoidTodouble: () => (T$.VoidTodouble = dart.constFn(dart.fnType(core.double, [])))(),
    LinkedMapOfBoxConstraints$Size: () => (T$.LinkedMapOfBoxConstraints$Size = dart.constFn(_js_helper.LinkedMap$(box.BoxConstraints, ui.Size)))(),
    VoidToSize: () => (T$.VoidToSize = dart.constFn(dart.fnType(ui.Size, [])))(),
    doubleN: () => (T$.doubleN = dart.constFn(dart.nullable(core.double)))(),
    LinkedMapOfTextBaseline$doubleN: () => (T$.LinkedMapOfTextBaseline$doubleN = dart.constFn(_js_helper.LinkedMap$(ui.TextBaseline, T$.doubleN())))(),
    VoidTodoubleN: () => (T$.VoidTodoubleN = dart.constFn(dart.fnType(T$.doubleN(), [])))(),
    DiagnosticsPropertyOfRenderBox: () => (T$.DiagnosticsPropertyOfRenderBox = dart.constFn(diagnostics.DiagnosticsProperty$(box.RenderBox)))(),
    DiagnosticsPropertyOfBoxConstraints: () => (T$.DiagnosticsPropertyOfBoxConstraints = dart.constFn(diagnostics.DiagnosticsProperty$(box.BoxConstraints)))(),
    doubleTodouble: () => (T$.doubleTodouble = dart.constFn(dart.fnType(core.double, [core.double])))(),
    FnAndStringAnddoubleTodouble: () => (T$.FnAndStringAnddoubleTodouble = dart.constFn(dart.fnType(core.double, [T$.doubleTodouble(), core.String, core.double])))(),
    FnAndFnAndString__Tovoid: () => (T$.FnAndFnAndString__Tovoid = dart.constFn(dart.fnType(dart.void, [T$.doubleTodouble(), T$.doubleTodouble(), core.String, core.double])))(),
    SizeTodynamic: () => (T$.SizeTodynamic = dart.constFn(dart.fnType(dart.dynamic, [ui.Size])))(),
    IdentityMapOfint$MouseCursorSession: () => (T$.IdentityMapOfint$MouseCursorSession = dart.constFn(_js_helper.IdentityMap$(core.int, mouse_cursor.MouseCursorSession)))(),
    MouseTrackerAnnotationToMouseCursor: () => (T$.MouseTrackerAnnotationToMouseCursor = dart.constFn(dart.fnType(mouse_cursor.MouseCursor, [mouse_tracking.MouseTrackerAnnotation])))(),
    IdentityMapOfint$_MouseState: () => (T$.IdentityMapOfint$_MouseState = dart.constFn(_js_helper.IdentityMap$(core.int, mouse_tracking._MouseState)))(),
    LinkedMapOfMouseTrackerAnnotation$Matrix4: () => (T$.LinkedMapOfMouseTrackerAnnotation$Matrix4 = dart.constFn(_js_helper.LinkedMap$(mouse_tracking.MouseTrackerAnnotation, vector_math_64.Matrix4)))(),
    LinkedHashMapOfMouseTrackerAnnotation$Matrix4: () => (T$.LinkedHashMapOfMouseTrackerAnnotation$Matrix4 = dart.constFn(collection.LinkedHashMap$(mouse_tracking.MouseTrackerAnnotation, vector_math_64.Matrix4)))(),
    IdentityMapOfString$dynamic: () => (T$.IdentityMapOfString$dynamic = dart.constFn(_js_helper.IdentityMap$(core.String, dart.dynamic)))(),
    FunctionN: () => (T$.FunctionN = dart.constFn(dart.nullable(core.Function)))(),
    FlagsSummaryOfFunctionN: () => (T$.FlagsSummaryOfFunctionN = dart.constFn(diagnostics.FlagsSummary$(T$.FunctionN())))(),
    IdentityMapOfString$FunctionN: () => (T$.IdentityMapOfString$FunctionN = dart.constFn(_js_helper.IdentityMap$(core.String, T$.FunctionN())))(),
    DiagnosticsPropertyOfMouseCursor: () => (T$.DiagnosticsPropertyOfMouseCursor = dart.constFn(diagnostics.DiagnosticsProperty$(mouse_cursor.MouseCursor)))(),
    DiagnosticsPropertyOfPointerEvent: () => (T$.DiagnosticsPropertyOfPointerEvent = dart.constFn(diagnostics.DiagnosticsProperty$(events.PointerEvent)))(),
    MapOfMouseTrackerAnnotation$Matrix4: () => (T$.MapOfMouseTrackerAnnotation$Matrix4 = dart.constFn(core.Map$(mouse_tracking.MouseTrackerAnnotation, vector_math_64.Matrix4)))(),
    DiagnosticsPropertyOfMapOfMouseTrackerAnnotation$Matrix4: () => (T$.DiagnosticsPropertyOfMapOfMouseTrackerAnnotation$Matrix4 = dart.constFn(diagnostics.DiagnosticsProperty$(T$.MapOfMouseTrackerAnnotation$Matrix4())))(),
    MouseTrackerAnnotationAndMatrix4Tovoid: () => (T$.MouseTrackerAnnotationAndMatrix4Tovoid = dart.constFn(dart.fnType(dart.void, [mouse_tracking.MouseTrackerAnnotation, vector_math_64.Matrix4])))(),
    MouseTrackerAnnotationTobool: () => (T$.MouseTrackerAnnotationTobool = dart.constFn(dart.fnType(core.bool, [mouse_tracking.MouseTrackerAnnotation])))(),
    FutureOfbool: () => (T$.FutureOfbool = dart.constFn(async.Future$(core.bool)))(),
    VoidToFutureOfbool: () => (T$.VoidToFutureOfbool = dart.constFn(dart.fnType(T$.FutureOfbool(), [])))(),
    FutureOfvoid: () => (T$.FutureOfvoid = dart.constFn(async.Future$(dart.void)))(),
    boolToFutureOfvoid: () => (T$.boolToFutureOfvoid = dart.constFn(dart.fnType(T$.FutureOfvoid(), [core.bool])))(),
    VoidToFutureOfvoid: () => (T$.VoidToFutureOfvoid = dart.constFn(dart.fnType(T$.FutureOfvoid(), [])))(),
    VoidToHitTestResult: () => (T$.VoidToHitTestResult = dart.constFn(dart.fnType(hit_test.HitTestResult, [])))(),
    DurationTovoid: () => (T$.DurationTovoid = dart.constFn(dart.fnType(dart.void, [core.Duration])))(),
    VoidToFn: () => (T$.VoidToFn = dart.constFn(dart.fnType(T$.RenderObjectTovoid(), [])))(),
    FnTodynamic: () => (T$.FnTodynamic = dart.constFn(dart.fnType(dart.dynamic, [T$.RenderObjectTovoid()])))(),
    OffsetLayerN: () => (T$.OffsetLayerN = dart.constFn(dart.nullable(layer$.OffsetLayer)))(),
    LinkedHashSetOfRenderObject: () => (T$.LinkedHashSetOfRenderObject = dart.constFn(collection.LinkedHashSet$(object$.RenderObject)))(),
    RenderObjectAndRenderObjectToint: () => (T$.RenderObjectAndRenderObjectToint = dart.constFn(dart.fnType(core.int, [object$.RenderObject, object$.RenderObject])))(),
    LinkedHashSetOfSemanticsTag: () => (T$.LinkedHashSetOfSemanticsTag = dart.constFn(collection.LinkedHashSet$(semantics.SemanticsTag)))(),
    DiagnosticsNodeTovoid: () => (T$.DiagnosticsNodeTovoid = dart.constFn(dart.fnType(dart.void, [diagnostics.DiagnosticsNode])))(),
    JSArrayOfString: () => (T$.JSArrayOfString = dart.constFn(_interceptors.JSArray$(core.String)))(),
    doubleAnddoubleAndStringToString: () => (T$.doubleAnddoubleAndStringToString = dart.constFn(dart.fnType(core.String, [core.double, core.double, core.String])))(),
    _IntrinsicDimensionL: () => (T$._IntrinsicDimensionL = dart.constFn(dart.legacy(box._IntrinsicDimension)))(),
    OffsetN: () => (T$.OffsetN = dart.constFn(dart.nullable(ui.Offset)))(),
    BoxHitTestResultAndOffsetNTobool: () => (T$.BoxHitTestResultAndOffsetNTobool = dart.constFn(dart.fnType(core.bool, [box.BoxHitTestResult, T$.OffsetN()])))()
  };
  var T$Eval = Object.assign({
    _: () => T$Eval
  }, T$);
  var S = {
    _: () => S
  };
  var S$Eval = Object.assign({
    _: () => S$Eval
  }, S);
  const CT = Object.create({
    _: () => (C, CT)
  });
  dart.defineLazy(CT, {
    get C0() {
      return C[0] = dart.const({
        __proto__: ui.Offset.prototype,
        [OffsetBase__dy]: 0,
        [OffsetBase__dx]: 0
      });
    },
    get C1() {
      return C[1] = dart.const({
        __proto__: ui.FilterQuality.prototype,
        [_name]: "FilterQuality.low",
        index: 1
      });
    },
    get C2() {
      return C[2] = dart.const({
        __proto__: ui.Color.prototype,
        [Color_value]: 4289331200.0
      });
    },
    get C3() {
      return C[3] = dart.const({
        __proto__: ui.Clip.prototype,
        [_name]: "Clip.hardEdge",
        index: 1
      });
    },
    get C4() {
      return C[4] = dart.const({
        __proto__: ui.Clip.prototype,
        [_name]: "Clip.antiAlias",
        index: 2
      });
    },
    get C5() {
      return C[5] = dart.const({
        __proto__: ui.Clip.prototype,
        [_name]: "Clip.none",
        index: 0
      });
    },
    get C6() {
      return C[6] = dart.const({
        __proto__: ui.Size.prototype,
        [OffsetBase__dy]: 0,
        [OffsetBase__dx]: 0
      });
    },
    get C7() {
      return C[7] = dart.const({
        __proto__: platform.TargetPlatform.prototype,
        [_name$]: "TargetPlatform.android",
        index: 0
      });
    },
    get C8() {
      return C[8] = dart.const({
        __proto__: platform.TargetPlatform.prototype,
        [_name$]: "TargetPlatform.fuchsia",
        index: 1
      });
    },
    get C9() {
      return C[9] = dart.const({
        __proto__: platform.TargetPlatform.prototype,
        [_name$]: "TargetPlatform.iOS",
        index: 2
      });
    },
    get C10() {
      return C[10] = dart.const({
        __proto__: platform.TargetPlatform.prototype,
        [_name$]: "TargetPlatform.linux",
        index: 3
      });
    },
    get C11() {
      return C[11] = dart.const({
        __proto__: platform.TargetPlatform.prototype,
        [_name$]: "TargetPlatform.macOS",
        index: 4
      });
    },
    get C12() {
      return C[12] = dart.const({
        __proto__: platform.TargetPlatform.prototype,
        [_name$]: "TargetPlatform.windows",
        index: 5
      });
    },
    get C13() {
      return C[13] = dart.fn(object$.RenderObject._cleanChildRelayoutBoundary, T$.RenderObjectTovoid());
    },
    get C14() {
      return C[14] = dart.const({
        __proto__: diagnostics.DiagnosticLevel.prototype,
        [_name$0]: "DiagnosticLevel.info",
        index: 3
      });
    },
    get C15() {
      return C[15] = dart.const({
        __proto__: diagnostics.DiagnosticLevel.prototype,
        [_name$0]: "DiagnosticLevel.debug",
        index: 2
      });
    },
    get C16() {
      return C[16] = dart.const({
        __proto__: core.Duration.prototype,
        [Duration__duration]: 0
      });
    },
    get C17() {
      return C[17] = dart.const({
        __proto__: curves.Cubic.prototype,
        [Cubic_d]: 1,
        [Cubic_c]: 0.25,
        [Cubic_b]: 0.1,
        [Cubic_a]: 0.25
      });
    },
    get C18() {
      return C[18] = dart.const({
        __proto__: diagnostics.DiagnosticsTreeStyle.prototype,
        [_name$0]: "DiagnosticsTreeStyle.shallow",
        index: 10
      });
    },
    get C19() {
      return C[19] = dart.const({
        __proto__: ui.Color.prototype,
        [Color_value]: 4278255615.0
      });
    },
    get C20() {
      return C[20] = dart.const({
        __proto__: ui.Color.prototype,
        [Color_value]: 4294955008.0
      });
    },
    get C21() {
      return C[21] = dart.const({
        __proto__: ui.Color.prototype,
        [Color_value]: 4278255360.0
      });
    },
    get C22() {
      return C[22] = dart.const({
        __proto__: mouse_cursor._DeferringMouseCursor.prototype
      });
    },
    get C23() {
      return C[23] = dart.const({
        __proto__: mouse_cursor._NoopMouseCursor.prototype
      });
    },
    get C24() {
      return C[24] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "none"
      });
    },
    get C25() {
      return C[25] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "basic"
      });
    },
    get C26() {
      return C[26] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "click"
      });
    },
    get C27() {
      return C[27] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "forbidden"
      });
    },
    get C28() {
      return C[28] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "wait"
      });
    },
    get C29() {
      return C[29] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "progress"
      });
    },
    get C30() {
      return C[30] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "contextMenu"
      });
    },
    get C31() {
      return C[31] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "help"
      });
    },
    get C32() {
      return C[32] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "text"
      });
    },
    get C33() {
      return C[33] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "verticalText"
      });
    },
    get C34() {
      return C[34] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "cell"
      });
    },
    get C35() {
      return C[35] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "precise"
      });
    },
    get C36() {
      return C[36] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "move"
      });
    },
    get C37() {
      return C[37] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "grab"
      });
    },
    get C38() {
      return C[38] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "grabbing"
      });
    },
    get C39() {
      return C[39] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "noDrop"
      });
    },
    get C40() {
      return C[40] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "alias"
      });
    },
    get C41() {
      return C[41] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "copy"
      });
    },
    get C42() {
      return C[42] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "disappearing"
      });
    },
    get C43() {
      return C[43] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "allScroll"
      });
    },
    get C44() {
      return C[44] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "resizeLeftRight"
      });
    },
    get C45() {
      return C[45] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "resizeUpDown"
      });
    },
    get C46() {
      return C[46] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "resizeUpLeftDownRight"
      });
    },
    get C47() {
      return C[47] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "resizeUpRightDownLeft"
      });
    },
    get C48() {
      return C[48] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "resizeUp"
      });
    },
    get C49() {
      return C[49] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "resizeDown"
      });
    },
    get C50() {
      return C[50] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "resizeLeft"
      });
    },
    get C51() {
      return C[51] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "resizeRight"
      });
    },
    get C52() {
      return C[52] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "resizeUpLeft"
      });
    },
    get C53() {
      return C[53] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "resizeUpRight"
      });
    },
    get C54() {
      return C[54] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "resizeDownLeft"
      });
    },
    get C55() {
      return C[55] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "resizeDownRight"
      });
    },
    get C56() {
      return C[56] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "resizeColumn"
      });
    },
    get C57() {
      return C[57] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "resizeRow"
      });
    },
    get C58() {
      return C[58] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "zoomIn"
      });
    },
    get C59() {
      return C[59] = dart.const({
        __proto__: mouse_cursor.SystemMouseCursor.prototype,
        [kind$]: "zoomOut"
      });
    },
    get C62() {
      return C[62] = dart.const({
        __proto__: message_codecs.StandardMessageCodec.prototype
      });
    },
    get C61() {
      return C[61] = dart.const({
        __proto__: message_codecs.StandardMethodCodec.prototype,
        [StandardMethodCodec_messageCodec]: C[62] || CT.C62
      });
    },
    get C60() {
      return C[60] = dart.const({
        __proto__: platform_channel.MethodChannel.prototype,
        [MethodChannel__binaryMessenger]: null,
        [MethodChannel_codec]: C[61] || CT.C61,
        [MethodChannel_name]: "flutter/service_worker"
      });
    },
    get C63() {
      return C[63] = dart.const({
        __proto__: ui.Color.prototype,
        [Color_value]: 4294940672.0
      });
    },
    get C64() {
      return C[64] = dart.const({
        __proto__: ui.Color.prototype,
        [Color_value]: 2415956223.0
      });
    },
    get C65() {
      return C[65] = dart.const({
        __proto__: ui.Color.prototype,
        [Color_value]: 4278227199.0
      });
    },
    get C66() {
      return C[66] = dart.const({
        __proto__: ui.Color.prototype,
        [Color_value]: 2425393296.0
      });
    },
    get C67() {
      return C[67] = dart.const({
        __proto__: colors.HSVColor.prototype,
        [HSVColor_value]: 1,
        [HSVColor_saturation]: 1,
        [HSVColor_hue]: 60,
        [HSVColor_alpha]: 0.4
      });
    },
    get C68() {
      return C[68] = dart.const({
        __proto__: box._IntrinsicDimension.prototype,
        [_name$1]: "_IntrinsicDimension.minWidth",
        index: 0
      });
    },
    get C69() {
      return C[69] = dart.const({
        __proto__: box._IntrinsicDimension.prototype,
        [_name$1]: "_IntrinsicDimension.maxWidth",
        index: 1
      });
    },
    get C70() {
      return C[70] = dart.const({
        __proto__: box._IntrinsicDimension.prototype,
        [_name$1]: "_IntrinsicDimension.minHeight",
        index: 2
      });
    },
    get C71() {
      return C[71] = dart.const({
        __proto__: box._IntrinsicDimension.prototype,
        [_name$1]: "_IntrinsicDimension.maxHeight",
        index: 3
      });
    },
    get C72() {
      return C[72] = dart.constList([C[68] || CT.C68, C[69] || CT.C69, C[70] || CT.C70, C[71] || CT.C71], T$._IntrinsicDimensionL());
    }
  }, false);
  var C = Array(73).fill(void 0);
  var I = [
    "file:///C:/flutter/packages/flutter/lib/src/rendering/layer.dart",
    "package:flutter/src/rendering/layer.dart",
    "file:///C:/flutter/packages/flutter/lib/src/rendering/view.dart",
    "package:flutter/src/rendering/view.dart",
    "file:///C:/flutter/packages/flutter/lib/src/rendering/object.dart",
    "package:flutter/src/rendering/object.dart",
    "file:///C:/flutter/packages/flutter/lib/src/rendering/box.dart",
    "package:flutter/src/rendering/box.dart",
    "file:///C:/flutter/packages/flutter/lib/src/rendering/mouse_cursor.dart",
    "file:///C:/flutter/packages/flutter/lib/src/rendering/mouse_tracking.dart",
    "package:flutter/src/rendering/mouse_tracking.dart",
    "package:flutter/src/rendering/mouse_cursor.dart",
    "file:///C:/flutter/packages/flutter/lib/src/rendering/binding.dart",
    "package:flutter/src/rendering/binding.dart",
    "file:///C:/flutter/packages/flutter/lib/src/rendering/debug.dart"
  ];
  var annotation$ = dart.privateName(layer$, "AnnotationEntry.annotation");
  var localPosition$ = dart.privateName(layer$, "AnnotationEntry.localPosition");
  const _is_AnnotationEntry_default = Symbol('_is_AnnotationEntry_default');
  layer$.AnnotationEntry$ = dart.generic(T => {
    class AnnotationEntry extends core.Object {
      get annotation() {
        return this[annotation$];
      }
      set annotation(value) {
        super.annotation = value;
      }
      get localPosition() {
        return this[localPosition$];
      }
      set localPosition(value) {
        super.localPosition = value;
      }
      toString() {
        return dart.str(object.objectRuntimeType(this, "AnnotationEntry")) + "(annotation: " + dart.str(this.annotation) + ", localPosition: " + dart.str(this.localPosition) + ")";
      }
    }
    (AnnotationEntry.new = function(opts) {
      let annotation = opts && 'annotation' in opts ? opts.annotation : null;
      let localPosition = opts && 'localPosition' in opts ? opts.localPosition : null;
      if (localPosition == null) dart.nullFailed(I[0], 25, 19, "localPosition");
      this[annotation$] = annotation;
      this[localPosition$] = localPosition;
      if (!(localPosition != null)) dart.assertFailed(null, I[0], 26, 15, "localPosition != null");
      ;
    }).prototype = AnnotationEntry.prototype;
    dart.addTypeTests(AnnotationEntry);
    AnnotationEntry.prototype[_is_AnnotationEntry_default] = true;
    dart.addTypeCaches(AnnotationEntry);
    dart.setLibraryUri(AnnotationEntry, I[1]);
    dart.setFieldSignature(AnnotationEntry, () => ({
      __proto__: dart.getFields(AnnotationEntry.__proto__),
      annotation: dart.finalFieldType(T),
      localPosition: dart.finalFieldType(ui.Offset)
    }));
    dart.defineExtensionMethods(AnnotationEntry, ['toString']);
    return AnnotationEntry;
  });
  layer$.AnnotationEntry = layer$.AnnotationEntry$();
  dart.addTypeTests(layer$.AnnotationEntry, _is_AnnotationEntry_default);
  var _entries = dart.privateName(layer$, "_entries");
  const _is_AnnotationResult_default = Symbol('_is_AnnotationResult_default');
  layer$.AnnotationResult$ = dart.generic(T => {
    var AnnotationEntryOfT = () => (AnnotationEntryOfT = dart.constFn(layer$.AnnotationEntry$(T)))();
    var JSArrayOfAnnotationEntryOfT = () => (JSArrayOfAnnotationEntryOfT = dart.constFn(_interceptors.JSArray$(AnnotationEntryOfT())))();
    var SyncIterableOfT = () => (SyncIterableOfT = dart.constFn(_js_helper.SyncIterable$(T)))();
    class AnnotationResult extends core.Object {
      add(entry) {
        AnnotationEntryOfT().as(entry);
        if (entry == null) dart.nullFailed(I[0], 56, 31, "entry");
        return this[_entries][$add](entry);
      }
      get entries() {
        return this[_entries];
      }
      get annotations() {
        return new (SyncIterableOfT()).new((function* annotations() {
          for (let entry of this[_entries])
            yield entry.annotation;
        }).bind(this));
      }
    }
    (AnnotationResult.new = function() {
      this[_entries] = JSArrayOfAnnotationEntryOfT().of([]);
      ;
    }).prototype = AnnotationResult.prototype;
    dart.addTypeTests(AnnotationResult);
    AnnotationResult.prototype[_is_AnnotationResult_default] = true;
    dart.addTypeCaches(AnnotationResult);
    dart.setMethodSignature(AnnotationResult, () => ({
      __proto__: dart.getMethods(AnnotationResult.__proto__),
      add: dart.fnType(dart.void, [dart.nullable(core.Object)])
    }));
    dart.setGetterSignature(AnnotationResult, () => ({
      __proto__: dart.getGetters(AnnotationResult.__proto__),
      entries: core.Iterable$(layer$.AnnotationEntry$(T)),
      annotations: core.Iterable$(T)
    }));
    dart.setLibraryUri(AnnotationResult, I[1]);
    dart.setFieldSignature(AnnotationResult, () => ({
      __proto__: dart.getFields(AnnotationResult.__proto__),
      [_entries]: dart.finalFieldType(core.List$(layer$.AnnotationEntry$(T)))
    }));
    return AnnotationResult;
  });
  layer$.AnnotationResult = layer$.AnnotationResult$();
  dart.addTypeTests(layer$.AnnotationResult, _is_AnnotationResult_default);
  var debugCreator = dart.privateName(layer$, "Layer.debugCreator");
  var _needsAddToScene = dart.privateName(layer$, "_needsAddToScene");
  var _engineLayer = dart.privateName(layer$, "_engineLayer");
  var _nextSibling = dart.privateName(layer$, "_nextSibling");
  var _previousSibling = dart.privateName(layer$, "_previousSibling");
  var _removeChild = dart.privateName(layer$, "_removeChild");
  var _addToSceneWithRetainedRendering = dart.privateName(layer$, "_addToSceneWithRetainedRendering");
  const AbstractNode_DiagnosticableTreeMixin$36 = class AbstractNode_DiagnosticableTreeMixin extends node.AbstractNode {};
  (AbstractNode_DiagnosticableTreeMixin$36.new = function() {
    AbstractNode_DiagnosticableTreeMixin$36.__proto__.new.call(this);
  }).prototype = AbstractNode_DiagnosticableTreeMixin$36.prototype;
  dart.applyMixin(AbstractNode_DiagnosticableTreeMixin$36, diagnostics.DiagnosticableTreeMixin);
  layer$.Layer = class Layer extends AbstractNode_DiagnosticableTreeMixin$36 {
    get debugCreator() {
      return this[debugCreator];
    }
    set debugCreator(value) {
      this[debugCreator] = value;
    }
    get parent() {
      return T$.ContainerLayerN().as(super.parent);
    }
    markNeedsAddToScene() {
      if (!!dart.test(this.alwaysNeedsAddToScene)) dart.assertFailed(dart.str(this[$runtimeType]) + " with alwaysNeedsAddToScene set called markNeedsAddToScene.\n" + "The layer's alwaysNeedsAddToScene is set to true, and therefore it should not call markNeedsAddToScene.", I[0], 133, 7, "!alwaysNeedsAddToScene");
      if (dart.test(this[_needsAddToScene])) {
        return;
      }
      this[_needsAddToScene] = true;
    }
    debugMarkClean() {
      if (!dart.test(dart.fn(() => {
        this[_needsAddToScene] = false;
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[0], 152, 12, "() {\r\n      _needsAddToScene = false;\r\n      return true;\r\n    }()");
    }
    get alwaysNeedsAddToScene() {
      return false;
    }
    get debugSubtreeNeedsAddToScene() {
      let result = null;
      if (!dart.test(dart.fn(() => {
        result = this[_needsAddToScene];
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[0], 169, 12, "() {\r\n      result = _needsAddToScene;\r\n      return true;\r\n    }()");
      return result;
    }
    get engineLayer() {
      return this[_engineLayer];
    }
    set engineLayer(value) {
      this[_engineLayer] = value;
      if (!dart.test(this.alwaysNeedsAddToScene)) {
        if (this.parent != null && !dart.test(dart.nullCheck(this.parent).alwaysNeedsAddToScene)) {
          dart.nullCheck(this.parent).markNeedsAddToScene();
        }
      }
    }
    updateSubtreeNeedsAddToScene() {
      this[_needsAddToScene] = dart.test(this[_needsAddToScene]) || dart.test(this.alwaysNeedsAddToScene);
    }
    get nextSibling() {
      return this[_nextSibling];
    }
    get previousSibling() {
      return this[_previousSibling];
    }
    dropChild(child) {
      node.AbstractNode.as(child);
      if (child == null) dart.nullFailed(I[0], 252, 31, "child");
      if (!dart.test(this.alwaysNeedsAddToScene)) {
        this.markNeedsAddToScene();
      }
      super.dropChild(child);
    }
    adoptChild(child) {
      node.AbstractNode.as(child);
      if (child == null) dart.nullFailed(I[0], 260, 32, "child");
      if (!dart.test(this.alwaysNeedsAddToScene)) {
        this.markNeedsAddToScene();
      }
      super.adoptChild(child);
    }
    remove() {
      let t0;
      t0 = this.parent;
      t0 == null ? null : t0[_removeChild](this);
    }
    findAnnotations(S, result, localPosition, opts) {
      if (result == null) dart.nullFailed(I[0], 327, 25, "result");
      if (localPosition == null) dart.nullFailed(I[0], 328, 12, "localPosition");
      let onlyFirst = opts && 'onlyFirst' in opts ? opts.onlyFirst : null;
      if (onlyFirst == null) dart.nullFailed(I[0], 329, 19, "onlyFirst");
      return false;
    }
    find(S, localPosition) {
      if (localPosition == null) dart.nullFailed(I[0], 354, 36, "localPosition");
      let result = new (layer$.AnnotationResult$(S)).new();
      this.findAnnotations(S, result, localPosition, {onlyFirst: true});
      return dart.test(result.entries[$isEmpty]) ? null : result.entries[$first].annotation;
    }
    findAllAnnotations(S, localPosition) {
      if (localPosition == null) dart.nullFailed(I[0], 380, 67, "localPosition");
      let result = new (layer$.AnnotationResult$(S)).new();
      this.findAnnotations(S, result, localPosition, {onlyFirst: false});
      return result;
    }
    [_addToSceneWithRetainedRendering](builder) {
      if (builder == null) dart.nullFailed(I[0], 393, 57, "builder");
      if (!dart.test(this[_needsAddToScene]) && this[_engineLayer] != null) {
        builder.addRetained(dart.nullCheck(this[_engineLayer]));
        return;
      }
      this.addToScene(builder);
      this[_needsAddToScene] = false;
    }
    toStringShort() {
      return dart.str(super.toStringShort()) + (this.owner == null ? " DETACHED" : "");
    }
    debugFillProperties(properties) {
      if (properties == null) dart.nullFailed(I[0], 424, 56, "properties");
      super.debugFillProperties(properties);
      properties.add(new (T$.DiagnosticsPropertyOfObject()).new("owner", this.owner, {level: this.parent != null ? diagnostics.DiagnosticLevel.hidden : diagnostics.DiagnosticLevel.info, defaultValue: null}));
      properties.add(new diagnostics.DiagnosticsProperty.new("creator", this.debugCreator, {defaultValue: null, level: diagnostics.DiagnosticLevel.debug}));
      properties.add(new (T$.DiagnosticsPropertyOfString()).new("engine layer", diagnostics.describeIdentity(this[_engineLayer])));
    }
  };
  (layer$.Layer.new = function() {
    this[_needsAddToScene] = true;
    this[_engineLayer] = null;
    this[_nextSibling] = null;
    this[_previousSibling] = null;
    this[debugCreator] = null;
    layer$.Layer.__proto__.new.call(this);
    ;
  }).prototype = layer$.Layer.prototype;
  dart.addTypeTests(layer$.Layer);
  dart.addTypeCaches(layer$.Layer);
  dart.setMethodSignature(layer$.Layer, () => ({
    __proto__: dart.getMethods(layer$.Layer.__proto__),
    markNeedsAddToScene: dart.fnType(dart.void, []),
    debugMarkClean: dart.fnType(dart.void, []),
    updateSubtreeNeedsAddToScene: dart.fnType(dart.void, []),
    remove: dart.fnType(dart.void, []),
    findAnnotations: dart.gFnType(S => [core.bool, [layer$.AnnotationResult$(S), ui.Offset], {}, {onlyFirst: core.bool}], S => [core.Object]),
    find: dart.gFnType(S => [dart.nullable(S), [ui.Offset]], S => [core.Object]),
    findAllAnnotations: dart.gFnType(S => [layer$.AnnotationResult$(S), [ui.Offset]], S => [core.Object]),
    [_addToSceneWithRetainedRendering]: dart.fnType(dart.void, [ui.SceneBuilder])
  }));
  dart.setGetterSignature(layer$.Layer, () => ({
    __proto__: dart.getGetters(layer$.Layer.__proto__),
    parent: dart.nullable(layer$.ContainerLayer),
    alwaysNeedsAddToScene: core.bool,
    debugSubtreeNeedsAddToScene: dart.nullable(core.bool),
    engineLayer: dart.nullable(ui.EngineLayer),
    nextSibling: dart.nullable(layer$.Layer),
    previousSibling: dart.nullable(layer$.Layer)
  }));
  dart.setSetterSignature(layer$.Layer, () => ({
    __proto__: dart.getSetters(layer$.Layer.__proto__),
    engineLayer: dart.nullable(ui.EngineLayer)
  }));
  dart.setLibraryUri(layer$.Layer, I[1]);
  dart.setFieldSignature(layer$.Layer, () => ({
    __proto__: dart.getFields(layer$.Layer.__proto__),
    [_needsAddToScene]: dart.fieldType(core.bool),
    [_engineLayer]: dart.fieldType(dart.nullable(ui.EngineLayer)),
    [_nextSibling]: dart.fieldType(dart.nullable(layer$.Layer)),
    [_previousSibling]: dart.fieldType(dart.nullable(layer$.Layer)),
    debugCreator: dart.fieldType(dart.dynamic)
  }));
  var canvasBounds$ = dart.privateName(layer$, "PictureLayer.canvasBounds");
  var _picture = dart.privateName(layer$, "_picture");
  var _isComplexHint = dart.privateName(layer$, "_isComplexHint");
  var _willChangeHint = dart.privateName(layer$, "_willChangeHint");
  var OffsetBase__dy = dart.privateName(ui, "OffsetBase._dy");
  var OffsetBase__dx = dart.privateName(ui, "OffsetBase._dx");
  layer$.PictureLayer = class PictureLayer extends layer$.Layer {
    get canvasBounds() {
      return this[canvasBounds$];
    }
    set canvasBounds(value) {
      super.canvasBounds = value;
    }
    get picture() {
      return this[_picture];
    }
    set picture(picture) {
      this.markNeedsAddToScene();
      this[_picture] = picture;
    }
    get isComplexHint() {
      return this[_isComplexHint];
    }
    set isComplexHint(value) {
      if (value == null) dart.nullFailed(I[0], 470, 26, "value");
      if (value != this[_isComplexHint]) {
        this[_isComplexHint] = value;
        this.markNeedsAddToScene();
      }
    }
    get willChangeHint() {
      return this[_willChangeHint];
    }
    set willChangeHint(value) {
      if (value == null) dart.nullFailed(I[0], 488, 27, "value");
      if (value != this[_willChangeHint]) {
        this[_willChangeHint] = value;
        this.markNeedsAddToScene();
      }
    }
    addToScene(builder, layerOffset = C[0] || CT.C0) {
      if (builder == null) dart.nullFailed(I[0], 496, 35, "builder");
      if (layerOffset == null) dart.nullFailed(I[0], 496, 53, "layerOffset");
      if (!(this.picture != null)) dart.assertFailed(null, I[0], 497, 12, "picture != null");
      builder.addPicture(layerOffset, dart.nullCheck(this.picture), {isComplexHint: this.isComplexHint, willChangeHint: this.willChangeHint});
    }
    debugFillProperties(properties) {
      if (properties == null) dart.nullFailed(I[0], 502, 56, "properties");
      super.debugFillProperties(properties);
      properties.add(new (T$.DiagnosticsPropertyOfRect()).new("paint bounds", this.canvasBounds));
      properties.add(new (T$.DiagnosticsPropertyOfString()).new("picture", diagnostics.describeIdentity(this[_picture])));
      properties.add(new (T$.DiagnosticsPropertyOfString()).new("raster cache hints", "isComplex = " + dart.str(this.isComplexHint) + ", willChange = " + dart.str(this.willChangeHint)));
    }
    findAnnotations(S, result, localPosition, opts) {
      if (result == null) dart.nullFailed(I[0], 513, 62, "result");
      if (localPosition == null) dart.nullFailed(I[0], 513, 77, "localPosition");
      let onlyFirst = opts && 'onlyFirst' in opts ? opts.onlyFirst : null;
      if (onlyFirst == null) dart.nullFailed(I[0], 513, 108, "onlyFirst");
      return false;
    }
  };
  (layer$.PictureLayer.new = function(canvasBounds) {
    if (canvasBounds == null) dart.nullFailed(I[0], 437, 21, "canvasBounds");
    this[_picture] = null;
    this[_isComplexHint] = false;
    this[_willChangeHint] = false;
    this[canvasBounds$] = canvasBounds;
    layer$.PictureLayer.__proto__.new.call(this);
    ;
  }).prototype = layer$.PictureLayer.prototype;
  dart.addTypeTests(layer$.PictureLayer);
  dart.addTypeCaches(layer$.PictureLayer);
  dart.setMethodSignature(layer$.PictureLayer, () => ({
    __proto__: dart.getMethods(layer$.PictureLayer.__proto__),
    addToScene: dart.fnType(dart.void, [ui.SceneBuilder], [ui.Offset]),
    findAnnotations: dart.gFnType(S => [core.bool, [layer$.AnnotationResult$(S), ui.Offset], {}, {onlyFirst: core.bool}], S => [core.Object])
  }));
  dart.setGetterSignature(layer$.PictureLayer, () => ({
    __proto__: dart.getGetters(layer$.PictureLayer.__proto__),
    picture: dart.nullable(ui.Picture),
    isComplexHint: core.bool,
    willChangeHint: core.bool
  }));
  dart.setSetterSignature(layer$.PictureLayer, () => ({
    __proto__: dart.getSetters(layer$.PictureLayer.__proto__),
    picture: dart.nullable(ui.Picture),
    isComplexHint: core.bool,
    willChangeHint: core.bool
  }));
  dart.setLibraryUri(layer$.PictureLayer, I[1]);
  dart.setFieldSignature(layer$.PictureLayer, () => ({
    __proto__: dart.getFields(layer$.PictureLayer.__proto__),
    canvasBounds: dart.finalFieldType(ui.Rect),
    [_picture]: dart.fieldType(dart.nullable(ui.Picture)),
    [_isComplexHint]: dart.fieldType(core.bool),
    [_willChangeHint]: dart.fieldType(core.bool)
  }));
  var rect$ = dart.privateName(layer$, "TextureLayer.rect");
  var textureId$ = dart.privateName(layer$, "TextureLayer.textureId");
  var freeze$ = dart.privateName(layer$, "TextureLayer.freeze");
  var filterQuality$ = dart.privateName(layer$, "TextureLayer.filterQuality");
  var _name = dart.privateName(ui, "_name");
  layer$.TextureLayer = class TextureLayer extends layer$.Layer {
    get rect() {
      return this[rect$];
    }
    set rect(value) {
      super.rect = value;
    }
    get textureId() {
      return this[textureId$];
    }
    set textureId(value) {
      super.textureId = value;
    }
    get freeze() {
      return this[freeze$];
    }
    set freeze(value) {
      super.freeze = value;
    }
    get filterQuality() {
      return this[filterQuality$];
    }
    set filterQuality(value) {
      super.filterQuality = value;
    }
    addToScene(builder, layerOffset = C[0] || CT.C0) {
      if (builder == null) dart.nullFailed(I[0], 575, 35, "builder");
      if (layerOffset == null) dart.nullFailed(I[0], 575, 53, "layerOffset");
      let shiftedRect = dart.equals(layerOffset, ui.Offset.zero) ? this.rect : this.rect.shift(layerOffset);
      builder.addTexture(this.textureId, {offset: shiftedRect.topLeft, width: shiftedRect.width, height: shiftedRect.height, freeze: this.freeze, filterQuality: this.filterQuality});
    }
    findAnnotations(S, result, localPosition, opts) {
      if (result == null) dart.nullFailed(I[0], 588, 62, "result");
      if (localPosition == null) dart.nullFailed(I[0], 588, 77, "localPosition");
      let onlyFirst = opts && 'onlyFirst' in opts ? opts.onlyFirst : null;
      if (onlyFirst == null) dart.nullFailed(I[0], 588, 108, "onlyFirst");
      return false;
    }
  };
  (layer$.TextureLayer.new = function(opts) {
    let rect = opts && 'rect' in opts ? opts.rect : null;
    if (rect == null) dart.nullFailed(I[0], 549, 19, "rect");
    let textureId = opts && 'textureId' in opts ? opts.textureId : null;
    if (textureId == null) dart.nullFailed(I[0], 550, 19, "textureId");
    let freeze = opts && 'freeze' in opts ? opts.freeze : false;
    if (freeze == null) dart.nullFailed(I[0], 551, 10, "freeze");
    let filterQuality = opts && 'filterQuality' in opts ? opts.filterQuality : C[1] || CT.C1;
    if (filterQuality == null) dart.nullFailed(I[0], 552, 10, "filterQuality");
    this[rect$] = rect;
    this[textureId$] = textureId;
    this[freeze$] = freeze;
    this[filterQuality$] = filterQuality;
    if (!(rect != null)) dart.assertFailed(null, I[0], 553, 15, "rect != null");
    if (!(textureId != null)) dart.assertFailed(null, I[0], 554, 15, "textureId != null");
    layer$.TextureLayer.__proto__.new.call(this);
    ;
  }).prototype = layer$.TextureLayer.prototype;
  dart.addTypeTests(layer$.TextureLayer);
  dart.addTypeCaches(layer$.TextureLayer);
  dart.setMethodSignature(layer$.TextureLayer, () => ({
    __proto__: dart.getMethods(layer$.TextureLayer.__proto__),
    addToScene: dart.fnType(dart.void, [ui.SceneBuilder], [ui.Offset]),
    findAnnotations: dart.gFnType(S => [core.bool, [layer$.AnnotationResult$(S), ui.Offset], {}, {onlyFirst: core.bool}], S => [core.Object])
  }));
  dart.setLibraryUri(layer$.TextureLayer, I[1]);
  dart.setFieldSignature(layer$.TextureLayer, () => ({
    __proto__: dart.getFields(layer$.TextureLayer.__proto__),
    rect: dart.finalFieldType(ui.Rect),
    textureId: dart.finalFieldType(core.int),
    freeze: dart.finalFieldType(core.bool),
    filterQuality: dart.finalFieldType(ui.FilterQuality)
  }));
  var rect$0 = dart.privateName(layer$, "PlatformViewLayer.rect");
  var viewId$ = dart.privateName(layer$, "PlatformViewLayer.viewId");
  layer$.PlatformViewLayer = class PlatformViewLayer extends layer$.Layer {
    get rect() {
      return this[rect$0];
    }
    set rect(value) {
      super.rect = value;
    }
    get viewId() {
      return this[viewId$];
    }
    set viewId(value) {
      super.viewId = value;
    }
    addToScene(builder, layerOffset = C[0] || CT.C0) {
      if (builder == null) dart.nullFailed(I[0], 614, 35, "builder");
      if (layerOffset == null) dart.nullFailed(I[0], 614, 53, "layerOffset");
      let shiftedRect = dart.equals(layerOffset, ui.Offset.zero) ? this.rect : this.rect.shift(layerOffset);
      builder.addPlatformView(this.viewId, {offset: shiftedRect.topLeft, width: shiftedRect.width, height: shiftedRect.height});
    }
  };
  (layer$.PlatformViewLayer.new = function(opts) {
    let rect = opts && 'rect' in opts ? opts.rect : null;
    if (rect == null) dart.nullFailed(I[0], 600, 19, "rect");
    let viewId = opts && 'viewId' in opts ? opts.viewId : null;
    if (viewId == null) dart.nullFailed(I[0], 601, 19, "viewId");
    this[rect$0] = rect;
    this[viewId$] = viewId;
    if (!(rect != null)) dart.assertFailed(null, I[0], 602, 15, "rect != null");
    if (!(viewId != null)) dart.assertFailed(null, I[0], 603, 15, "viewId != null");
    layer$.PlatformViewLayer.__proto__.new.call(this);
    ;
  }).prototype = layer$.PlatformViewLayer.prototype;
  dart.addTypeTests(layer$.PlatformViewLayer);
  dart.addTypeCaches(layer$.PlatformViewLayer);
  dart.setMethodSignature(layer$.PlatformViewLayer, () => ({
    __proto__: dart.getMethods(layer$.PlatformViewLayer.__proto__),
    addToScene: dart.fnType(dart.void, [ui.SceneBuilder], [ui.Offset])
  }));
  dart.setLibraryUri(layer$.PlatformViewLayer, I[1]);
  dart.setFieldSignature(layer$.PlatformViewLayer, () => ({
    __proto__: dart.getFields(layer$.PlatformViewLayer.__proto__),
    rect: dart.finalFieldType(ui.Rect),
    viewId: dart.finalFieldType(core.int)
  }));
  var optionsMask$ = dart.privateName(layer$, "PerformanceOverlayLayer.optionsMask");
  var rasterizerThreshold$ = dart.privateName(layer$, "PerformanceOverlayLayer.rasterizerThreshold");
  var checkerboardRasterCacheImages$ = dart.privateName(layer$, "PerformanceOverlayLayer.checkerboardRasterCacheImages");
  var checkerboardOffscreenLayers$ = dart.privateName(layer$, "PerformanceOverlayLayer.checkerboardOffscreenLayers");
  var _overlayRect = dart.privateName(layer$, "_overlayRect");
  layer$.PerformanceOverlayLayer = class PerformanceOverlayLayer extends layer$.Layer {
    get optionsMask() {
      return this[optionsMask$];
    }
    set optionsMask(value) {
      super.optionsMask = value;
    }
    get rasterizerThreshold() {
      return this[rasterizerThreshold$];
    }
    set rasterizerThreshold(value) {
      super.rasterizerThreshold = value;
    }
    get checkerboardRasterCacheImages() {
      return this[checkerboardRasterCacheImages$];
    }
    set checkerboardRasterCacheImages(value) {
      super.checkerboardRasterCacheImages = value;
    }
    get checkerboardOffscreenLayers() {
      return this[checkerboardOffscreenLayers$];
    }
    set checkerboardOffscreenLayers(value) {
      super.checkerboardOffscreenLayers = value;
    }
    get overlayRect() {
      return this[_overlayRect];
    }
    set overlayRect(value) {
      if (value == null) dart.nullFailed(I[0], 645, 24, "value");
      if (!dart.equals(value, this[_overlayRect])) {
        this[_overlayRect] = value;
        this.markNeedsAddToScene();
      }
    }
    addToScene(builder, layerOffset = C[0] || CT.C0) {
      if (builder == null) dart.nullFailed(I[0], 685, 35, "builder");
      if (layerOffset == null) dart.nullFailed(I[0], 685, 53, "layerOffset");
      if (!(this.optionsMask != null)) dart.assertFailed(null, I[0], 686, 12, "optionsMask != null");
      let shiftedOverlayRect = dart.equals(layerOffset, ui.Offset.zero) ? this.overlayRect : this.overlayRect.shift(layerOffset);
      builder.addPerformanceOverlay(this.optionsMask, shiftedOverlayRect);
      builder.setRasterizerTracingThreshold(this.rasterizerThreshold);
      builder.setCheckerboardRasterCacheImages(this.checkerboardRasterCacheImages);
      builder.setCheckerboardOffscreenLayers(this.checkerboardOffscreenLayers);
    }
    findAnnotations(S, result, localPosition, opts) {
      if (result == null) dart.nullFailed(I[0], 695, 62, "result");
      if (localPosition == null) dart.nullFailed(I[0], 695, 77, "localPosition");
      let onlyFirst = opts && 'onlyFirst' in opts ? opts.onlyFirst : null;
      if (onlyFirst == null) dart.nullFailed(I[0], 695, 108, "onlyFirst");
      return false;
    }
  };
  (layer$.PerformanceOverlayLayer.new = function(opts) {
    let overlayRect = opts && 'overlayRect' in opts ? opts.overlayRect : null;
    if (overlayRect == null) dart.nullFailed(I[0], 632, 19, "overlayRect");
    let optionsMask = opts && 'optionsMask' in opts ? opts.optionsMask : null;
    if (optionsMask == null) dart.nullFailed(I[0], 633, 19, "optionsMask");
    let rasterizerThreshold = opts && 'rasterizerThreshold' in opts ? opts.rasterizerThreshold : null;
    if (rasterizerThreshold == null) dart.nullFailed(I[0], 634, 19, "rasterizerThreshold");
    let checkerboardRasterCacheImages = opts && 'checkerboardRasterCacheImages' in opts ? opts.checkerboardRasterCacheImages : null;
    if (checkerboardRasterCacheImages == null) dart.nullFailed(I[0], 635, 19, "checkerboardRasterCacheImages");
    let checkerboardOffscreenLayers = opts && 'checkerboardOffscreenLayers' in opts ? opts.checkerboardOffscreenLayers : null;
    if (checkerboardOffscreenLayers == null) dart.nullFailed(I[0], 636, 19, "checkerboardOffscreenLayers");
    this[optionsMask$] = optionsMask;
    this[rasterizerThreshold$] = rasterizerThreshold;
    this[checkerboardRasterCacheImages$] = checkerboardRasterCacheImages;
    this[checkerboardOffscreenLayers$] = checkerboardOffscreenLayers;
    this[_overlayRect] = overlayRect;
    layer$.PerformanceOverlayLayer.__proto__.new.call(this);
    ;
  }).prototype = layer$.PerformanceOverlayLayer.prototype;
  dart.addTypeTests(layer$.PerformanceOverlayLayer);
  dart.addTypeCaches(layer$.PerformanceOverlayLayer);
  dart.setMethodSignature(layer$.PerformanceOverlayLayer, () => ({
    __proto__: dart.getMethods(layer$.PerformanceOverlayLayer.__proto__),
    addToScene: dart.fnType(dart.void, [ui.SceneBuilder], [ui.Offset]),
    findAnnotations: dart.gFnType(S => [core.bool, [layer$.AnnotationResult$(S), ui.Offset], {}, {onlyFirst: core.bool}], S => [core.Object])
  }));
  dart.setGetterSignature(layer$.PerformanceOverlayLayer, () => ({
    __proto__: dart.getGetters(layer$.PerformanceOverlayLayer.__proto__),
    overlayRect: ui.Rect
  }));
  dart.setSetterSignature(layer$.PerformanceOverlayLayer, () => ({
    __proto__: dart.getSetters(layer$.PerformanceOverlayLayer.__proto__),
    overlayRect: ui.Rect
  }));
  dart.setLibraryUri(layer$.PerformanceOverlayLayer, I[1]);
  dart.setFieldSignature(layer$.PerformanceOverlayLayer, () => ({
    __proto__: dart.getFields(layer$.PerformanceOverlayLayer.__proto__),
    [_overlayRect]: dart.fieldType(ui.Rect),
    optionsMask: dart.finalFieldType(core.int),
    rasterizerThreshold: dart.finalFieldType(core.int),
    checkerboardRasterCacheImages: dart.finalFieldType(core.bool),
    checkerboardOffscreenLayers: dart.finalFieldType(core.bool)
  }));
  var _firstChild = dart.privateName(layer$, "_firstChild");
  var _lastChild = dart.privateName(layer$, "_lastChild");
  var _debugCheckElevations = dart.privateName(layer$, "_debugCheckElevations");
  var _debugUltimatePreviousSiblingOf = dart.privateName(layer$, "_debugUltimatePreviousSiblingOf");
  var _debugUltimateNextSiblingOf = dart.privateName(layer$, "_debugUltimateNextSiblingOf");
  var Color_value = dart.privateName(ui, "Color.value");
  var _highlightConflictingLayer = dart.privateName(layer$, "_highlightConflictingLayer");
  var _processConflictingPhysicalLayers = dart.privateName(layer$, "_processConflictingPhysicalLayers");
  var _debugTransformedClipPath = dart.privateName(layer$, "_debugTransformedClipPath");
  layer$.ContainerLayer = class ContainerLayer extends layer$.Layer {
    get firstChild() {
      return this[_firstChild];
    }
    get lastChild() {
      return this[_lastChild];
    }
    get hasChildren() {
      return this[_firstChild] != null;
    }
    buildScene(builder) {
      if (builder == null) dart.nullFailed(I[0], 723, 39, "builder");
      let temporaryLayers = null;
      if (!dart.test(dart.fn(() => {
        if (dart.test(debug$0.debugCheckElevationsEnabled)) {
          temporaryLayers = this[_debugCheckElevations]();
        }
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[0], 725, 12, "() {\r\n      if (debugCheckElevationsEnabled) {\r\n        temporaryLayers = _debugCheckElevations();\r\n      }\r\n      return true;\r\n    }()");
      this.updateSubtreeNeedsAddToScene();
      this.addToScene(builder);
      this[_needsAddToScene] = false;
      let scene = builder.build();
      if (!dart.test(dart.fn(() => {
        if (temporaryLayers != null) {
          for (let temporaryLayer of dart.nullCheck(temporaryLayers)) {
            temporaryLayer.remove();
          }
        }
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[0], 738, 12, "() {\r\n      // We should remove any layers that got added to highlight the incorrect\r\n      // PhysicalModelLayers. If we don't, we'll end up adding duplicate layers\r\n      // or continuing to render stale outlines.\r\n      if (temporaryLayers != null) {\r\n        for (final PictureLayer temporaryLayer in temporaryLayers!) {\r\n          temporaryLayer.remove();\r\n        }\r\n      }\r\n      return true;\r\n    }()");
      return scene;
    }
    [_debugUltimatePreviousSiblingOf](child, opts) {
      if (child == null) dart.nullFailed(I[0], 752, 46, "child");
      let equals = opts && 'equals' in opts ? opts.equals : null;
      if (!(child.attached == this.attached)) dart.assertFailed(null, I[0], 753, 12, "child.attached == attached");
      while (child.previousSibling != null) {
        if (!!dart.equals(child.previousSibling, child)) dart.assertFailed(null, I[0], 755, 14, "child.previousSibling != child");
        child = dart.nullCheck(child.previousSibling);
        if (!(child.attached == this.attached)) dart.assertFailed(null, I[0], 757, 14, "child.attached == attached");
      }
      return dart.equals(child, equals);
    }
    [_debugUltimateNextSiblingOf](child, opts) {
      if (child == null) dart.nullFailed(I[0], 762, 42, "child");
      let equals = opts && 'equals' in opts ? opts.equals : null;
      if (!(child.attached == this.attached)) dart.assertFailed(null, I[0], 763, 12, "child.attached == attached");
      while (child[_nextSibling] != null) {
        if (!!dart.equals(child[_nextSibling], child)) dart.assertFailed(null, I[0], 765, 14, "child._nextSibling != child");
        child = dart.nullCheck(child[_nextSibling]);
        if (!(child.attached == this.attached)) dart.assertFailed(null, I[0], 767, 14, "child.attached == attached");
      }
      return dart.equals(child, equals);
    }
    [_highlightConflictingLayer](child) {
      let t0, t0$;
      if (child == null) dart.nullFailed(I[0], 772, 62, "child");
      let recorder = ui.PictureRecorder.new();
      let canvas = ui.Canvas.new(recorder);
      canvas.drawPath(dart.nullCheck(child.clipPath), (t0 = ui.Paint.new(), (() => {
        t0.color = C[2] || CT.C2;
        t0.style = ui.PaintingStyle.stroke;
        t0.strokeWidth = dart.nullCheck(child.elevation) + 10.0;
        return t0;
      })()));
      let pictureLayer = (t0$ = new layer$.PictureLayer.new(dart.nullCheck(child.clipPath).getBounds()), (() => {
        t0$.picture = recorder.endRecording();
        t0$.debugCreator = child;
        return t0$;
      })());
      child.append(pictureLayer);
      return pictureLayer;
    }
    [_processConflictingPhysicalLayers](predecessor, child) {
      if (predecessor == null) dart.nullFailed(I[0], 791, 75, "predecessor");
      if (child == null) dart.nullFailed(I[0], 791, 107, "child");
      assertions.FlutterError.reportError(new assertions.FlutterErrorDetails.new({exception: assertions.FlutterError.new("Painting order is out of order with respect to elevation.\n" + "See https://api.flutter.dev/flutter/rendering/debugCheckElevationsEnabled.html " + "for more details."), library: "rendering library", context: new assertions.ErrorDescription.new("during compositing"), informationCollector: dart.fn(() => T$.JSArrayOfDiagnosticsNode().of([child.toDiagnosticsNode({name: "Attempted to composite layer", style: diagnostics.DiagnosticsTreeStyle.errorProperty}), predecessor.toDiagnosticsNode({name: "after layer", style: diagnostics.DiagnosticsTreeStyle.errorProperty}), new assertions.ErrorDescription.new("which occupies the same area at a higher elevation.")]), T$.VoidToListOfDiagnosticsNode())}));
      return T$.JSArrayOfPictureLayer().of([this[_highlightConflictingLayer](predecessor), this[_highlightConflictingLayer](child)]);
    }
    [_debugCheckElevations]() {
      let t0;
      let physicalModelLayers = this.depthFirstIterateChildren()[$whereType](layer$.PhysicalModelLayer)[$toList]();
      let addedLayers = T$.JSArrayOfPictureLayer().of([]);
      for (let i = 0; i < dart.notNull(physicalModelLayers[$length]); i = i + 1) {
        let physicalModelLayer = physicalModelLayers[$_get](i);
        if (!!dart.equals((t0 = physicalModelLayer.lastChild, t0 == null ? null : t0.debugCreator), physicalModelLayer)) dart.assertFailed("debugCheckElevations has either already visited this layer or failed " + "to remove the added picture from it.", I[0], 825, 9, "physicalModelLayer.lastChild?.debugCreator != physicalModelLayer");
        let accumulatedElevation = dart.nullCheck(physicalModelLayer.elevation);
        let ancestor = physicalModelLayer.parent;
        while (ancestor != null) {
          if (layer$.PhysicalModelLayer.is(ancestor)) {
            accumulatedElevation = accumulatedElevation + dart.nullCheck(ancestor.elevation);
          }
          ancestor = ancestor.parent;
        }
        for (let j = 0; j <= i; j = j + 1) {
          let predecessor = physicalModelLayers[$_get](j);
          let predecessorAccumulatedElevation = dart.nullCheck(predecessor.elevation);
          ancestor = predecessor.parent;
          while (ancestor != null) {
            if (dart.equals(ancestor, predecessor)) {
              continue;
            }
            if (layer$.PhysicalModelLayer.is(ancestor)) {
              predecessorAccumulatedElevation = predecessorAccumulatedElevation + dart.nullCheck(ancestor.elevation);
            }
            ancestor = ancestor.parent;
          }
          if (predecessorAccumulatedElevation <= accumulatedElevation) {
            continue;
          }
          let intersection = ui.Path.combine(ui.PathOperation.intersect, predecessor[_debugTransformedClipPath], physicalModelLayer[_debugTransformedClipPath]);
          if (intersection != null && dart.test(intersection.computeMetrics()[$any](dart.fn(metric => {
            if (metric == null) dart.nullFailed(I[0], 858, 86, "metric");
            return dart.notNull(metric.length) > 0;
          }, T$.PathMetricTobool())))) {
            addedLayers[$addAll](this[_processConflictingPhysicalLayers](predecessor, physicalModelLayer));
          }
        }
      }
      return addedLayers;
    }
    updateSubtreeNeedsAddToScene() {
      super.updateSubtreeNeedsAddToScene();
      let child = this.firstChild;
      while (child != null) {
        child.updateSubtreeNeedsAddToScene();
        this[_needsAddToScene] = dart.test(this[_needsAddToScene]) || dart.test(child[_needsAddToScene]);
        child = child.nextSibling;
      }
    }
    findAnnotations(S, result, localPosition, opts) {
      if (result == null) dart.nullFailed(I[0], 878, 62, "result");
      if (localPosition == null) dart.nullFailed(I[0], 878, 77, "localPosition");
      let onlyFirst = opts && 'onlyFirst' in opts ? opts.onlyFirst : null;
      if (onlyFirst == null) dart.nullFailed(I[0], 878, 108, "onlyFirst");
      for (let child = this.lastChild; child != null; child = child.previousSibling) {
        let isAbsorbed = child.findAnnotations(S, result, localPosition, {onlyFirst: onlyFirst});
        if (dart.test(isAbsorbed)) return true;
        if (dart.test(onlyFirst) && dart.test(result.entries[$isNotEmpty])) return isAbsorbed;
      }
      return false;
    }
    attach(owner) {
      core.Object.as(owner);
      if (owner == null) dart.nullFailed(I[0], 890, 22, "owner");
      super.attach(owner);
      let child = this.firstChild;
      while (child != null) {
        child.attach(owner);
        child = child.nextSibling;
      }
    }
    detach() {
      super.detach();
      let child = this.firstChild;
      while (child != null) {
        child.detach();
        child = child.nextSibling;
      }
    }
    append(child) {
      if (child == null) dart.nullFailed(I[0], 910, 21, "child");
      if (!!dart.equals(child, this)) dart.assertFailed(null, I[0], 911, 12, "child != this");
      if (!!dart.equals(child, this.firstChild)) dart.assertFailed(null, I[0], 912, 12, "child != firstChild");
      if (!!dart.equals(child, this.lastChild)) dart.assertFailed(null, I[0], 913, 12, "child != lastChild");
      if (!(child.parent == null)) dart.assertFailed(null, I[0], 914, 12, "child.parent == null");
      if (!!dart.test(child.attached)) dart.assertFailed(null, I[0], 915, 12, "!child.attached");
      if (!(child.nextSibling == null)) dart.assertFailed(null, I[0], 916, 12, "child.nextSibling == null");
      if (!(child.previousSibling == null)) dart.assertFailed(null, I[0], 917, 12, "child.previousSibling == null");
      if (!dart.test(dart.fn(() => {
        let node = this;
        while (node.parent != null)
          node = dart.nullCheck(node.parent);
        if (!!node[$_equals](child)) dart.assertFailed(null, I[0], 922, 14, "node != child");
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[0], 918, 12, "() {\r\n      Layer node = this;\r\n      while (node.parent != null)\r\n        node = node.parent!;\r\n      assert(node != child); // indicates we are about to create a cycle\r\n      return true;\r\n    }()");
      this.adoptChild(child);
      child[_previousSibling] = this.lastChild;
      if (this.lastChild != null) dart.nullCheck(this.lastChild)[_nextSibling] = child;
      this[_lastChild] = child;
      this[_firstChild] == null ? this[_firstChild] = child : null;
      if (!(child.attached == this.attached)) dart.assertFailed(null, I[0], 931, 12, "child.attached == attached");
    }
    [_removeChild](child) {
      if (child == null) dart.nullFailed(I[0], 935, 27, "child");
      if (!dart.equals(child.parent, this)) dart.assertFailed(null, I[0], 936, 12, "child.parent == this");
      if (!(child.attached == this.attached)) dart.assertFailed(null, I[0], 937, 12, "child.attached == attached");
      if (!dart.test(this[_debugUltimatePreviousSiblingOf](child, {equals: this.firstChild}))) dart.assertFailed(null, I[0], 938, 12, "_debugUltimatePreviousSiblingOf(child, equals: firstChild)");
      if (!dart.test(this[_debugUltimateNextSiblingOf](child, {equals: this.lastChild}))) dart.assertFailed(null, I[0], 939, 12, "_debugUltimateNextSiblingOf(child, equals: lastChild)");
      if (child[_previousSibling] == null) {
        if (!dart.equals(this[_firstChild], child)) dart.assertFailed(null, I[0], 941, 14, "_firstChild == child");
        this[_firstChild] = child[_nextSibling];
      } else {
        dart.nullCheck(child[_previousSibling])[_nextSibling] = child.nextSibling;
      }
      if (child[_nextSibling] == null) {
        if (!dart.equals(this.lastChild, child)) dart.assertFailed(null, I[0], 947, 14, "lastChild == child");
        this[_lastChild] = child.previousSibling;
      } else {
        dart.nullCheck(child.nextSibling)[_previousSibling] = child.previousSibling;
      }
      if (!(this.firstChild == null === (this.lastChild == null))) dart.assertFailed(null, I[0], 952, 12, "(firstChild == null) == (lastChild == null)");
      if (!(this.firstChild == null || dart.nullCheck(this.firstChild).attached == this.attached)) dart.assertFailed(null, I[0], 953, 12, "firstChild == null || firstChild!.attached == attached");
      if (!(this.lastChild == null || dart.nullCheck(this.lastChild).attached == this.attached)) dart.assertFailed(null, I[0], 954, 12, "lastChild == null || lastChild!.attached == attached");
      if (!(this.firstChild == null || dart.test(this[_debugUltimateNextSiblingOf](dart.nullCheck(this.firstChild), {equals: this.lastChild})))) dart.assertFailed(null, I[0], 955, 12, "firstChild == null || _debugUltimateNextSiblingOf(firstChild!, equals: lastChild)");
      if (!(this.lastChild == null || dart.test(this[_debugUltimatePreviousSiblingOf](dart.nullCheck(this.lastChild), {equals: this.firstChild})))) dart.assertFailed(null, I[0], 956, 12, "lastChild == null || _debugUltimatePreviousSiblingOf(lastChild!, equals: firstChild)");
      child[_previousSibling] = null;
      child[_nextSibling] = null;
      this.dropChild(child);
      if (!!dart.test(child.attached)) dart.assertFailed(null, I[0], 960, 12, "!child.attached");
    }
    removeAllChildren() {
      let child = this.firstChild;
      while (child != null) {
        let next = child.nextSibling;
        child[_previousSibling] = null;
        child[_nextSibling] = null;
        if (!(child.attached == this.attached)) dart.assertFailed(null, I[0], 970, 14, "child.attached == attached");
        this.dropChild(child);
        child = next;
      }
      this[_firstChild] = null;
      this[_lastChild] = null;
    }
    addToScene(builder, layerOffset = C[0] || CT.C0) {
      if (builder == null) dart.nullFailed(I[0], 979, 35, "builder");
      if (layerOffset == null) dart.nullFailed(I[0], 979, 53, "layerOffset");
      this.addChildrenToScene(builder, layerOffset);
    }
    addChildrenToScene(builder, childOffset = C[0] || CT.C0) {
      if (builder == null) dart.nullFailed(I[0], 990, 43, "builder");
      if (childOffset == null) dart.nullFailed(I[0], 990, 61, "childOffset");
      let child = this.firstChild;
      while (child != null) {
        if (dart.equals(childOffset, ui.Offset.zero)) {
          child[_addToSceneWithRetainedRendering](builder);
        } else {
          child.addToScene(builder, childOffset);
        }
        child = child.nextSibling;
      }
    }
    applyTransform(child, transform) {
      if (transform == null) dart.nullFailed(I[0], 1035, 45, "transform");
      if (!(child != null)) dart.assertFailed(null, I[0], 1036, 12, "child != null");
      if (!(transform != null)) dart.assertFailed(null, I[0], 1037, 12, "transform != null");
    }
    depthFirstIterateChildren() {
      if (this.firstChild == null) return T$.JSArrayOfLayer().of([]);
      let children = T$.JSArrayOfLayer().of([]);
      let child = this.firstChild;
      while (child != null) {
        children[$add](child);
        if (layer$.ContainerLayer.is(child)) {
          children[$addAll](child.depthFirstIterateChildren());
        }
        child = child.nextSibling;
      }
      return children;
    }
    debugDescribeChildren() {
      let children = T$.JSArrayOfDiagnosticsNode().of([]);
      if (this.firstChild == null) return children;
      let child = this.firstChild;
      let count = 1;
      while (true) {
        children[$add](dart.nullCheck(child).toDiagnosticsNode({name: "child " + dart.str(count)}));
        if (dart.equals(child, this.lastChild)) break;
        count = count + 1;
        child = child.nextSibling;
      }
      return children;
    }
  };
  (layer$.ContainerLayer.new = function() {
    this[_firstChild] = null;
    this[_lastChild] = null;
    layer$.ContainerLayer.__proto__.new.call(this);
    ;
  }).prototype = layer$.ContainerLayer.prototype;
  dart.addTypeTests(layer$.ContainerLayer);
  dart.addTypeCaches(layer$.ContainerLayer);
  dart.setMethodSignature(layer$.ContainerLayer, () => ({
    __proto__: dart.getMethods(layer$.ContainerLayer.__proto__),
    buildScene: dart.fnType(ui.Scene, [ui.SceneBuilder]),
    [_debugUltimatePreviousSiblingOf]: dart.fnType(core.bool, [layer$.Layer], {equals: dart.nullable(layer$.Layer)}, {}),
    [_debugUltimateNextSiblingOf]: dart.fnType(core.bool, [layer$.Layer], {equals: dart.nullable(layer$.Layer)}, {}),
    [_highlightConflictingLayer]: dart.fnType(layer$.PictureLayer, [layer$.PhysicalModelLayer]),
    [_processConflictingPhysicalLayers]: dart.fnType(core.List$(layer$.PictureLayer), [layer$.PhysicalModelLayer, layer$.PhysicalModelLayer]),
    [_debugCheckElevations]: dart.fnType(core.List$(layer$.PictureLayer), []),
    findAnnotations: dart.gFnType(S => [core.bool, [layer$.AnnotationResult$(S), ui.Offset], {}, {onlyFirst: core.bool}], S => [core.Object]),
    append: dart.fnType(dart.void, [layer$.Layer]),
    [_removeChild]: dart.fnType(dart.void, [layer$.Layer]),
    removeAllChildren: dart.fnType(dart.void, []),
    addToScene: dart.fnType(dart.void, [ui.SceneBuilder], [ui.Offset]),
    addChildrenToScene: dart.fnType(dart.void, [ui.SceneBuilder], [ui.Offset]),
    applyTransform: dart.fnType(dart.void, [dart.nullable(layer$.Layer), vector_math_64.Matrix4]),
    depthFirstIterateChildren: dart.fnType(core.List$(layer$.Layer), [])
  }));
  dart.setGetterSignature(layer$.ContainerLayer, () => ({
    __proto__: dart.getGetters(layer$.ContainerLayer.__proto__),
    firstChild: dart.nullable(layer$.Layer),
    lastChild: dart.nullable(layer$.Layer),
    hasChildren: core.bool
  }));
  dart.setLibraryUri(layer$.ContainerLayer, I[1]);
  dart.setFieldSignature(layer$.ContainerLayer, () => ({
    __proto__: dart.getFields(layer$.ContainerLayer.__proto__),
    [_firstChild]: dart.fieldType(dart.nullable(layer$.Layer)),
    [_lastChild]: dart.fieldType(dart.nullable(layer$.Layer))
  }));
  var _offset = dart.privateName(layer$, "_offset");
  layer$.OffsetLayer = class OffsetLayer extends layer$.ContainerLayer {
    get offset() {
      return this[_offset];
    }
    set offset(value) {
      if (value == null) dart.nullFailed(I[0], 1100, 21, "value");
      if (!dart.equals(value, this[_offset])) {
        this.markNeedsAddToScene();
      }
      this[_offset] = value;
    }
    findAnnotations(S, result, localPosition, opts) {
      if (result == null) dart.nullFailed(I[0], 1108, 62, "result");
      if (localPosition == null) dart.nullFailed(I[0], 1108, 77, "localPosition");
      let onlyFirst = opts && 'onlyFirst' in opts ? opts.onlyFirst : null;
      if (onlyFirst == null) dart.nullFailed(I[0], 1108, 108, "onlyFirst");
      return super.findAnnotations(S, result, localPosition['-'](this.offset), {onlyFirst: onlyFirst});
    }
    applyTransform(child, transform) {
      if (transform == null) dart.nullFailed(I[0], 1113, 45, "transform");
      if (!(child != null)) dart.assertFailed(null, I[0], 1114, 12, "child != null");
      if (!(transform != null)) dart.assertFailed(null, I[0], 1115, 12, "transform != null");
      transform.multiply(vector_math_64.Matrix4.translationValues(this.offset.dx, this.offset.dy, 0.0));
    }
    addToScene(builder, layerOffset = C[0] || CT.C0) {
      if (builder == null) dart.nullFailed(I[0], 1120, 35, "builder");
      if (layerOffset == null) dart.nullFailed(I[0], 1120, 53, "layerOffset");
      this.engineLayer = builder.pushOffset(dart.notNull(layerOffset.dx) + dart.notNull(this.offset.dx), dart.notNull(layerOffset.dy) + dart.notNull(this.offset.dy), {oldLayer: T$.OffsetEngineLayerN().as(this[_engineLayer])});
      this.addChildrenToScene(builder);
      builder.pop();
    }
    debugFillProperties(properties) {
      if (properties == null) dart.nullFailed(I[0], 1136, 56, "properties");
      super.debugFillProperties(properties);
      properties.add(new (T$.DiagnosticsPropertyOfOffset()).new("offset", this.offset));
    }
    toImage(bounds, opts) {
      if (bounds == null) dart.nullFailed(I[0], 1157, 33, "bounds");
      let pixelRatio = opts && 'pixelRatio' in opts ? opts.pixelRatio : 1;
      if (pixelRatio == null) dart.nullFailed(I[0], 1157, 50, "pixelRatio");
      return async.async(ui.Image, (function* toImage() {
        if (!(bounds != null)) dart.assertFailed(null, I[0], 1158, 12, "bounds != null");
        if (!(pixelRatio != null)) dart.assertFailed(null, I[0], 1159, 12, "pixelRatio != null");
        let builder = ui.SceneBuilder.new();
        let transform = vector_math_64.Matrix4.translationValues((-dart.notNull(bounds.left) - dart.notNull(this.offset.dx)) * dart.notNull(pixelRatio), (-dart.notNull(bounds.top) - dart.notNull(this.offset.dy)) * dart.notNull(pixelRatio), 0.0);
        transform.scale(pixelRatio, pixelRatio);
        builder.pushTransform(transform.storage);
        let scene = this.buildScene(builder);
        try {
          return yield scene.toImage((dart.notNull(pixelRatio) * dart.notNull(bounds.width))[$ceil](), (dart.notNull(pixelRatio) * dart.notNull(bounds.height))[$ceil]());
        } finally {
          scene.dispose();
        }
      }).bind(this));
    }
  };
  (layer$.OffsetLayer.new = function(opts) {
    let offset = opts && 'offset' in opts ? opts.offset : C[0] || CT.C0;
    if (offset == null) dart.nullFailed(I[0], 1089, 24, "offset");
    this[_offset] = offset;
    layer$.OffsetLayer.__proto__.new.call(this);
    ;
  }).prototype = layer$.OffsetLayer.prototype;
  dart.addTypeTests(layer$.OffsetLayer);
  dart.addTypeCaches(layer$.OffsetLayer);
  dart.setMethodSignature(layer$.OffsetLayer, () => ({
    __proto__: dart.getMethods(layer$.OffsetLayer.__proto__),
    findAnnotations: dart.gFnType(S => [core.bool, [layer$.AnnotationResult$(S), ui.Offset], {}, {onlyFirst: core.bool}], S => [core.Object]),
    toImage: dart.fnType(async.Future$(ui.Image), [ui.Rect], {pixelRatio: core.double}, {})
  }));
  dart.setGetterSignature(layer$.OffsetLayer, () => ({
    __proto__: dart.getGetters(layer$.OffsetLayer.__proto__),
    offset: ui.Offset
  }));
  dart.setSetterSignature(layer$.OffsetLayer, () => ({
    __proto__: dart.getSetters(layer$.OffsetLayer.__proto__),
    offset: ui.Offset
  }));
  dart.setLibraryUri(layer$.OffsetLayer, I[1]);
  dart.setFieldSignature(layer$.OffsetLayer, () => ({
    __proto__: dart.getFields(layer$.OffsetLayer.__proto__),
    [_offset]: dart.fieldType(ui.Offset)
  }));
  var _clipRect = dart.privateName(layer$, "_clipRect");
  var _clipBehavior = dart.privateName(layer$, "_clipBehavior");
  layer$.ClipRectLayer = class ClipRectLayer extends layer$.ContainerLayer {
    get clipRect() {
      return this[_clipRect];
    }
    set clipRect(value) {
      if (!dart.equals(value, this[_clipRect])) {
        this[_clipRect] = value;
        this.markNeedsAddToScene();
      }
    }
    get clipBehavior() {
      return this[_clipBehavior];
    }
    set clipBehavior(value) {
      if (value == null) dart.nullFailed(I[0], 1225, 25, "value");
      if (!(value != null)) dart.assertFailed(null, I[0], 1226, 12, "value != null");
      if (!(value != ui.Clip.none)) dart.assertFailed(null, I[0], 1227, 12, "value != Clip.none");
      if (value != this[_clipBehavior]) {
        this[_clipBehavior] = value;
        this.markNeedsAddToScene();
      }
    }
    findAnnotations(S, result, localPosition, opts) {
      if (result == null) dart.nullFailed(I[0], 1235, 62, "result");
      if (localPosition == null) dart.nullFailed(I[0], 1235, 77, "localPosition");
      let onlyFirst = opts && 'onlyFirst' in opts ? opts.onlyFirst : null;
      if (onlyFirst == null) dart.nullFailed(I[0], 1235, 108, "onlyFirst");
      if (!dart.test(dart.nullCheck(this.clipRect).contains(localPosition))) return false;
      return super.findAnnotations(S, result, localPosition, {onlyFirst: onlyFirst});
    }
    addToScene(builder, layerOffset = C[0] || CT.C0) {
      if (builder == null) dart.nullFailed(I[0], 1242, 35, "builder");
      if (layerOffset == null) dart.nullFailed(I[0], 1242, 53, "layerOffset");
      if (!(this.clipRect != null)) dart.assertFailed(null, I[0], 1243, 12, "clipRect != null");
      if (!(this.clipBehavior != null)) dart.assertFailed(null, I[0], 1244, 12, "clipBehavior != null");
      let enabled = true;
      if (!dart.test(dart.fn(() => {
        enabled = !dart.test(debug$0.debugDisableClipLayers);
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[0], 1246, 12, "() {\r\n      enabled = !debugDisableClipLayers;\r\n      return true;\r\n    }()");
      if (enabled) {
        let shiftedClipRect = dart.equals(layerOffset, ui.Offset.zero) ? dart.nullCheck(this.clipRect) : dart.nullCheck(this.clipRect).shift(layerOffset);
        this.engineLayer = builder.pushClipRect(shiftedClipRect, {clipBehavior: this.clipBehavior, oldLayer: T$.ClipRectEngineLayerN().as(this[_engineLayer])});
      } else {
        this.engineLayer = null;
      }
      this.addChildrenToScene(builder, layerOffset);
      if (enabled) builder.pop();
    }
    debugFillProperties(properties) {
      if (properties == null) dart.nullFailed(I[0], 1266, 56, "properties");
      super.debugFillProperties(properties);
      properties.add(new (T$.DiagnosticsPropertyOfRect()).new("clipRect", this.clipRect));
      properties.add(new (T$.DiagnosticsPropertyOfClip()).new("clipBehavior", this.clipBehavior));
    }
  };
  (layer$.ClipRectLayer.new = function(opts) {
    let clipRect = opts && 'clipRect' in opts ? opts.clipRect : null;
    let clipBehavior = opts && 'clipBehavior' in opts ? opts.clipBehavior : C[3] || CT.C3;
    if (clipBehavior == null) dart.nullFailed(I[0], 1197, 10, "clipBehavior");
    this[_clipRect] = clipRect;
    this[_clipBehavior] = clipBehavior;
    if (!(clipBehavior != null)) dart.assertFailed(null, I[0], 1200, 15, "clipBehavior != null");
    if (!(clipBehavior != ui.Clip.none)) dart.assertFailed(null, I[0], 1201, 15, "clipBehavior != Clip.none");
    layer$.ClipRectLayer.__proto__.new.call(this);
    ;
  }).prototype = layer$.ClipRectLayer.prototype;
  dart.addTypeTests(layer$.ClipRectLayer);
  dart.addTypeCaches(layer$.ClipRectLayer);
  dart.setMethodSignature(layer$.ClipRectLayer, () => ({
    __proto__: dart.getMethods(layer$.ClipRectLayer.__proto__),
    findAnnotations: dart.gFnType(S => [core.bool, [layer$.AnnotationResult$(S), ui.Offset], {}, {onlyFirst: core.bool}], S => [core.Object])
  }));
  dart.setGetterSignature(layer$.ClipRectLayer, () => ({
    __proto__: dart.getGetters(layer$.ClipRectLayer.__proto__),
    clipRect: dart.nullable(ui.Rect),
    clipBehavior: ui.Clip
  }));
  dart.setSetterSignature(layer$.ClipRectLayer, () => ({
    __proto__: dart.getSetters(layer$.ClipRectLayer.__proto__),
    clipRect: dart.nullable(ui.Rect),
    clipBehavior: ui.Clip
  }));
  dart.setLibraryUri(layer$.ClipRectLayer, I[1]);
  dart.setFieldSignature(layer$.ClipRectLayer, () => ({
    __proto__: dart.getFields(layer$.ClipRectLayer.__proto__),
    [_clipRect]: dart.fieldType(dart.nullable(ui.Rect)),
    [_clipBehavior]: dart.fieldType(ui.Clip)
  }));
  var _clipRRect = dart.privateName(layer$, "_clipRRect");
  layer$.ClipRRectLayer = class ClipRRectLayer extends layer$.ContainerLayer {
    get clipRRect() {
      return this[_clipRRect];
    }
    set clipRRect(value) {
      if (!dart.equals(value, this[_clipRRect])) {
        this[_clipRRect] = value;
        this.markNeedsAddToScene();
      }
    }
    get clipBehavior() {
      return this[_clipBehavior];
    }
    set clipBehavior(value) {
      if (value == null) dart.nullFailed(I[0], 1309, 25, "value");
      if (!(value != null)) dart.assertFailed(null, I[0], 1310, 12, "value != null");
      if (!(value != ui.Clip.none)) dart.assertFailed(null, I[0], 1311, 12, "value != Clip.none");
      if (value != this[_clipBehavior]) {
        this[_clipBehavior] = value;
        this.markNeedsAddToScene();
      }
    }
    findAnnotations(S, result, localPosition, opts) {
      if (result == null) dart.nullFailed(I[0], 1319, 62, "result");
      if (localPosition == null) dart.nullFailed(I[0], 1319, 77, "localPosition");
      let onlyFirst = opts && 'onlyFirst' in opts ? opts.onlyFirst : null;
      if (onlyFirst == null) dart.nullFailed(I[0], 1319, 108, "onlyFirst");
      if (!dart.test(dart.nullCheck(this.clipRRect).contains(localPosition))) return false;
      return super.findAnnotations(S, result, localPosition, {onlyFirst: onlyFirst});
    }
    addToScene(builder, layerOffset = C[0] || CT.C0) {
      if (builder == null) dart.nullFailed(I[0], 1326, 35, "builder");
      if (layerOffset == null) dart.nullFailed(I[0], 1326, 53, "layerOffset");
      if (!(this.clipRRect != null)) dart.assertFailed(null, I[0], 1327, 12, "clipRRect != null");
      if (!(this.clipBehavior != null)) dart.assertFailed(null, I[0], 1328, 12, "clipBehavior != null");
      let enabled = true;
      if (!dart.test(dart.fn(() => {
        enabled = !dart.test(debug$0.debugDisableClipLayers);
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[0], 1330, 12, "() {\r\n      enabled = !debugDisableClipLayers;\r\n      return true;\r\n    }()");
      if (enabled) {
        let shiftedClipRRect = dart.equals(layerOffset, ui.Offset.zero) ? dart.nullCheck(this.clipRRect) : dart.nullCheck(this.clipRRect).shift(layerOffset);
        this.engineLayer = builder.pushClipRRect(shiftedClipRRect, {clipBehavior: this.clipBehavior, oldLayer: T$.ClipRRectEngineLayerN().as(this[_engineLayer])});
      } else {
        this.engineLayer = null;
      }
      this.addChildrenToScene(builder, layerOffset);
      if (enabled) builder.pop();
    }
    debugFillProperties(properties) {
      if (properties == null) dart.nullFailed(I[0], 1350, 56, "properties");
      super.debugFillProperties(properties);
      properties.add(new (T$.DiagnosticsPropertyOfRRect()).new("clipRRect", this.clipRRect));
      properties.add(new (T$.DiagnosticsPropertyOfClip()).new("clipBehavior", this.clipBehavior));
    }
  };
  (layer$.ClipRRectLayer.new = function(opts) {
    let clipRRect = opts && 'clipRRect' in opts ? opts.clipRRect : null;
    let clipBehavior = opts && 'clipBehavior' in opts ? opts.clipBehavior : C[4] || CT.C4;
    if (clipBehavior == null) dart.nullFailed(I[0], 1285, 10, "clipBehavior");
    this[_clipRRect] = clipRRect;
    this[_clipBehavior] = clipBehavior;
    if (!(clipBehavior != null)) dart.assertFailed(null, I[0], 1288, 15, "clipBehavior != null");
    if (!(clipBehavior != ui.Clip.none)) dart.assertFailed(null, I[0], 1289, 15, "clipBehavior != Clip.none");
    layer$.ClipRRectLayer.__proto__.new.call(this);
    ;
  }).prototype = layer$.ClipRRectLayer.prototype;
  dart.addTypeTests(layer$.ClipRRectLayer);
  dart.addTypeCaches(layer$.ClipRRectLayer);
  dart.setMethodSignature(layer$.ClipRRectLayer, () => ({
    __proto__: dart.getMethods(layer$.ClipRRectLayer.__proto__),
    findAnnotations: dart.gFnType(S => [core.bool, [layer$.AnnotationResult$(S), ui.Offset], {}, {onlyFirst: core.bool}], S => [core.Object])
  }));
  dart.setGetterSignature(layer$.ClipRRectLayer, () => ({
    __proto__: dart.getGetters(layer$.ClipRRectLayer.__proto__),
    clipRRect: dart.nullable(ui.RRect),
    clipBehavior: ui.Clip
  }));
  dart.setSetterSignature(layer$.ClipRRectLayer, () => ({
    __proto__: dart.getSetters(layer$.ClipRRectLayer.__proto__),
    clipRRect: dart.nullable(ui.RRect),
    clipBehavior: ui.Clip
  }));
  dart.setLibraryUri(layer$.ClipRRectLayer, I[1]);
  dart.setFieldSignature(layer$.ClipRRectLayer, () => ({
    __proto__: dart.getFields(layer$.ClipRRectLayer.__proto__),
    [_clipRRect]: dart.fieldType(dart.nullable(ui.RRect)),
    [_clipBehavior]: dart.fieldType(ui.Clip)
  }));
  var _clipPath = dart.privateName(layer$, "_clipPath");
  layer$.ClipPathLayer = class ClipPathLayer extends layer$.ContainerLayer {
    get clipPath() {
      return this[_clipPath];
    }
    set clipPath(value) {
      if (!dart.equals(value, this[_clipPath])) {
        this[_clipPath] = value;
        this.markNeedsAddToScene();
      }
    }
    get clipBehavior() {
      return this[_clipBehavior];
    }
    set clipBehavior(value) {
      if (value == null) dart.nullFailed(I[0], 1393, 25, "value");
      if (!(value != null)) dart.assertFailed(null, I[0], 1394, 12, "value != null");
      if (!(value != ui.Clip.none)) dart.assertFailed(null, I[0], 1395, 12, "value != Clip.none");
      if (value != this[_clipBehavior]) {
        this[_clipBehavior] = value;
        this.markNeedsAddToScene();
      }
    }
    findAnnotations(S, result, localPosition, opts) {
      if (result == null) dart.nullFailed(I[0], 1403, 62, "result");
      if (localPosition == null) dart.nullFailed(I[0], 1403, 77, "localPosition");
      let onlyFirst = opts && 'onlyFirst' in opts ? opts.onlyFirst : null;
      if (onlyFirst == null) dart.nullFailed(I[0], 1403, 108, "onlyFirst");
      if (!dart.test(dart.nullCheck(this.clipPath).contains(localPosition))) return false;
      return super.findAnnotations(S, result, localPosition, {onlyFirst: onlyFirst});
    }
    addToScene(builder, layerOffset = C[0] || CT.C0) {
      if (builder == null) dart.nullFailed(I[0], 1410, 35, "builder");
      if (layerOffset == null) dart.nullFailed(I[0], 1410, 53, "layerOffset");
      if (!(this.clipPath != null)) dart.assertFailed(null, I[0], 1411, 12, "clipPath != null");
      if (!(this.clipBehavior != null)) dart.assertFailed(null, I[0], 1412, 12, "clipBehavior != null");
      let enabled = true;
      if (!dart.test(dart.fn(() => {
        enabled = !dart.test(debug$0.debugDisableClipLayers);
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[0], 1414, 12, "() {\r\n      enabled = !debugDisableClipLayers;\r\n      return true;\r\n    }()");
      if (enabled) {
        let shiftedPath = dart.equals(layerOffset, ui.Offset.zero) ? dart.nullCheck(this.clipPath) : dart.nullCheck(this.clipPath).shift(layerOffset);
        this.engineLayer = builder.pushClipPath(shiftedPath, {clipBehavior: this.clipBehavior, oldLayer: T$.ClipPathEngineLayerN().as(this[_engineLayer])});
      } else {
        this.engineLayer = null;
      }
      this.addChildrenToScene(builder, layerOffset);
      if (enabled) builder.pop();
    }
    debugFillProperties(properties) {
      if (properties == null) dart.nullFailed(I[0], 1434, 56, "properties");
      super.debugFillProperties(properties);
      properties.add(new (T$.DiagnosticsPropertyOfClip()).new("clipBehavior", this.clipBehavior));
    }
  };
  (layer$.ClipPathLayer.new = function(opts) {
    let clipPath = opts && 'clipPath' in opts ? opts.clipPath : null;
    let clipBehavior = opts && 'clipBehavior' in opts ? opts.clipBehavior : C[4] || CT.C4;
    if (clipBehavior == null) dart.nullFailed(I[0], 1369, 10, "clipBehavior");
    this[_clipPath] = clipPath;
    this[_clipBehavior] = clipBehavior;
    if (!(clipBehavior != null)) dart.assertFailed(null, I[0], 1372, 15, "clipBehavior != null");
    if (!(clipBehavior != ui.Clip.none)) dart.assertFailed(null, I[0], 1373, 15, "clipBehavior != Clip.none");
    layer$.ClipPathLayer.__proto__.new.call(this);
    ;
  }).prototype = layer$.ClipPathLayer.prototype;
  dart.addTypeTests(layer$.ClipPathLayer);
  dart.addTypeCaches(layer$.ClipPathLayer);
  dart.setMethodSignature(layer$.ClipPathLayer, () => ({
    __proto__: dart.getMethods(layer$.ClipPathLayer.__proto__),
    findAnnotations: dart.gFnType(S => [core.bool, [layer$.AnnotationResult$(S), ui.Offset], {}, {onlyFirst: core.bool}], S => [core.Object])
  }));
  dart.setGetterSignature(layer$.ClipPathLayer, () => ({
    __proto__: dart.getGetters(layer$.ClipPathLayer.__proto__),
    clipPath: dart.nullable(ui.Path),
    clipBehavior: ui.Clip
  }));
  dart.setSetterSignature(layer$.ClipPathLayer, () => ({
    __proto__: dart.getSetters(layer$.ClipPathLayer.__proto__),
    clipPath: dart.nullable(ui.Path),
    clipBehavior: ui.Clip
  }));
  dart.setLibraryUri(layer$.ClipPathLayer, I[1]);
  dart.setFieldSignature(layer$.ClipPathLayer, () => ({
    __proto__: dart.getFields(layer$.ClipPathLayer.__proto__),
    [_clipPath]: dart.fieldType(dart.nullable(ui.Path)),
    [_clipBehavior]: dart.fieldType(ui.Clip)
  }));
  var _colorFilter = dart.privateName(layer$, "_colorFilter");
  layer$.ColorFilterLayer = class ColorFilterLayer extends layer$.ContainerLayer {
    get colorFilter() {
      return this[_colorFilter];
    }
    set colorFilter(value) {
      if (!(value != null)) dart.assertFailed(null, I[0], 1457, 12, "value != null");
      if (!dart.equals(value, this[_colorFilter])) {
        this[_colorFilter] = value;
        this.markNeedsAddToScene();
      }
    }
    addToScene(builder, layerOffset = C[0] || CT.C0) {
      if (builder == null) dart.nullFailed(I[0], 1465, 35, "builder");
      if (layerOffset == null) dart.nullFailed(I[0], 1465, 53, "layerOffset");
      if (!(this.colorFilter != null)) dart.assertFailed(null, I[0], 1466, 12, "colorFilter != null");
      this.engineLayer = builder.pushColorFilter(dart.nullCheck(this.colorFilter), {oldLayer: T$.ColorFilterEngineLayerN().as(this[_engineLayer])});
      this.addChildrenToScene(builder, layerOffset);
      builder.pop();
    }
    debugFillProperties(properties) {
      if (properties == null) dart.nullFailed(I[0], 1476, 56, "properties");
      super.debugFillProperties(properties);
      properties.add(new (T$.DiagnosticsPropertyOfColorFilter()).new("colorFilter", this.colorFilter));
    }
  };
  (layer$.ColorFilterLayer.new = function(opts) {
    let colorFilter = opts && 'colorFilter' in opts ? opts.colorFilter : null;
    this[_colorFilter] = colorFilter;
    layer$.ColorFilterLayer.__proto__.new.call(this);
    ;
  }).prototype = layer$.ColorFilterLayer.prototype;
  dart.addTypeTests(layer$.ColorFilterLayer);
  dart.addTypeCaches(layer$.ColorFilterLayer);
  dart.setGetterSignature(layer$.ColorFilterLayer, () => ({
    __proto__: dart.getGetters(layer$.ColorFilterLayer.__proto__),
    colorFilter: dart.nullable(ui.ColorFilter)
  }));
  dart.setSetterSignature(layer$.ColorFilterLayer, () => ({
    __proto__: dart.getSetters(layer$.ColorFilterLayer.__proto__),
    colorFilter: dart.nullable(ui.ColorFilter)
  }));
  dart.setLibraryUri(layer$.ColorFilterLayer, I[1]);
  dart.setFieldSignature(layer$.ColorFilterLayer, () => ({
    __proto__: dart.getFields(layer$.ColorFilterLayer.__proto__),
    [_colorFilter]: dart.fieldType(dart.nullable(ui.ColorFilter))
  }));
  var _imageFilter = dart.privateName(layer$, "_imageFilter");
  layer$.ImageFilterLayer = class ImageFilterLayer extends layer$.ContainerLayer {
    get imageFilter() {
      return this[_imageFilter];
    }
    set imageFilter(value) {
      if (!(value != null)) dart.assertFailed(null, I[0], 1499, 12, "value != null");
      if (!dart.equals(value, this[_imageFilter])) {
        this[_imageFilter] = value;
        this.markNeedsAddToScene();
      }
    }
    addToScene(builder, layerOffset = C[0] || CT.C0) {
      if (builder == null) dart.nullFailed(I[0], 1507, 35, "builder");
      if (layerOffset == null) dart.nullFailed(I[0], 1507, 53, "layerOffset");
      if (!(this.imageFilter != null)) dart.assertFailed(null, I[0], 1508, 12, "imageFilter != null");
      this.engineLayer = builder.pushImageFilter(dart.nullCheck(this.imageFilter), {oldLayer: T$.ImageFilterEngineLayerN().as(this[_engineLayer])});
      this.addChildrenToScene(builder, layerOffset);
      builder.pop();
    }
    debugFillProperties(properties) {
      if (properties == null) dart.nullFailed(I[0], 1518, 56, "properties");
      super.debugFillProperties(properties);
      properties.add(new (T$.DiagnosticsPropertyOfImageFilter()).new("imageFilter", this.imageFilter));
    }
  };
  (layer$.ImageFilterLayer.new = function(opts) {
    let imageFilter = opts && 'imageFilter' in opts ? opts.imageFilter : null;
    this[_imageFilter] = imageFilter;
    layer$.ImageFilterLayer.__proto__.new.call(this);
    ;
  }).prototype = layer$.ImageFilterLayer.prototype;
  dart.addTypeTests(layer$.ImageFilterLayer);
  dart.addTypeCaches(layer$.ImageFilterLayer);
  dart.setGetterSignature(layer$.ImageFilterLayer, () => ({
    __proto__: dart.getGetters(layer$.ImageFilterLayer.__proto__),
    imageFilter: dart.nullable(ui.ImageFilter)
  }));
  dart.setSetterSignature(layer$.ImageFilterLayer, () => ({
    __proto__: dart.getSetters(layer$.ImageFilterLayer.__proto__),
    imageFilter: dart.nullable(ui.ImageFilter)
  }));
  dart.setLibraryUri(layer$.ImageFilterLayer, I[1]);
  dart.setFieldSignature(layer$.ImageFilterLayer, () => ({
    __proto__: dart.getFields(layer$.ImageFilterLayer.__proto__),
    [_imageFilter]: dart.fieldType(dart.nullable(ui.ImageFilter))
  }));
  var _lastEffectiveTransform = dart.privateName(layer$, "_lastEffectiveTransform");
  var _invertedTransform = dart.privateName(layer$, "_invertedTransform");
  var _inverseDirty = dart.privateName(layer$, "_inverseDirty");
  var _transform = dart.privateName(layer$, "_transform");
  var _transformOffset = dart.privateName(layer$, "_transformOffset");
  layer$.TransformLayer = class TransformLayer extends layer$.OffsetLayer {
    get transform() {
      return this[_transform];
    }
    set transform(value) {
      if (!(value != null)) dart.assertFailed(null, I[0], 1550, 12, "value != null");
      if (!dart.test(dart.nullCheck(value).storage[$every](dart.fn(component => {
        if (component == null) dart.nullFailed(I[0], 1551, 41, "component");
        return component[$isFinite];
      }, T$.doubleTobool())))) dart.assertFailed(null, I[0], 1551, 12, "value!.storage.every((double component) => component.isFinite)");
      if (dart.equals(value, this[_transform])) return;
      this[_transform] = value;
      this[_inverseDirty] = true;
      this.markNeedsAddToScene();
    }
    addToScene(builder, layerOffset = C[0] || CT.C0) {
      let t0;
      if (builder == null) dart.nullFailed(I[0], 1564, 35, "builder");
      if (layerOffset == null) dart.nullFailed(I[0], 1564, 53, "layerOffset");
      if (!(this.transform != null)) dart.assertFailed(null, I[0], 1565, 12, "transform != null");
      this[_lastEffectiveTransform] = this.transform;
      let totalOffset = this.offset['+'](layerOffset);
      if (!dart.equals(totalOffset, ui.Offset.zero)) {
        this[_lastEffectiveTransform] = (t0 = vector_math_64.Matrix4.translationValues(totalOffset.dx, totalOffset.dy, 0.0), (() => {
          t0.multiply(dart.nullCheck(this[_lastEffectiveTransform]));
          return t0;
        })());
      }
      this.engineLayer = builder.pushTransform(dart.nullCheck(this[_lastEffectiveTransform]).storage, {oldLayer: T$.TransformEngineLayerN().as(this[_engineLayer])});
      this.addChildrenToScene(builder);
      builder.pop();
    }
    [_transformOffset](localPosition) {
      if (localPosition == null) dart.nullFailed(I[0], 1580, 35, "localPosition");
      if (dart.test(this[_inverseDirty])) {
        this[_invertedTransform] = vector_math_64.Matrix4.tryInvert(events.PointerEvent.removePerspectiveTransform(dart.nullCheck(this.transform)));
        this[_inverseDirty] = false;
      }
      if (this[_invertedTransform] == null) return null;
      return matrix_utils.MatrixUtils.transformPoint(dart.nullCheck(this[_invertedTransform]), localPosition);
    }
    findAnnotations(S, result, localPosition, opts) {
      if (result == null) dart.nullFailed(I[0], 1594, 62, "result");
      if (localPosition == null) dart.nullFailed(I[0], 1594, 77, "localPosition");
      let onlyFirst = opts && 'onlyFirst' in opts ? opts.onlyFirst : null;
      if (onlyFirst == null) dart.nullFailed(I[0], 1594, 108, "onlyFirst");
      let transformedOffset = this[_transformOffset](localPosition);
      if (transformedOffset == null) return false;
      return super.findAnnotations(S, result, transformedOffset, {onlyFirst: onlyFirst});
    }
    applyTransform(child, transform) {
      if (transform == null) dart.nullFailed(I[0], 1602, 45, "transform");
      if (!(child != null)) dart.assertFailed(null, I[0], 1603, 12, "child != null");
      if (!(transform != null)) dart.assertFailed(null, I[0], 1604, 12, "transform != null");
      if (!(this[_lastEffectiveTransform] != null || this.transform != null)) dart.assertFailed(null, I[0], 1605, 12, "_lastEffectiveTransform != null || this.transform != null");
      if (this[_lastEffectiveTransform] == null) {
        transform.multiply(dart.nullCheck(this.transform));
      } else {
        transform.multiply(dart.nullCheck(this[_lastEffectiveTransform]));
      }
    }
    debugFillProperties(properties) {
      if (properties == null) dart.nullFailed(I[0], 1614, 56, "properties");
      super.debugFillProperties(properties);
      properties.add(new matrix_utils.TransformProperty.new("transform", this.transform));
    }
  };
  (layer$.TransformLayer.new = function(opts) {
    let transform = opts && 'transform' in opts ? opts.transform : null;
    let offset = opts && 'offset' in opts ? opts.offset : C[0] || CT.C0;
    if (offset == null) dart.nullFailed(I[0], 1534, 47, "offset");
    this[_lastEffectiveTransform] = null;
    this[_invertedTransform] = null;
    this[_inverseDirty] = true;
    this[_transform] = transform;
    layer$.TransformLayer.__proto__.new.call(this, {offset: offset});
    ;
  }).prototype = layer$.TransformLayer.prototype;
  dart.addTypeTests(layer$.TransformLayer);
  dart.addTypeCaches(layer$.TransformLayer);
  dart.setMethodSignature(layer$.TransformLayer, () => ({
    __proto__: dart.getMethods(layer$.TransformLayer.__proto__),
    [_transformOffset]: dart.fnType(dart.nullable(ui.Offset), [ui.Offset]),
    findAnnotations: dart.gFnType(S => [core.bool, [layer$.AnnotationResult$(S), ui.Offset], {}, {onlyFirst: core.bool}], S => [core.Object])
  }));
  dart.setGetterSignature(layer$.TransformLayer, () => ({
    __proto__: dart.getGetters(layer$.TransformLayer.__proto__),
    transform: dart.nullable(vector_math_64.Matrix4)
  }));
  dart.setSetterSignature(layer$.TransformLayer, () => ({
    __proto__: dart.getSetters(layer$.TransformLayer.__proto__),
    transform: dart.nullable(vector_math_64.Matrix4)
  }));
  dart.setLibraryUri(layer$.TransformLayer, I[1]);
  dart.setFieldSignature(layer$.TransformLayer, () => ({
    __proto__: dart.getFields(layer$.TransformLayer.__proto__),
    [_transform]: dart.fieldType(dart.nullable(vector_math_64.Matrix4)),
    [_lastEffectiveTransform]: dart.fieldType(dart.nullable(vector_math_64.Matrix4)),
    [_invertedTransform]: dart.fieldType(dart.nullable(vector_math_64.Matrix4)),
    [_inverseDirty]: dart.fieldType(core.bool)
  }));
  var _alpha = dart.privateName(layer$, "_alpha");
  layer$.OpacityLayer = class OpacityLayer extends layer$.ContainerLayer {
    get alpha() {
      return this[_alpha];
    }
    set alpha(value) {
      if (!(value != null)) dart.assertFailed(null, I[0], 1649, 12, "value != null");
      if (value != this[_alpha]) {
        this[_alpha] = value;
        this.markNeedsAddToScene();
      }
    }
    get offset() {
      return this[_offset];
    }
    set offset(value) {
      if (!dart.equals(value, this[_offset])) {
        this[_offset] = value;
        this.markNeedsAddToScene();
      }
    }
    applyTransform(child, transform) {
      if (transform == null) dart.nullFailed(I[0], 1667, 45, "transform");
      if (!(child != null)) dart.assertFailed(null, I[0], 1668, 12, "child != null");
      if (!(transform != null)) dart.assertFailed(null, I[0], 1669, 12, "transform != null");
      transform.translate(dart.nullCheck(this.offset).dx, dart.nullCheck(this.offset).dy);
    }
    addToScene(builder, layerOffset = C[0] || CT.C0) {
      if (builder == null) dart.nullFailed(I[0], 1674, 35, "builder");
      if (layerOffset == null) dart.nullFailed(I[0], 1674, 53, "layerOffset");
      if (!(this.alpha != null)) dart.assertFailed(null, I[0], 1675, 12, "alpha != null");
      let enabled = this.firstChild != null;
      if (!dart.test(dart.fn(() => {
        enabled = enabled && !dart.test(debug$0.debugDisableOpacityLayers);
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[0], 1677, 12, "() {\r\n      enabled = enabled && !debugDisableOpacityLayers;\r\n      return true;\r\n    }()");
      if (enabled)
        this.engineLayer = builder.pushOpacity(dart.nullCheck(this.alpha), {offset: dart.nullCheck(this.offset)['+'](layerOffset), oldLayer: T$.OpacityEngineLayerN().as(this[_engineLayer])});
      else
        this.engineLayer = null;
      this.addChildrenToScene(builder);
      if (enabled) builder.pop();
    }
    debugFillProperties(properties) {
      if (properties == null) dart.nullFailed(I[0], 1696, 56, "properties");
      super.debugFillProperties(properties);
      properties.add(new diagnostics.IntProperty.new("alpha", this.alpha));
      properties.add(new (T$.DiagnosticsPropertyOfOffset()).new("offset", this.offset));
    }
  };
  (layer$.OpacityLayer.new = function(opts) {
    let alpha = opts && 'alpha' in opts ? opts.alpha : null;
    let offset = opts && 'offset' in opts ? opts.offset : C[0] || CT.C0;
    if (offset == null) dart.nullFailed(I[0], 1635, 12, "offset");
    this[_alpha] = alpha;
    this[_offset] = offset;
    layer$.OpacityLayer.__proto__.new.call(this);
    ;
  }).prototype = layer$.OpacityLayer.prototype;
  dart.addTypeTests(layer$.OpacityLayer);
  dart.addTypeCaches(layer$.OpacityLayer);
  dart.setGetterSignature(layer$.OpacityLayer, () => ({
    __proto__: dart.getGetters(layer$.OpacityLayer.__proto__),
    alpha: dart.nullable(core.int),
    offset: dart.nullable(ui.Offset)
  }));
  dart.setSetterSignature(layer$.OpacityLayer, () => ({
    __proto__: dart.getSetters(layer$.OpacityLayer.__proto__),
    alpha: dart.nullable(core.int),
    offset: dart.nullable(ui.Offset)
  }));
  dart.setLibraryUri(layer$.OpacityLayer, I[1]);
  dart.setFieldSignature(layer$.OpacityLayer, () => ({
    __proto__: dart.getFields(layer$.OpacityLayer.__proto__),
    [_alpha]: dart.fieldType(dart.nullable(core.int)),
    [_offset]: dart.fieldType(dart.nullable(ui.Offset))
  }));
  var _shader = dart.privateName(layer$, "_shader");
  var _maskRect = dart.privateName(layer$, "_maskRect");
  var _blendMode = dart.privateName(layer$, "_blendMode");
  layer$.ShaderMaskLayer = class ShaderMaskLayer extends layer$.ContainerLayer {
    get shader() {
      return this[_shader];
    }
    set shader(value) {
      if (!dart.equals(value, this[_shader])) {
        this[_shader] = value;
        this.markNeedsAddToScene();
      }
    }
    get maskRect() {
      return this[_maskRect];
    }
    set maskRect(value) {
      if (!dart.equals(value, this[_maskRect])) {
        this[_maskRect] = value;
        this.markNeedsAddToScene();
      }
    }
    get blendMode() {
      return this[_blendMode];
    }
    set blendMode(value) {
      if (value != this[_blendMode]) {
        this[_blendMode] = value;
        this.markNeedsAddToScene();
      }
    }
    addToScene(builder, layerOffset = C[0] || CT.C0) {
      if (builder == null) dart.nullFailed(I[0], 1773, 35, "builder");
      if (layerOffset == null) dart.nullFailed(I[0], 1773, 53, "layerOffset");
      if (!(this.shader != null)) dart.assertFailed(null, I[0], 1774, 12, "shader != null");
      if (!(this.maskRect != null)) dart.assertFailed(null, I[0], 1775, 12, "maskRect != null");
      if (!(this.blendMode != null)) dart.assertFailed(null, I[0], 1776, 12, "blendMode != null");
      if (!(layerOffset != null)) dart.assertFailed(null, I[0], 1777, 12, "layerOffset != null");
      let shiftedMaskRect = dart.equals(layerOffset, ui.Offset.zero) ? dart.nullCheck(this.maskRect) : dart.nullCheck(this.maskRect).shift(layerOffset);
      this.engineLayer = builder.pushShaderMask(dart.nullCheck(this.shader), shiftedMaskRect, dart.nullCheck(this.blendMode), {oldLayer: T$.ShaderMaskEngineLayerN().as(this[_engineLayer])});
      this.addChildrenToScene(builder, layerOffset);
      builder.pop();
    }
    debugFillProperties(properties) {
      if (properties == null) dart.nullFailed(I[0], 1790, 56, "properties");
      super.debugFillProperties(properties);
      properties.add(new (T$.DiagnosticsPropertyOfShader()).new("shader", this.shader));
      properties.add(new (T$.DiagnosticsPropertyOfRect()).new("maskRect", this.maskRect));
      properties.add(new (T$.DiagnosticsPropertyOfBlendMode()).new("blendMode", this.blendMode));
    }
  };
  (layer$.ShaderMaskLayer.new = function(opts) {
    let shader = opts && 'shader' in opts ? opts.shader : null;
    let maskRect = opts && 'maskRect' in opts ? opts.maskRect : null;
    let blendMode = opts && 'blendMode' in opts ? opts.blendMode : null;
    this[_shader] = shader;
    this[_maskRect] = maskRect;
    this[_blendMode] = blendMode;
    layer$.ShaderMaskLayer.__proto__.new.call(this);
    ;
  }).prototype = layer$.ShaderMaskLayer.prototype;
  dart.addTypeTests(layer$.ShaderMaskLayer);
  dart.addTypeCaches(layer$.ShaderMaskLayer);
  dart.setGetterSignature(layer$.ShaderMaskLayer, () => ({
    __proto__: dart.getGetters(layer$.ShaderMaskLayer.__proto__),
    shader: dart.nullable(ui.Shader),
    maskRect: dart.nullable(ui.Rect),
    blendMode: dart.nullable(ui.BlendMode)
  }));
  dart.setSetterSignature(layer$.ShaderMaskLayer, () => ({
    __proto__: dart.getSetters(layer$.ShaderMaskLayer.__proto__),
    shader: dart.nullable(ui.Shader),
    maskRect: dart.nullable(ui.Rect),
    blendMode: dart.nullable(ui.BlendMode)
  }));
  dart.setLibraryUri(layer$.ShaderMaskLayer, I[1]);
  dart.setFieldSignature(layer$.ShaderMaskLayer, () => ({
    __proto__: dart.getFields(layer$.ShaderMaskLayer.__proto__),
    [_shader]: dart.fieldType(dart.nullable(ui.Shader)),
    [_maskRect]: dart.fieldType(dart.nullable(ui.Rect)),
    [_blendMode]: dart.fieldType(dart.nullable(ui.BlendMode))
  }));
  var _filter = dart.privateName(layer$, "_filter");
  layer$.BackdropFilterLayer = class BackdropFilterLayer extends layer$.ContainerLayer {
    get filter() {
      return this[_filter];
    }
    set filter(value) {
      if (!dart.equals(value, this[_filter])) {
        this[_filter] = value;
        this.markNeedsAddToScene();
      }
    }
    addToScene(builder, layerOffset = C[0] || CT.C0) {
      if (builder == null) dart.nullFailed(I[0], 1820, 35, "builder");
      if (layerOffset == null) dart.nullFailed(I[0], 1820, 53, "layerOffset");
      if (!(this.filter != null)) dart.assertFailed(null, I[0], 1821, 12, "filter != null");
      this.engineLayer = builder.pushBackdropFilter(dart.nullCheck(this.filter), {oldLayer: T$.BackdropFilterEngineLayerN().as(this[_engineLayer])});
      this.addChildrenToScene(builder, layerOffset);
      builder.pop();
    }
  };
  (layer$.BackdropFilterLayer.new = function(opts) {
    let filter = opts && 'filter' in opts ? opts.filter : null;
    this[_filter] = filter;
    layer$.BackdropFilterLayer.__proto__.new.call(this);
    ;
  }).prototype = layer$.BackdropFilterLayer.prototype;
  dart.addTypeTests(layer$.BackdropFilterLayer);
  dart.addTypeCaches(layer$.BackdropFilterLayer);
  dart.setGetterSignature(layer$.BackdropFilterLayer, () => ({
    __proto__: dart.getGetters(layer$.BackdropFilterLayer.__proto__),
    filter: dart.nullable(ui.ImageFilter)
  }));
  dart.setSetterSignature(layer$.BackdropFilterLayer, () => ({
    __proto__: dart.getSetters(layer$.BackdropFilterLayer.__proto__),
    filter: dart.nullable(ui.ImageFilter)
  }));
  dart.setLibraryUri(layer$.BackdropFilterLayer, I[1]);
  dart.setFieldSignature(layer$.BackdropFilterLayer, () => ({
    __proto__: dart.getFields(layer$.BackdropFilterLayer.__proto__),
    [_filter]: dart.fieldType(dart.nullable(ui.ImageFilter))
  }));
  var _elevation = dart.privateName(layer$, "_elevation");
  var _color = dart.privateName(layer$, "_color");
  var _shadowColor = dart.privateName(layer$, "_shadowColor");
  layer$.PhysicalModelLayer = class PhysicalModelLayer extends layer$.ContainerLayer {
    get clipPath() {
      return this[_clipPath];
    }
    set clipPath(value) {
      if (!dart.equals(value, this[_clipPath])) {
        this[_clipPath] = value;
        this.markNeedsAddToScene();
      }
    }
    get [_debugTransformedClipPath]() {
      let ancestor = this.parent;
      let matrix = vector_math_64.Matrix4.identity();
      while (ancestor != null && ancestor.parent != null) {
        ancestor.applyTransform(this, matrix);
        ancestor = ancestor.parent;
      }
      return dart.nullCheck(this.clipPath).transform(matrix.storage);
    }
    get clipBehavior() {
      return this[_clipBehavior];
    }
    set clipBehavior(value) {
      if (value == null) dart.nullFailed(I[0], 1884, 25, "value");
      if (!(value != null)) dart.assertFailed(null, I[0], 1885, 12, "value != null");
      if (value != this[_clipBehavior]) {
        this[_clipBehavior] = value;
        this.markNeedsAddToScene();
      }
    }
    get elevation() {
      return this[_elevation];
    }
    set elevation(value) {
      if (value != this[_elevation]) {
        this[_elevation] = value;
        this.markNeedsAddToScene();
      }
    }
    get color() {
      return this[_color];
    }
    set color(value) {
      if (!dart.equals(value, this[_color])) {
        this[_color] = value;
        this.markNeedsAddToScene();
      }
    }
    get shadowColor() {
      return this[_shadowColor];
    }
    set shadowColor(value) {
      if (!dart.equals(value, this[_shadowColor])) {
        this[_shadowColor] = value;
        this.markNeedsAddToScene();
      }
    }
    findAnnotations(S, result, localPosition, opts) {
      if (result == null) dart.nullFailed(I[0], 1935, 62, "result");
      if (localPosition == null) dart.nullFailed(I[0], 1935, 77, "localPosition");
      let onlyFirst = opts && 'onlyFirst' in opts ? opts.onlyFirst : null;
      if (onlyFirst == null) dart.nullFailed(I[0], 1935, 108, "onlyFirst");
      if (!dart.test(dart.nullCheck(this.clipPath).contains(localPosition))) return false;
      return super.findAnnotations(S, result, localPosition, {onlyFirst: onlyFirst});
    }
    addToScene(builder, layerOffset = C[0] || CT.C0) {
      if (builder == null) dart.nullFailed(I[0], 1942, 35, "builder");
      if (layerOffset == null) dart.nullFailed(I[0], 1942, 53, "layerOffset");
      if (!(this.clipPath != null)) dart.assertFailed(null, I[0], 1943, 12, "clipPath != null");
      if (!(this.clipBehavior != null)) dart.assertFailed(null, I[0], 1944, 12, "clipBehavior != null");
      if (!(this.elevation != null)) dart.assertFailed(null, I[0], 1945, 12, "elevation != null");
      if (!(this.color != null)) dart.assertFailed(null, I[0], 1946, 12, "color != null");
      if (!(this.shadowColor != null)) dart.assertFailed(null, I[0], 1947, 12, "shadowColor != null");
      let enabled = true;
      if (!dart.test(dart.fn(() => {
        enabled = !dart.test(debug$0.debugDisablePhysicalShapeLayers);
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[0], 1950, 12, "() {\r\n      enabled = !debugDisablePhysicalShapeLayers;\r\n      return true;\r\n    }()");
      if (enabled) {
        this.engineLayer = builder.pushPhysicalShape({path: dart.equals(layerOffset, ui.Offset.zero) ? dart.nullCheck(this.clipPath) : dart.nullCheck(this.clipPath).shift(layerOffset), elevation: dart.nullCheck(this.elevation), color: dart.nullCheck(this.color), shadowColor: this.shadowColor, clipBehavior: this.clipBehavior, oldLayer: T$.PhysicalShapeEngineLayerN().as(this[_engineLayer])});
      } else {
        this.engineLayer = null;
      }
      this.addChildrenToScene(builder, layerOffset);
      if (enabled) builder.pop();
    }
    debugFillProperties(properties) {
      if (properties == null) dart.nullFailed(I[0], 1972, 56, "properties");
      super.debugFillProperties(properties);
      properties.add(new diagnostics.DoubleProperty.new("elevation", this.elevation));
      properties.add(new colors.ColorProperty.new("color", this.color));
    }
  };
  (layer$.PhysicalModelLayer.new = function(opts) {
    let clipPath = opts && 'clipPath' in opts ? opts.clipPath : null;
    let clipBehavior = opts && 'clipBehavior' in opts ? opts.clipBehavior : C[5] || CT.C5;
    if (clipBehavior == null) dart.nullFailed(I[0], 1848, 10, "clipBehavior");
    let elevation = opts && 'elevation' in opts ? opts.elevation : null;
    let color = opts && 'color' in opts ? opts.color : null;
    let shadowColor = opts && 'shadowColor' in opts ? opts.shadowColor : null;
    this[_clipPath] = clipPath;
    this[_clipBehavior] = clipBehavior;
    this[_elevation] = elevation;
    this[_color] = color;
    this[_shadowColor] = shadowColor;
    layer$.PhysicalModelLayer.__proto__.new.call(this);
    ;
  }).prototype = layer$.PhysicalModelLayer.prototype;
  dart.addTypeTests(layer$.PhysicalModelLayer);
  dart.addTypeCaches(layer$.PhysicalModelLayer);
  dart.setMethodSignature(layer$.PhysicalModelLayer, () => ({
    __proto__: dart.getMethods(layer$.PhysicalModelLayer.__proto__),
    findAnnotations: dart.gFnType(S => [core.bool, [layer$.AnnotationResult$(S), ui.Offset], {}, {onlyFirst: core.bool}], S => [core.Object])
  }));
  dart.setGetterSignature(layer$.PhysicalModelLayer, () => ({
    __proto__: dart.getGetters(layer$.PhysicalModelLayer.__proto__),
    clipPath: dart.nullable(ui.Path),
    [_debugTransformedClipPath]: ui.Path,
    clipBehavior: ui.Clip,
    elevation: dart.nullable(core.double),
    color: dart.nullable(ui.Color),
    shadowColor: dart.nullable(ui.Color)
  }));
  dart.setSetterSignature(layer$.PhysicalModelLayer, () => ({
    __proto__: dart.getSetters(layer$.PhysicalModelLayer.__proto__),
    clipPath: dart.nullable(ui.Path),
    clipBehavior: ui.Clip,
    elevation: dart.nullable(core.double),
    color: dart.nullable(ui.Color),
    shadowColor: dart.nullable(ui.Color)
  }));
  dart.setLibraryUri(layer$.PhysicalModelLayer, I[1]);
  dart.setFieldSignature(layer$.PhysicalModelLayer, () => ({
    __proto__: dart.getFields(layer$.PhysicalModelLayer.__proto__),
    [_clipPath]: dart.fieldType(dart.nullable(ui.Path)),
    [_clipBehavior]: dart.fieldType(ui.Clip),
    [_elevation]: dart.fieldType(dart.nullable(core.double)),
    [_color]: dart.fieldType(dart.nullable(ui.Color)),
    [_shadowColor]: dart.fieldType(dart.nullable(ui.Color))
  }));
  var leaderSize = dart.privateName(layer$, "LayerLink.leaderSize");
  var _leader = dart.privateName(layer$, "_leader");
  layer$.LayerLink = class LayerLink extends core.Object {
    get leaderSize() {
      return this[leaderSize];
    }
    set leaderSize(value) {
      this[leaderSize] = value;
    }
    get leader() {
      return this[_leader];
    }
    toString() {
      return dart.str(diagnostics.describeIdentity(this)) + "(" + (this[_leader] != null ? "<linked>" : "<dangling>") + ")";
    }
  };
  (layer$.LayerLink.new = function() {
    this[_leader] = null;
    this[leaderSize] = null;
    ;
  }).prototype = layer$.LayerLink.prototype;
  dart.addTypeTests(layer$.LayerLink);
  dart.addTypeCaches(layer$.LayerLink);
  dart.setGetterSignature(layer$.LayerLink, () => ({
    __proto__: dart.getGetters(layer$.LayerLink.__proto__),
    leader: dart.nullable(layer$.LeaderLayer)
  }));
  dart.setLibraryUri(layer$.LayerLink, I[1]);
  dart.setFieldSignature(layer$.LayerLink, () => ({
    __proto__: dart.getFields(layer$.LayerLink.__proto__),
    [_leader]: dart.fieldType(dart.nullable(layer$.LeaderLayer)),
    leaderSize: dart.fieldType(dart.nullable(ui.Size))
  }));
  dart.defineExtensionMethods(layer$.LayerLink, ['toString']);
  var offset$ = dart.privateName(layer$, "LeaderLayer.offset");
  var _lastOffset = dart.privateName(layer$, "_lastOffset");
  var _link = dart.privateName(layer$, "_link");
  layer$.LeaderLayer = class LeaderLayer extends layer$.ContainerLayer {
    get offset() {
      return this[offset$];
    }
    set offset(value) {
      this[offset$] = value;
    }
    get link() {
      return this[_link];
    }
    set link(value) {
      if (value == null) dart.nullFailed(I[0], 2029, 22, "value");
      if (!(value != null)) dart.assertFailed(null, I[0], 2030, 12, "value != null");
      this[_link] = value;
    }
    get alwaysNeedsAddToScene() {
      return true;
    }
    attach(owner) {
      core.Object.as(owner);
      if (owner == null) dart.nullFailed(I[0], 2049, 22, "owner");
      super.attach(owner);
      if (!(this.link.leader == null)) dart.assertFailed(null, I[0], 2051, 12, "link.leader == null");
      this[_lastOffset] = null;
      this.link[_leader] = this;
    }
    detach() {
      if (!dart.equals(this.link.leader, this)) dart.assertFailed(null, I[0], 2058, 12, "link.leader == this");
      this.link[_leader] = null;
      this[_lastOffset] = null;
      super.detach();
    }
    findAnnotations(S, result, localPosition, opts) {
      if (result == null) dart.nullFailed(I[0], 2072, 62, "result");
      if (localPosition == null) dart.nullFailed(I[0], 2072, 77, "localPosition");
      let onlyFirst = opts && 'onlyFirst' in opts ? opts.onlyFirst : null;
      if (onlyFirst == null) dart.nullFailed(I[0], 2072, 108, "onlyFirst");
      return super.findAnnotations(S, result, localPosition['-'](this.offset), {onlyFirst: onlyFirst});
    }
    addToScene(builder, layerOffset = C[0] || CT.C0) {
      if (builder == null) dart.nullFailed(I[0], 2077, 35, "builder");
      if (layerOffset == null) dart.nullFailed(I[0], 2077, 53, "layerOffset");
      if (!(this.offset != null)) dart.assertFailed(null, I[0], 2078, 12, "offset != null");
      this[_lastOffset] = this.offset['+'](layerOffset);
      if (!dart.equals(this[_lastOffset], ui.Offset.zero)) this.engineLayer = builder.pushTransform(vector_math_64.Matrix4.translationValues(dart.nullCheck(this[_lastOffset]).dx, dart.nullCheck(this[_lastOffset]).dy, 0.0).storage, {oldLayer: T$.TransformEngineLayerN().as(this[_engineLayer])});
      this.addChildrenToScene(builder);
      if (!dart.equals(this[_lastOffset], ui.Offset.zero)) builder.pop();
    }
    applyTransform(child, transform) {
      if (transform == null) dart.nullFailed(I[0], 2098, 45, "transform");
      if (!(this[_lastOffset] != null)) dart.assertFailed(null, I[0], 2099, 12, "_lastOffset != null");
      if (!dart.equals(this[_lastOffset], ui.Offset.zero)) transform.translate(dart.nullCheck(this[_lastOffset]).dx, dart.nullCheck(this[_lastOffset]).dy);
    }
    debugFillProperties(properties) {
      if (properties == null) dart.nullFailed(I[0], 2105, 56, "properties");
      super.debugFillProperties(properties);
      properties.add(new (T$.DiagnosticsPropertyOfOffset()).new("offset", this.offset));
      properties.add(new (T$.DiagnosticsPropertyOfLayerLink()).new("link", this.link));
    }
  };
  (layer$.LeaderLayer.new = function(opts) {
    let link = opts && 'link' in opts ? opts.link : null;
    if (link == null) dart.nullFailed(I[0], 2022, 36, "link");
    let offset = opts && 'offset' in opts ? opts.offset : C[0] || CT.C0;
    if (offset == null) dart.nullFailed(I[0], 2022, 47, "offset");
    this[_lastOffset] = null;
    this[offset$] = offset;
    if (!(link != null)) dart.assertFailed(null, I[0], 2022, 80, "link != null");
    this[_link] = link;
    layer$.LeaderLayer.__proto__.new.call(this);
    ;
  }).prototype = layer$.LeaderLayer.prototype;
  dart.addTypeTests(layer$.LeaderLayer);
  dart.addTypeCaches(layer$.LeaderLayer);
  dart.setMethodSignature(layer$.LeaderLayer, () => ({
    __proto__: dart.getMethods(layer$.LeaderLayer.__proto__),
    findAnnotations: dart.gFnType(S => [core.bool, [layer$.AnnotationResult$(S), ui.Offset], {}, {onlyFirst: core.bool}], S => [core.Object])
  }));
  dart.setGetterSignature(layer$.LeaderLayer, () => ({
    __proto__: dart.getGetters(layer$.LeaderLayer.__proto__),
    link: layer$.LayerLink
  }));
  dart.setSetterSignature(layer$.LeaderLayer, () => ({
    __proto__: dart.getSetters(layer$.LeaderLayer.__proto__),
    link: layer$.LayerLink
  }));
  dart.setLibraryUri(layer$.LeaderLayer, I[1]);
  dart.setFieldSignature(layer$.LeaderLayer, () => ({
    __proto__: dart.getFields(layer$.LeaderLayer.__proto__),
    [_link]: dart.fieldType(layer$.LayerLink),
    offset: dart.fieldType(ui.Offset),
    [_lastOffset]: dart.fieldType(dart.nullable(ui.Offset))
  }));
  var showWhenUnlinked$ = dart.privateName(layer$, "FollowerLayer.showWhenUnlinked");
  var unlinkedOffset$ = dart.privateName(layer$, "FollowerLayer.unlinkedOffset");
  var linkedOffset$ = dart.privateName(layer$, "FollowerLayer.linkedOffset");
  var _lastTransform = dart.privateName(layer$, "_lastTransform");
  var _establishTransform = dart.privateName(layer$, "_establishTransform");
  layer$.FollowerLayer = class FollowerLayer extends layer$.ContainerLayer {
    get showWhenUnlinked() {
      return this[showWhenUnlinked$];
    }
    set showWhenUnlinked(value) {
      this[showWhenUnlinked$] = value;
    }
    get unlinkedOffset() {
      return this[unlinkedOffset$];
    }
    set unlinkedOffset(value) {
      this[unlinkedOffset$] = value;
    }
    get linkedOffset() {
      return this[linkedOffset$];
    }
    set linkedOffset(value) {
      this[linkedOffset$] = value;
    }
    get link() {
      return this[_link];
    }
    set link(value) {
      if (value == null) dart.nullFailed(I[0], 2142, 22, "value");
      if (!(value != null)) dart.assertFailed(null, I[0], 2143, 12, "value != null");
      this[_link] = value;
    }
    [_transformOffset](localPosition) {
      if (localPosition == null) dart.nullFailed(I[0], 2195, 35, "localPosition");
      if (dart.test(this[_inverseDirty])) {
        this[_invertedTransform] = vector_math_64.Matrix4.tryInvert(dart.nullCheck(this.getLastTransform()));
        this[_inverseDirty] = false;
      }
      if (this[_invertedTransform] == null) return null;
      let vector = vector_math_64.Vector4.new(localPosition.dx, localPosition.dy, 0.0, 1.0);
      let result = dart.nullCheck(this[_invertedTransform]).transform(vector);
      return new ui.Offset.new(dart.notNull(result._get(0)) - dart.notNull(dart.nullCheck(this.linkedOffset).dx), dart.notNull(result._get(1)) - dart.notNull(dart.nullCheck(this.linkedOffset).dy));
    }
    findAnnotations(S, result, localPosition, opts) {
      if (result == null) dart.nullFailed(I[0], 2208, 62, "result");
      if (localPosition == null) dart.nullFailed(I[0], 2208, 77, "localPosition");
      let onlyFirst = opts && 'onlyFirst' in opts ? opts.onlyFirst : null;
      if (onlyFirst == null) dart.nullFailed(I[0], 2208, 108, "onlyFirst");
      if (this.link.leader == null) {
        if (dart.nullCheck(this.showWhenUnlinked)) {
          return super.findAnnotations(S, result, localPosition['-'](dart.nullCheck(this.unlinkedOffset)), {onlyFirst: onlyFirst});
        }
        return false;
      }
      let transformedOffset = this[_transformOffset](localPosition);
      if (transformedOffset == null) {
        return false;
      }
      return super.findAnnotations(S, result, transformedOffset, {onlyFirst: onlyFirst});
    }
    getLastTransform() {
      if (this[_lastTransform] == null) return null;
      let result = vector_math_64.Matrix4.translationValues(-dart.notNull(dart.nullCheck(this[_lastOffset]).dx), -dart.notNull(dart.nullCheck(this[_lastOffset]).dy), 0.0);
      result.multiply(dart.nullCheck(this[_lastTransform]));
      return result;
    }
    static _collectTransformForLayerChain(layers) {
      let t0;
      if (layers == null) dart.nullFailed(I[0], 2242, 71, "layers");
      let result = vector_math_64.Matrix4.identity();
      for (let index = dart.notNull(layers[$length]) - 1; index > 0; index = index - 1) {
        t0 = layers[$_get](index);
        t0 == null ? null : t0.applyTransform(layers[$_get](index - 1), result);
      }
      return result;
    }
    static _pathsToCommonAncestor(a, b, ancestorsA, ancestorsB) {
      if (ancestorsA == null) dart.nullFailed(I[0], 2260, 27, "ancestorsA");
      if (ancestorsB == null) dart.nullFailed(I[0], 2260, 61, "ancestorsB");
      if (a == null || b == null) return null;
      if (a == b) return a;
      if (dart.notNull(a.depth) < dart.notNull(b.depth)) {
        ancestorsB[$add](b.parent);
        return layer$.FollowerLayer._pathsToCommonAncestor(a, b.parent, ancestorsA, ancestorsB);
      } else if (dart.notNull(a.depth) > dart.notNull(b.depth)) {
        ancestorsA[$add](a.parent);
        return layer$.FollowerLayer._pathsToCommonAncestor(a.parent, b, ancestorsA, ancestorsB);
      }
      ancestorsA[$add](a.parent);
      ancestorsB[$add](b.parent);
      return layer$.FollowerLayer._pathsToCommonAncestor(a.parent, b.parent, ancestorsA, ancestorsB);
    }
    [_establishTransform]() {
      if (!(this.link != null)) dart.assertFailed(null, I[0], 2284, 12, "link != null");
      this[_lastTransform] = null;
      let leader = this.link.leader;
      if (leader == null) return;
      if (!dart.equals(leader.owner, this.owner)) dart.assertFailed("Linked LeaderLayer anchor is not in the same layer tree as the FollowerLayer.", I[0], 2292, 7, "leader.owner == owner");
      if (!(leader[_lastOffset] != null)) dart.assertFailed("LeaderLayer anchor must come before FollowerLayer in paint order, but the reverse was true.", I[0], 2296, 7, "leader._lastOffset != null");
      let forwardLayers = T$.JSArrayOfContainerLayer().of([leader]);
      let inverseLayers = T$.JSArrayOfContainerLayer().of([this]);
      let ancestor = layer$.FollowerLayer._pathsToCommonAncestor(leader, this, forwardLayers, inverseLayers);
      if (!(ancestor != null)) dart.assertFailed(null, I[0], 2310, 12, "ancestor != null");
      let forwardTransform = layer$.FollowerLayer._collectTransformForLayerChain(forwardLayers);
      leader.applyTransform(null, forwardTransform);
      forwardTransform.translate(dart.nullCheck(this.linkedOffset).dx, dart.nullCheck(this.linkedOffset).dy);
      let inverseTransform = layer$.FollowerLayer._collectTransformForLayerChain(inverseLayers);
      if (inverseTransform.invert() === 0.0) {
        return;
      }
      inverseTransform.multiply(forwardTransform);
      this[_lastTransform] = inverseTransform;
      this[_inverseDirty] = true;
    }
    get alwaysNeedsAddToScene() {
      return true;
    }
    addToScene(builder, layerOffset = C[0] || CT.C0) {
      if (builder == null) dart.nullFailed(I[0], 2345, 35, "builder");
      if (layerOffset == null) dart.nullFailed(I[0], 2345, 53, "layerOffset");
      if (!(this.link != null)) dart.assertFailed(null, I[0], 2346, 12, "link != null");
      if (!(this.showWhenUnlinked != null)) dart.assertFailed(null, I[0], 2347, 12, "showWhenUnlinked != null");
      if (this.link.leader == null && !dart.nullCheck(this.showWhenUnlinked)) {
        this[_lastTransform] = null;
        this[_lastOffset] = null;
        this[_inverseDirty] = true;
        this.engineLayer = null;
        return;
      }
      this[_establishTransform]();
      if (this[_lastTransform] != null) {
        this.engineLayer = builder.pushTransform(dart.nullCheck(this[_lastTransform]).storage, {oldLayer: T$.TransformEngineLayerN().as(this[_engineLayer])});
        this.addChildrenToScene(builder);
        builder.pop();
        this[_lastOffset] = dart.nullCheck(this.unlinkedOffset)['+'](layerOffset);
      } else {
        this[_lastOffset] = null;
        let matrix = vector_math_64.Matrix4.translationValues(dart.nullCheck(this.unlinkedOffset).dx, dart.nullCheck(this.unlinkedOffset).dy, 0.0);
        this.engineLayer = builder.pushTransform(matrix.storage, {oldLayer: T$.TransformEngineLayerN().as(this[_engineLayer])});
        this.addChildrenToScene(builder);
        builder.pop();
      }
      this[_inverseDirty] = true;
    }
    applyTransform(child, transform) {
      if (transform == null) dart.nullFailed(I[0], 2378, 45, "transform");
      if (!(child != null)) dart.assertFailed(null, I[0], 2379, 12, "child != null");
      if (!(transform != null)) dart.assertFailed(null, I[0], 2380, 12, "transform != null");
      if (this[_lastTransform] != null) {
        transform.multiply(dart.nullCheck(this[_lastTransform]));
      } else {
        transform.multiply(vector_math_64.Matrix4.translationValues(dart.nullCheck(this.unlinkedOffset).dx, dart.nullCheck(this.unlinkedOffset).dy, 0.0));
      }
    }
    debugFillProperties(properties) {
      if (properties == null) dart.nullFailed(I[0], 2389, 56, "properties");
      super.debugFillProperties(properties);
      properties.add(new (T$.DiagnosticsPropertyOfLayerLink()).new("link", this.link));
      properties.add(new matrix_utils.TransformProperty.new("transform", this.getLastTransform(), {defaultValue: null}));
    }
  };
  (layer$.FollowerLayer.new = function(opts) {
    let link = opts && 'link' in opts ? opts.link : null;
    if (link == null) dart.nullFailed(I[0], 2130, 24, "link");
    let showWhenUnlinked = opts && 'showWhenUnlinked' in opts ? opts.showWhenUnlinked : true;
    let unlinkedOffset = opts && 'unlinkedOffset' in opts ? opts.unlinkedOffset : C[0] || CT.C0;
    let linkedOffset = opts && 'linkedOffset' in opts ? opts.linkedOffset : C[0] || CT.C0;
    this[_lastOffset] = null;
    this[_lastTransform] = null;
    this[_invertedTransform] = null;
    this[_inverseDirty] = true;
    this[showWhenUnlinked$] = showWhenUnlinked;
    this[unlinkedOffset$] = unlinkedOffset;
    this[linkedOffset$] = linkedOffset;
    if (!(link != null)) dart.assertFailed(null, I[0], 2134, 15, "link != null");
    this[_link] = link;
    layer$.FollowerLayer.__proto__.new.call(this);
    ;
  }).prototype = layer$.FollowerLayer.prototype;
  dart.addTypeTests(layer$.FollowerLayer);
  dart.addTypeCaches(layer$.FollowerLayer);
  dart.setMethodSignature(layer$.FollowerLayer, () => ({
    __proto__: dart.getMethods(layer$.FollowerLayer.__proto__),
    [_transformOffset]: dart.fnType(dart.nullable(ui.Offset), [ui.Offset]),
    findAnnotations: dart.gFnType(S => [core.bool, [layer$.AnnotationResult$(S), ui.Offset], {}, {onlyFirst: core.bool}], S => [core.Object]),
    getLastTransform: dart.fnType(dart.nullable(vector_math_64.Matrix4), []),
    [_establishTransform]: dart.fnType(dart.void, [])
  }));
  dart.setGetterSignature(layer$.FollowerLayer, () => ({
    __proto__: dart.getGetters(layer$.FollowerLayer.__proto__),
    link: layer$.LayerLink
  }));
  dart.setSetterSignature(layer$.FollowerLayer, () => ({
    __proto__: dart.getSetters(layer$.FollowerLayer.__proto__),
    link: layer$.LayerLink
  }));
  dart.setLibraryUri(layer$.FollowerLayer, I[1]);
  dart.setFieldSignature(layer$.FollowerLayer, () => ({
    __proto__: dart.getFields(layer$.FollowerLayer.__proto__),
    [_link]: dart.fieldType(layer$.LayerLink),
    showWhenUnlinked: dart.fieldType(dart.nullable(core.bool)),
    unlinkedOffset: dart.fieldType(dart.nullable(ui.Offset)),
    linkedOffset: dart.fieldType(dart.nullable(ui.Offset)),
    [_lastOffset]: dart.fieldType(dart.nullable(ui.Offset)),
    [_lastTransform]: dart.fieldType(dart.nullable(vector_math_64.Matrix4)),
    [_invertedTransform]: dart.fieldType(dart.nullable(vector_math_64.Matrix4)),
    [_inverseDirty]: dart.fieldType(core.bool)
  }));
  var value$ = dart.privateName(layer$, "AnnotatedRegionLayer.value");
  var size$ = dart.privateName(layer$, "AnnotatedRegionLayer.size");
  var offset$0 = dart.privateName(layer$, "AnnotatedRegionLayer.offset");
  var opaque$ = dart.privateName(layer$, "AnnotatedRegionLayer.opaque");
  const _is_AnnotatedRegionLayer_default = Symbol('_is_AnnotatedRegionLayer_default');
  layer$.AnnotatedRegionLayer$ = dart.generic(T => {
    var DiagnosticsPropertyOfT = () => (DiagnosticsPropertyOfT = dart.constFn(diagnostics.DiagnosticsProperty$(T)))();
    class AnnotatedRegionLayer extends layer$.ContainerLayer {
      get value() {
        return this[value$];
      }
      set value(value) {
        super.value = value;
      }
      get size() {
        return this[size$];
      }
      set size(value) {
        super.size = value;
      }
      get offset() {
        return this[offset$0];
      }
      set offset(value) {
        super.offset = value;
      }
      get opaque() {
        return this[opaque$];
      }
      set opaque(value) {
        super.opaque = value;
      }
      findAnnotations(S, result, localPosition, opts) {
        if (result == null) dart.nullFailed(I[0], 2498, 62, "result");
        if (localPosition == null) dart.nullFailed(I[0], 2498, 77, "localPosition");
        let onlyFirst = opts && 'onlyFirst' in opts ? opts.onlyFirst : null;
        if (onlyFirst == null) dart.nullFailed(I[0], 2498, 108, "onlyFirst");
        let isAbsorbed = super.findAnnotations(S, result, localPosition, {onlyFirst: onlyFirst});
        if (dart.test(result.entries[$isNotEmpty]) && dart.test(onlyFirst)) return isAbsorbed;
        if (this.size != null && !dart.test(this.offset['&'](dart.nullCheck(this.size)).contains(localPosition))) {
          return isAbsorbed;
        }
        if (dart.wrapType(T)._equals(dart.wrapType(S))) {
          isAbsorbed = dart.test(isAbsorbed) || dart.test(this.opaque);
          let untypedValue = this.value;
          let typedValue = S.as(untypedValue);
          result.add(new (layer$.AnnotationEntry$(S)).new({annotation: typedValue, localPosition: localPosition['-'](this.offset)}));
        }
        return isAbsorbed;
      }
      debugFillProperties(properties) {
        if (properties == null) dart.nullFailed(I[0], 2518, 56, "properties");
        super.debugFillProperties(properties);
        properties.add(new (DiagnosticsPropertyOfT()).new("value", this.value));
        properties.add(new (T$.DiagnosticsPropertyOfSize()).new("size", this.size, {defaultValue: null}));
        properties.add(new (T$.DiagnosticsPropertyOfOffset()).new("offset", this.offset, {defaultValue: null}));
        properties.add(new (T$.DiagnosticsPropertyOfbool()).new("opaque", this.opaque, {defaultValue: false}));
      }
    }
    (AnnotatedRegionLayer.new = function(value, opts) {
      let t0;
      if (value == null) dart.nullFailed(I[0], 2422, 10, "value");
      let size = opts && 'size' in opts ? opts.size : null;
      let offset = opts && 'offset' in opts ? opts.offset : null;
      let opaque = opts && 'opaque' in opts ? opts.opaque : false;
      if (opaque == null) dart.nullFailed(I[0], 2425, 10, "opaque");
      this[value$] = value;
      this[size$] = size;
      this[opaque$] = opaque;
      if (!(value != null)) dart.assertFailed(null, I[0], 2426, 15, "value != null");
      if (!(opaque != null)) dart.assertFailed(null, I[0], 2427, 15, "opaque != null");
      this[offset$0] = (t0 = offset, t0 == null ? ui.Offset.zero : t0);
      AnnotatedRegionLayer.__proto__.new.call(this);
      ;
    }).prototype = AnnotatedRegionLayer.prototype;
    dart.addTypeTests(AnnotatedRegionLayer);
    AnnotatedRegionLayer.prototype[_is_AnnotatedRegionLayer_default] = true;
    dart.addTypeCaches(AnnotatedRegionLayer);
    dart.setMethodSignature(AnnotatedRegionLayer, () => ({
      __proto__: dart.getMethods(AnnotatedRegionLayer.__proto__),
      findAnnotations: dart.gFnType(S => [core.bool, [layer$.AnnotationResult$(S), ui.Offset], {}, {onlyFirst: core.bool}], S => [core.Object])
    }));
    dart.setLibraryUri(AnnotatedRegionLayer, I[1]);
    dart.setFieldSignature(AnnotatedRegionLayer, () => ({
      __proto__: dart.getFields(AnnotatedRegionLayer.__proto__),
      value: dart.finalFieldType(T),
      size: dart.finalFieldType(dart.nullable(ui.Size)),
      offset: dart.finalFieldType(ui.Offset),
      opaque: dart.finalFieldType(core.bool)
    }));
    return AnnotatedRegionLayer;
  });
  layer$.AnnotatedRegionLayer = layer$.AnnotatedRegionLayer$();
  dart.addTypeTests(layer$.AnnotatedRegionLayer, _is_AnnotatedRegionLayer_default);
  var size$0 = dart.privateName(view, "ViewConfiguration.size");
  var devicePixelRatio$ = dart.privateName(view, "ViewConfiguration.devicePixelRatio");
  view.ViewConfiguration = class ViewConfiguration extends core.Object {
    get size() {
      return this[size$0];
    }
    set size(value) {
      super.size = value;
    }
    get devicePixelRatio() {
      return this[devicePixelRatio$];
    }
    set devicePixelRatio(value) {
      super.devicePixelRatio = value;
    }
    toMatrix() {
      return vector_math_64.Matrix4.diagonal3Values(this.devicePixelRatio, this.devicePixelRatio, 1.0);
    }
    toString() {
      return dart.str(this.size) + " at " + dart.str(debug.debugFormatDouble(this.devicePixelRatio)) + "x";
    }
  };
  (view.ViewConfiguration.new = function(opts) {
    let size = opts && 'size' in opts ? opts.size : C[6] || CT.C6;
    if (size == null) dart.nullFailed(I[2], 26, 10, "size");
    let devicePixelRatio = opts && 'devicePixelRatio' in opts ? opts.devicePixelRatio : 1;
    if (devicePixelRatio == null) dart.nullFailed(I[2], 27, 10, "devicePixelRatio");
    this[size$0] = size;
    this[devicePixelRatio$] = devicePixelRatio;
    ;
  }).prototype = view.ViewConfiguration.prototype;
  dart.addTypeTests(view.ViewConfiguration);
  dart.addTypeCaches(view.ViewConfiguration);
  dart.setMethodSignature(view.ViewConfiguration, () => ({
    __proto__: dart.getMethods(view.ViewConfiguration.__proto__),
    toMatrix: dart.fnType(vector_math_64.Matrix4, [])
  }));
  dart.setLibraryUri(view.ViewConfiguration, I[3]);
  dart.setFieldSignature(view.ViewConfiguration, () => ({
    __proto__: dart.getFields(view.ViewConfiguration.__proto__),
    size: dart.finalFieldType(ui.Size),
    devicePixelRatio: dart.finalFieldType(core.double)
  }));
  dart.defineExtensionMethods(view.ViewConfiguration, ['toString']);
  var automaticSystemUiAdjustment = dart.privateName(view, "RenderView.automaticSystemUiAdjustment");
  var _size = dart.privateName(view, "_size");
  var _rootTransform = dart.privateName(view, "_rootTransform");
  var _configuration = dart.privateName(view, "_configuration");
  var _window = dart.privateName(view, "_window");
  var _updateMatricesAndCreateNewRootLayer = dart.privateName(view, "_updateMatricesAndCreateNewRootLayer");
  var _updateSystemChrome = dart.privateName(view, "_updateSystemChrome");
  var _name$ = dart.privateName(platform, "_name");
  var parentData = dart.privateName(object$, "RenderObject.parentData");
  var debugCreator$ = dart.privateName(object$, "RenderObject.debugCreator");
  var _debugDoingThisResize = dart.privateName(object$, "_debugDoingThisResize");
  var _debugDoingThisLayout = dart.privateName(object$, "_debugDoingThisLayout");
  var _debugCanParentUseSize = dart.privateName(object$, "_debugCanParentUseSize");
  var _debugMutationsLocked = dart.privateName(object$, "_debugMutationsLocked");
  var _needsLayout = dart.privateName(object$, "_needsLayout");
  var _relayoutBoundary = dart.privateName(object$, "_relayoutBoundary");
  var _doingThisLayoutWithCallback = dart.privateName(object$, "_doingThisLayoutWithCallback");
  var _constraints = dart.privateName(object$, "_constraints");
  var _debugDoingThisPaint = dart.privateName(object$, "_debugDoingThisPaint");
  var _layer = dart.privateName(object$, "_layer");
  var _needsCompositingBitsUpdate = dart.privateName(object$, "_needsCompositingBitsUpdate");
  var __RenderObject__needsCompositing = dart.privateName(object$, "_#RenderObject#_needsCompositing");
  var __RenderObject__needsCompositing_isSet = dart.privateName(object$, "_#RenderObject#_needsCompositing#isSet");
  var _needsPaint = dart.privateName(object$, "_needsPaint");
  var _cachedSemanticsConfiguration = dart.privateName(object$, "_cachedSemanticsConfiguration");
  var _needsSemanticsUpdate = dart.privateName(object$, "_needsSemanticsUpdate");
  var _semantics = dart.privateName(object$, "_semantics");
  var _needsCompositing = dart.privateName(object$, "_needsCompositing");
  var _debugCanPerformMutations = dart.privateName(object$, "_debugCanPerformMutations");
  var _cleanRelayoutBoundary = dart.privateName(object$, "_cleanRelayoutBoundary");
  var _debugReportException = dart.privateName(object$, "_debugReportException");
  var _debugAllowMutationsToDirtySubtrees = dart.privateName(object$, "_debugAllowMutationsToDirtySubtrees");
  var _semanticsConfiguration = dart.privateName(object$, "_semanticsConfiguration");
  var _debugSubtreeRelayoutRootAlreadyMarkedNeedsLayout = dart.privateName(object$, "_debugSubtreeRelayoutRootAlreadyMarkedNeedsLayout");
  var _nodesNeedingLayout = dart.privateName(object$, "_nodesNeedingLayout");
  var _debugDoingLayout = dart.privateName(object$, "_debugDoingLayout");
  var _layoutWithoutResize = dart.privateName(object$, "_layoutWithoutResize");
  var _enableMutationsToDirtySubtrees = dart.privateName(object$, "_enableMutationsToDirtySubtrees");
  var _nodesNeedingCompositingBitsUpdate = dart.privateName(object$, "_nodesNeedingCompositingBitsUpdate");
  var _updateCompositingBits = dart.privateName(object$, "_updateCompositingBits");
  var _nodesNeedingPaint = dart.privateName(object$, "_nodesNeedingPaint");
  var _skippedPaintingOnLayer = dart.privateName(object$, "_skippedPaintingOnLayer");
  var _debugDoingPaint = dart.privateName(object$, "_debugDoingPaint");
  var _paintWithContext = dart.privateName(object$, "_paintWithContext");
  var _debugDoingSemantics = dart.privateName(object$, "_debugDoingSemantics");
  var _semanticsOwner = dart.privateName(object$, "_semanticsOwner");
  var _nodesNeedingSemantics = dart.privateName(object$, "_nodesNeedingSemantics");
  var _getSemanticsForParent = dart.privateName(object$, "_getSemanticsForParent");
  var _updateSemantics = dart.privateName(object$, "_updateSemantics");
  var _name$0 = dart.privateName(diagnostics, "_name");
  var Duration__duration = dart.privateName(core, "Duration._duration");
  var Cubic_d = dart.privateName(curves, "Cubic.d");
  var Cubic_c = dart.privateName(curves, "Cubic.c");
  var Cubic_b = dart.privateName(curves, "Cubic.b");
  var Cubic_a = dart.privateName(curves, "Cubic.a");
  const AbstractNode_DiagnosticableTreeMixin$36$ = class AbstractNode_DiagnosticableTreeMixin extends node.AbstractNode {};
  (AbstractNode_DiagnosticableTreeMixin$36$.new = function() {
    AbstractNode_DiagnosticableTreeMixin$36$.__proto__.new.call(this);
  }).prototype = AbstractNode_DiagnosticableTreeMixin$36$.prototype;
  dart.applyMixin(AbstractNode_DiagnosticableTreeMixin$36$, diagnostics.DiagnosticableTreeMixin);
  object$.RenderObject = class RenderObject extends AbstractNode_DiagnosticableTreeMixin$36$ {
    get parentData() {
      return this[parentData];
    }
    set parentData(value) {
      this[parentData] = value;
    }
    get debugCreator() {
      return this[debugCreator$];
    }
    set debugCreator(value) {
      this[debugCreator$] = value;
    }
    reassemble() {
      this.markNeedsLayout();
      this.markNeedsCompositingBitsUpdate();
      this.markNeedsPaint();
      this.markNeedsSemanticsUpdate();
      this.visitChildren(dart.fn(child => {
        if (child == null) dart.nullFailed(I[4], 1233, 33, "child");
        child.reassemble();
      }, T$.RenderObjectTovoid()));
    }
    setupParentData(child) {
      object$.RenderObject.as(child);
      if (child == null) dart.nullFailed(I[4], 1261, 47, "child");
      if (!dart.test(this[_debugCanPerformMutations])) dart.assertFailed(null, I[4], 1262, 12, "_debugCanPerformMutations");
      if (!object$.ParentData.is(child.parentData)) child.parentData = new object$.ParentData.new();
    }
    adoptChild(child) {
      object$.RenderObject.as(child);
      if (child == null) dart.nullFailed(I[4], 1272, 32, "child");
      if (!dart.test(this[_debugCanPerformMutations])) dart.assertFailed(null, I[4], 1273, 12, "_debugCanPerformMutations");
      if (!(child != null)) dart.assertFailed(null, I[4], 1274, 12, "child != null");
      this.setupParentData(child);
      this.markNeedsLayout();
      this.markNeedsCompositingBitsUpdate();
      this.markNeedsSemanticsUpdate();
      super.adoptChild(child);
    }
    dropChild(child) {
      object$.RenderObject.as(child);
      if (child == null) dart.nullFailed(I[4], 1287, 31, "child");
      if (!dart.test(this[_debugCanPerformMutations])) dart.assertFailed(null, I[4], 1288, 12, "_debugCanPerformMutations");
      if (!(child != null)) dart.assertFailed(null, I[4], 1289, 12, "child != null");
      if (!(child.parentData != null)) dart.assertFailed(null, I[4], 1290, 12, "child.parentData != null");
      child[_cleanRelayoutBoundary]();
      dart.nullCheck(child.parentData).detach();
      child.parentData = null;
      super.dropChild(child);
      this.markNeedsLayout();
      this.markNeedsCompositingBitsUpdate();
      this.markNeedsSemanticsUpdate();
    }
    visitChildren(visitor) {
      if (visitor == null) dart.nullFailed(I[4], 1303, 42, "visitor");
    }
    [_debugReportException](method, exception, stack) {
      if (method == null) dart.nullFailed(I[4], 1314, 37, "method");
      if (exception == null) dart.nullFailed(I[4], 1314, 52, "exception");
      if (stack == null) dart.nullFailed(I[4], 1314, 74, "stack");
      assertions.FlutterError.reportError(new assertions.FlutterErrorDetails.new({exception: exception, stack: stack, library: "rendering library", context: new assertions.ErrorDescription.new("during " + dart.str(method) + "()"), informationCollector: dart.fn(() => new (T$.SyncIterableOfDiagnosticsNode()).new((function*() {
          if (this.debugCreator != null) yield new object$.DiagnosticsDebugCreator.new(dart.nullCheck(this.debugCreator));
          yield this.describeForError("The following RenderObject was being processed when the exception was fired");
          yield this.describeForError("RenderObject", {style: diagnostics.DiagnosticsTreeStyle.truncateChildren});
        }).bind(this)), T$.VoidToIterableOfDiagnosticsNode())}));
    }
    get debugDoingThisResize() {
      return this[_debugDoingThisResize];
    }
    get debugDoingThisLayout() {
      return this[_debugDoingThisLayout];
    }
    static get debugActiveLayout() {
      return object$.RenderObject._debugActiveLayout;
    }
    get debugCanParentUseSize() {
      return dart.nullCheck(this[_debugCanParentUseSize]);
    }
    get [_debugCanPerformMutations]() {
      let result = null;
      let result$35isSet = false;
      function result$35get() {
        return result$35isSet ? result : dart.throw(new _internal.LateError.localNI("result"));
      }
      dart.fn(result$35get, T$.VoidTobool());
      function result$35set(t3) {
        if (t3 == null) dart.nullFailed(I[4], 1370, 15, "null");
        result$35isSet = true;
        return result = t3;
      }
      dart.fn(result$35set, T$.boolTodynamic());
      if (!dart.test(dart.fn(() => {
        let node = this;
        while (true) {
          if (dart.test(node[_doingThisLayoutWithCallback])) {
            result$35set(true);
            break;
          }
          if (this.owner != null && dart.test(dart.nullCheck(this.owner)[_debugAllowMutationsToDirtySubtrees]) && dart.test(node[_needsLayout])) {
            result$35set(true);
            break;
          }
          if (dart.test(node[_debugMutationsLocked])) {
            result$35set(false);
            break;
          }
          if (!object$.RenderObject.is(node.parent)) {
            result$35set(true);
            break;
          }
          node = object$.RenderObject.as(dart.nullCheck(node.parent));
        }
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 1371, 12, "() {\r\n      RenderObject node = this;\r\n      while (true) {\r\n        if (node._doingThisLayoutWithCallback) {\r\n          result = true;\r\n          break;\r\n        }\r\n        if (owner != null && owner!._debugAllowMutationsToDirtySubtrees && node._needsLayout) {\r\n          result = true;\r\n          break;\r\n        }\r\n        if (node._debugMutationsLocked) {\r\n          result = false;\r\n          break;\r\n        }\r\n        if (node.parent is! RenderObject) {\r\n          result = true;\r\n          break;\r\n        }\r\n        node = node.parent! as RenderObject;\r\n      }\r\n      return true;\r\n    }()");
      return result$35get();
    }
    get owner() {
      return T$.PipelineOwnerN().as(super.owner);
    }
    attach(owner) {
      object$.PipelineOwner.as(owner);
      if (owner == null) dart.nullFailed(I[4], 1401, 29, "owner");
      super.attach(owner);
      if (dart.test(this[_needsLayout]) && this[_relayoutBoundary] != null) {
        this[_needsLayout] = false;
        this.markNeedsLayout();
      }
      if (dart.test(this[_needsCompositingBitsUpdate])) {
        this[_needsCompositingBitsUpdate] = false;
        this.markNeedsCompositingBitsUpdate();
      }
      if (dart.test(this[_needsPaint]) && this[_layer] != null) {
        this[_needsPaint] = false;
        this.markNeedsPaint();
      }
      if (dart.test(this[_needsSemanticsUpdate]) && dart.test(this[_semanticsConfiguration].isSemanticBoundary)) {
        this[_needsSemanticsUpdate] = false;
        this.markNeedsSemanticsUpdate();
      }
    }
    get debugNeedsLayout() {
      let result = null;
      let result$35isSet = false;
      function result$35get() {
        return result$35isSet ? result : dart.throw(new _internal.LateError.localNI("result"));
      }
      dart.fn(result$35get, T$.VoidTobool());
      function result$35set(t8) {
        if (t8 == null) dart.nullFailed(I[4], 1438, 15, "null");
        result$35isSet = true;
        return result = t8;
      }
      dart.fn(result$35set, T$.boolTodynamic());
      if (!dart.test(dart.fn(() => {
        result$35set(this[_needsLayout]);
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 1439, 12, "() {\r\n      result = _needsLayout;\r\n      return true;\r\n    }()");
      return result$35get();
    }
    get debugDoingThisLayoutWithCallback() {
      return this[_doingThisLayoutWithCallback];
    }
    get constraints() {
      if (this[_constraints] == null) dart.throw(new core.StateError.new("A RenderObject does not have any constraints before it has been laid out."));
      return dart.nullCheck(this[_constraints]);
    }
    [_debugSubtreeRelayoutRootAlreadyMarkedNeedsLayout]() {
      if (this[_relayoutBoundary] == null) return true;
      let node = this;
      while (!node[$_equals](this[_relayoutBoundary])) {
        if (!dart.equals(node[_relayoutBoundary], this[_relayoutBoundary])) dart.assertFailed(null, I[4], 1488, 14, "node._relayoutBoundary == _relayoutBoundary");
        if (!(node.parent != null)) dart.assertFailed(null, I[4], 1489, 14, "node.parent != null");
        node = object$.RenderObject.as(dart.nullCheck(node.parent));
        if (!dart.test(node[_needsLayout]) && !dart.test(node[_debugDoingThisLayout])) return false;
      }
      if (!dart.equals(node[_relayoutBoundary], node)) dart.assertFailed(null, I[4], 1494, 12, "node._relayoutBoundary == node");
      return true;
    }
    markNeedsLayout() {
      if (!dart.test(this[_debugCanPerformMutations])) dart.assertFailed(null, I[4], 1537, 12, "_debugCanPerformMutations");
      if (dart.test(this[_needsLayout])) {
        if (!dart.test(this[_debugSubtreeRelayoutRootAlreadyMarkedNeedsLayout]())) dart.assertFailed(null, I[4], 1539, 14, "_debugSubtreeRelayoutRootAlreadyMarkedNeedsLayout()");
        return;
      }
      if (!(this[_relayoutBoundary] != null)) dart.assertFailed(null, I[4], 1542, 12, "_relayoutBoundary != null");
      if (!dart.equals(this[_relayoutBoundary], this)) {
        this.markParentNeedsLayout();
      } else {
        this[_needsLayout] = true;
        if (this.owner != null) {
          if (!dart.test(dart.fn(() => {
            if (dart.test(debug$0.debugPrintMarkNeedsLayoutStacks)) assertions.debugPrintStack({label: "markNeedsLayout() called for " + dart.str(this)});
            return true;
          }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 1548, 16, "() {\r\n          if (debugPrintMarkNeedsLayoutStacks)\r\n            debugPrintStack(label: 'markNeedsLayout() called for $this');\r\n          return true;\r\n        }()");
          dart.nullCheck(this.owner)[_nodesNeedingLayout][$add](this);
          dart.nullCheck(this.owner).requestVisualUpdate();
        }
      }
    }
    markParentNeedsLayout() {
      this[_needsLayout] = true;
      if (!(this.parent != null)) dart.assertFailed(null, I[4], 1571, 12, "this.parent != null");
      let parent = object$.RenderObject.as(dart.nullCheck(this.parent));
      if (!dart.test(this[_doingThisLayoutWithCallback])) {
        parent.markNeedsLayout();
      } else {
        if (!dart.test(parent[_debugDoingThisLayout])) dart.assertFailed(null, I[4], 1576, 14, "parent._debugDoingThisLayout");
      }
      if (!parent[$_equals](this.parent)) dart.assertFailed(null, I[4], 1578, 12, "parent == this.parent");
    }
    markNeedsLayoutForSizedByParentChange() {
      this.markNeedsLayout();
      this.markParentNeedsLayout();
    }
    [_cleanRelayoutBoundary]() {
      if (!dart.equals(this[_relayoutBoundary], this)) {
        this[_relayoutBoundary] = null;
        this[_needsLayout] = true;
        this.visitChildren(C[13] || CT.C13);
      }
    }
    static _cleanChildRelayoutBoundary(child) {
      if (child == null) dart.nullFailed(I[4], 1602, 56, "child");
      child[_cleanRelayoutBoundary]();
    }
    scheduleInitialLayout() {
      if (!dart.test(this.attached)) dart.assertFailed(null, I[4], 1613, 12, "attached");
      if (!!object$.RenderObject.is(this.parent)) dart.assertFailed(null, I[4], 1614, 12, "parent is! RenderObject");
      if (!!dart.test(dart.nullCheck(this.owner)[_debugDoingLayout])) dart.assertFailed(null, I[4], 1615, 12, "!owner!._debugDoingLayout");
      if (!(this[_relayoutBoundary] == null)) dart.assertFailed(null, I[4], 1616, 12, "_relayoutBoundary == null");
      this[_relayoutBoundary] = this;
      if (!dart.test(dart.fn(() => {
        this[_debugCanParentUseSize] = false;
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 1618, 12, "() {\r\n      _debugCanParentUseSize = false;\r\n      return true;\r\n    }()");
      dart.nullCheck(this.owner)[_nodesNeedingLayout][$add](this);
    }
    [_layoutWithoutResize]() {
      if (!dart.equals(this[_relayoutBoundary], this)) dart.assertFailed(null, I[4], 1626, 12, "_relayoutBoundary == this");
      let debugPreviousActiveLayout = null;
      if (!!dart.test(this[_debugMutationsLocked])) dart.assertFailed(null, I[4], 1628, 12, "!_debugMutationsLocked");
      if (!!dart.test(this[_doingThisLayoutWithCallback])) dart.assertFailed(null, I[4], 1629, 12, "!_doingThisLayoutWithCallback");
      if (!(this[_debugCanParentUseSize] != null)) dart.assertFailed(null, I[4], 1630, 12, "_debugCanParentUseSize != null");
      if (!dart.test(dart.fn(() => {
        this[_debugMutationsLocked] = true;
        this[_debugDoingThisLayout] = true;
        debugPreviousActiveLayout = object$.RenderObject._debugActiveLayout;
        object$.RenderObject._debugActiveLayout = this;
        if (dart.test(debug$0.debugPrintLayouts)) print.debugPrint("Laying out (without resize) " + dart.str(this));
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 1631, 12, "() {\r\n      _debugMutationsLocked = true;\r\n      _debugDoingThisLayout = true;\r\n      debugPreviousActiveLayout = _debugActiveLayout;\r\n      _debugActiveLayout = this;\r\n      if (debugPrintLayouts)\r\n        debugPrint('Laying out (without resize) $this');\r\n      return true;\r\n    }()");
      try {
        this.performLayout();
        this.markNeedsSemanticsUpdate();
      } catch (e$) {
        let e = dart.getThrown(e$);
        let stack = dart.stackTrace(e$);
        if (core.Object.is(e)) {
          this[_debugReportException]("performLayout", e, stack);
        } else
          throw e$;
      }
      if (!dart.test(dart.fn(() => {
        object$.RenderObject._debugActiveLayout = debugPreviousActiveLayout;
        this[_debugDoingThisLayout] = false;
        this[_debugMutationsLocked] = false;
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 1646, 12, "() {\r\n      _debugActiveLayout = debugPreviousActiveLayout;\r\n      _debugDoingThisLayout = false;\r\n      _debugMutationsLocked = false;\r\n      return true;\r\n    }()");
      this[_needsLayout] = false;
      this.markNeedsPaint();
    }
    layout(constraints, opts) {
      if (constraints == null) dart.nullFailed(I[4], 1679, 27, "constraints");
      let parentUsesSize = opts && 'parentUsesSize' in opts ? opts.parentUsesSize : false;
      if (parentUsesSize == null) dart.nullFailed(I[4], 1679, 47, "parentUsesSize");
      if (!false && dart.test(debug$0.debugProfileLayoutsEnabled)) developer.Timeline.startSync(dart.str(this[$runtimeType]), {arguments: debug.timelineArgumentsIndicatingLandmarkEvent});
      if (!(constraints != null)) dart.assertFailed(null, I[4], 1683, 12, "constraints != null");
      if (!dart.test(constraints.debugAssertIsValid({isAppliedConstraint: true, informationCollector: dart.fn(() => new (T$.SyncIterableOfDiagnosticsNode()).new((function*() {
          let stack = dart.toString(core.StackTrace.current)[$split]("\n");
          let targetFrame = null;
          let layoutFramePattern = core.RegExp.new("^#[0-9]+ +RenderObject.layout \\(");
          for (let i = 0; i < dart.notNull(stack[$length]); i = i + 1) {
            if (layoutFramePattern[$matchAsPrefix](stack[$_get](i)) != null) {
              targetFrame = i + 1;
              break;
            }
          }
          if (targetFrame != null && dart.notNull(targetFrame) < dart.notNull(stack[$length])) {
            let targetFramePattern = core.RegExp.new("^#[0-9]+ +(.+)$");
            let targetFrameMatch = targetFramePattern[$matchAsPrefix](stack[$_get](targetFrame));
            let problemFunction = targetFrameMatch != null && dart.notNull(targetFrameMatch.groupCount) > 0 ? targetFrameMatch.group(1) : stack[$_get](targetFrame)[$trim]();
            yield new assertions.ErrorDescription.new("These invalid constraints were provided to " + dart.str(this[$runtimeType]) + "'s layout() " + "function by the following function, which probably computed the " + "invalid constraints in question:\n" + "  " + dart.str(problemFunction));
          }
        }).bind(this)), T$.VoidToIterableOfDiagnosticsNode())}))) dart.assertFailed(null, I[4], 1684, 12, "constraints.debugAssertIsValid(\r\n      isAppliedConstraint: true,\r\n      informationCollector: () sync* {\r\n        final List<String> stack = StackTrace.current.toString().split('\\n');\r\n        int? targetFrame;\r\n        final Pattern layoutFramePattern = RegExp(r'^#[0-9]+ +RenderObject.layout \\(');\r\n        for (int i = 0; i < stack.length; i += 1) {\r\n          if (layoutFramePattern.matchAsPrefix(stack[i]) != null) {\r\n            targetFrame = i + 1;\r\n            break;\r\n          }\r\n        }\r\n        if (targetFrame != null && targetFrame < stack.length) {\r\n          final Pattern targetFramePattern = RegExp(r'^#[0-9]+ +(.+)$');\r\n          final Match? targetFrameMatch = targetFramePattern.matchAsPrefix(stack[targetFrame]);\r\n          final String? problemFunction = (targetFrameMatch != null && targetFrameMatch.groupCount > 0) ? targetFrameMatch.group(1) : stack[targetFrame].trim();\r\n          // TODO(jacobr): this case is similar to displaying a single stack frame.\r\n          yield ErrorDescription(\r\n            \"These invalid constraints were provided to $runtimeType's layout() \"\r\n            'function by the following function, which probably computed the '\r\n            'invalid constraints in question:\\n'\r\n            '  $problemFunction'\r\n          );\r\n        }\r\n      },\r\n    )");
      if (!!dart.test(this[_debugDoingThisResize])) dart.assertFailed(null, I[4], 1710, 12, "!_debugDoingThisResize");
      if (!!dart.test(this[_debugDoingThisLayout])) dart.assertFailed(null, I[4], 1711, 12, "!_debugDoingThisLayout");
      let relayoutBoundary = null;
      if (!dart.test(parentUsesSize) || dart.test(this.sizedByParent) || dart.test(constraints.isTight) || !object$.RenderObject.is(this.parent)) {
        relayoutBoundary = this;
      } else {
        relayoutBoundary = object$.RenderObject.as(dart.nullCheck(this.parent))[_relayoutBoundary];
      }
      if (!dart.test(dart.fn(() => {
        this[_debugCanParentUseSize] = parentUsesSize;
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 1718, 12, "() {\r\n      _debugCanParentUseSize = parentUsesSize;\r\n      return true;\r\n    }()");
      if (!dart.test(this[_needsLayout]) && dart.equals(constraints, this[_constraints]) && dart.equals(relayoutBoundary, this[_relayoutBoundary])) {
        if (!dart.test(dart.fn(() => {
          this[_debugDoingThisResize] = this.sizedByParent;
          this[_debugDoingThisLayout] = !dart.test(this.sizedByParent);
          let debugPreviousActiveLayout = object$.RenderObject._debugActiveLayout;
          object$.RenderObject._debugActiveLayout = this;
          this.debugResetSize();
          object$.RenderObject._debugActiveLayout = debugPreviousActiveLayout;
          this[_debugDoingThisLayout] = false;
          this[_debugDoingThisResize] = false;
          return true;
        }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 1723, 14, "() {\r\n        // in case parentUsesSize changed since the last invocation, set size\r\n        // to itself, so it has the right internal debug values.\r\n        _debugDoingThisResize = sizedByParent;\r\n        _debugDoingThisLayout = !sizedByParent;\r\n        final RenderObject? debugPreviousActiveLayout = _debugActiveLayout;\r\n        _debugActiveLayout = this;\r\n        debugResetSize();\r\n        _debugActiveLayout = debugPreviousActiveLayout;\r\n        _debugDoingThisLayout = false;\r\n        _debugDoingThisResize = false;\r\n        return true;\r\n      }()");
        if (!false && dart.test(debug$0.debugProfileLayoutsEnabled)) developer.Timeline.finishSync();
        return;
      }
      this[_constraints] = constraints;
      if (this[_relayoutBoundary] != null && !dart.equals(relayoutBoundary, this[_relayoutBoundary])) {
        this.visitChildren(C[13] || CT.C13);
      }
      this[_relayoutBoundary] = relayoutBoundary;
      if (!!dart.test(this[_debugMutationsLocked])) dart.assertFailed(null, I[4], 1749, 12, "!_debugMutationsLocked");
      if (!!dart.test(this[_doingThisLayoutWithCallback])) dart.assertFailed(null, I[4], 1750, 12, "!_doingThisLayoutWithCallback");
      if (!dart.test(dart.fn(() => {
        this[_debugMutationsLocked] = true;
        if (dart.test(debug$0.debugPrintLayouts)) print.debugPrint("Laying out (" + (dart.test(this.sizedByParent) ? "with separate resize" : "with resize allowed") + ") " + dart.str(this));
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 1751, 12, "() {\r\n      _debugMutationsLocked = true;\r\n      if (debugPrintLayouts)\r\n        debugPrint('Laying out (${sizedByParent ? \"with separate resize\" : \"with resize allowed\"}) $this');\r\n      return true;\r\n    }()");
      if (dart.test(this.sizedByParent)) {
        if (!dart.test(dart.fn(() => {
          this[_debugDoingThisResize] = true;
          return true;
        }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 1758, 14, "() {\r\n        _debugDoingThisResize = true;\r\n        return true;\r\n      }()");
        try {
          this.performResize();
          if (!dart.test(dart.fn(() => {
            this.debugAssertDoesMeetConstraints();
            return true;
          }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 1764, 16, "() {\r\n          debugAssertDoesMeetConstraints();\r\n          return true;\r\n        }()");
        } catch (e$) {
          let e = dart.getThrown(e$);
          let stack = dart.stackTrace(e$);
          if (core.Object.is(e)) {
            this[_debugReportException]("performResize", e, stack);
          } else
            throw e$;
        }
        if (!dart.test(dart.fn(() => {
          this[_debugDoingThisResize] = false;
          return true;
        }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 1771, 14, "() {\r\n        _debugDoingThisResize = false;\r\n        return true;\r\n      }()");
      }
      let debugPreviousActiveLayout = null;
      if (!dart.test(dart.fn(() => {
        this[_debugDoingThisLayout] = true;
        debugPreviousActiveLayout = object$.RenderObject._debugActiveLayout;
        object$.RenderObject._debugActiveLayout = this;
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 1777, 12, "() {\r\n      _debugDoingThisLayout = true;\r\n      debugPreviousActiveLayout = _debugActiveLayout;\r\n      _debugActiveLayout = this;\r\n      return true;\r\n    }()");
      try {
        this.performLayout();
        this.markNeedsSemanticsUpdate();
        if (!dart.test(dart.fn(() => {
          this.debugAssertDoesMeetConstraints();
          return true;
        }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 1786, 14, "() {\r\n        debugAssertDoesMeetConstraints();\r\n        return true;\r\n      }()");
      } catch (e$0) {
        let e = dart.getThrown(e$0);
        let stack = dart.stackTrace(e$0);
        if (core.Object.is(e)) {
          this[_debugReportException]("performLayout", e, stack);
        } else
          throw e$0;
      }
      if (!dart.test(dart.fn(() => {
        object$.RenderObject._debugActiveLayout = debugPreviousActiveLayout;
        this[_debugDoingThisLayout] = false;
        this[_debugMutationsLocked] = false;
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 1793, 12, "() {\r\n      _debugActiveLayout = debugPreviousActiveLayout;\r\n      _debugDoingThisLayout = false;\r\n      _debugMutationsLocked = false;\r\n      return true;\r\n    }()");
      this[_needsLayout] = false;
      this.markNeedsPaint();
      if (!false && dart.test(debug$0.debugProfileLayoutsEnabled)) developer.Timeline.finishSync();
    }
    debugResetSize() {
    }
    get sizedByParent() {
      return false;
    }
    invokeLayoutCallback(T, callback) {
      if (callback == null) dart.nullFailed(I[4], 1888, 70, "callback");
      if (!dart.test(this[_debugMutationsLocked])) dart.assertFailed(null, I[4], 1889, 12, "_debugMutationsLocked");
      if (!dart.test(this[_debugDoingThisLayout])) dart.assertFailed(null, I[4], 1890, 12, "_debugDoingThisLayout");
      if (!!dart.test(this[_doingThisLayoutWithCallback])) dart.assertFailed(null, I[4], 1891, 12, "!_doingThisLayoutWithCallback");
      this[_doingThisLayoutWithCallback] = true;
      try {
        dart.nullCheck(this.owner)[_enableMutationsToDirtySubtrees](dart.fn(() => {
          callback(T.as(this.constraints));
        }, T$.VoidTovoid()));
      } finally {
        this[_doingThisLayoutWithCallback] = false;
      }
    }
    rotate(opts) {
      let oldAngle = opts && 'oldAngle' in opts ? opts.oldAngle : null;
      let newAngle = opts && 'newAngle' in opts ? opts.newAngle : null;
      let time = opts && 'time' in opts ? opts.time : null;
    }
    get debugDoingThisPaint() {
      return this[_debugDoingThisPaint];
    }
    static get debugActivePaint() {
      return object$.RenderObject._debugActivePaint;
    }
    get isRepaintBoundary() {
      return false;
    }
    debugRegisterRepaintBoundaryPaint(opts) {
      let includedParent = opts && 'includedParent' in opts ? opts.includedParent : true;
      if (includedParent == null) dart.nullFailed(I[4], 1957, 49, "includedParent");
      let includedChild = opts && 'includedChild' in opts ? opts.includedChild : false;
      if (includedChild == null) dart.nullFailed(I[4], 1957, 77, "includedChild");
    }
    get alwaysNeedsCompositing() {
      return false;
    }
    get layer() {
      if (!(!dart.test(this.isRepaintBoundary) || this[_layer] == null || layer$.OffsetLayer.is(this[_layer]))) dart.assertFailed(null, I[4], 1989, 12, "!isRepaintBoundary || (_layer == null || _layer is OffsetLayer)");
      return this[_layer];
    }
    set layer(newLayer) {
      if (!!dart.test(this.isRepaintBoundary)) dart.assertFailed("Attempted to set a layer to a repaint boundary render object.\n" + "The framework creates and assigns an OffsetLayer to a repaint " + "boundary automatically.", I[4], 1996, 7, "!isRepaintBoundary");
      this[_layer] = newLayer;
    }
    get debugLayer() {
      let result = null;
      if (!dart.test(dart.fn(() => {
        result = this[_layer];
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 2014, 12, "() {\r\n      result = _layer;\r\n      return true;\r\n    }()");
      return result;
    }
    markNeedsCompositingBitsUpdate() {
      if (dart.test(this[_needsCompositingBitsUpdate])) return;
      this[_needsCompositingBitsUpdate] = true;
      if (object$.RenderObject.is(this.parent)) {
        let parent = object$.RenderObject.as(dart.nullCheck(this.parent));
        if (dart.test(parent[_needsCompositingBitsUpdate])) return;
        if (!dart.test(this.isRepaintBoundary) && !dart.test(parent.isRepaintBoundary)) {
          parent.markNeedsCompositingBitsUpdate();
          return;
        }
      }
      if (!dart.test(dart.fn(() => {
        let parent = this.parent;
        if (object$.RenderObject.is(parent)) return parent[_needsCompositing];
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 2051, 12, "() {\r\n      final AbstractNode? parent = this.parent;\r\n      if (parent is RenderObject)\r\n        return parent._needsCompositing;\r\n      return true;\r\n    }()");
      if (this.owner != null) dart.nullCheck(this.owner)[_nodesNeedingCompositingBitsUpdate][$add](this);
    }
    get [_needsCompositing]() {
      let t13;
      return dart.test(this[__RenderObject__needsCompositing_isSet]) ? (t13 = this[__RenderObject__needsCompositing], t13) : dart.throw(new _internal.LateError.fieldNI("_needsCompositing"));
    }
    set [_needsCompositing](t13) {
      if (t13 == null) dart.nullFailed(I[4], 2062, 13, "null");
      this[__RenderObject__needsCompositing_isSet] = true;
      this[__RenderObject__needsCompositing] = t13;
    }
    get needsCompositing() {
      if (!!dart.test(this[_needsCompositingBitsUpdate])) dart.assertFailed(null, I[4], 2071, 12, "!_needsCompositingBitsUpdate");
      return this[_needsCompositing];
    }
    [_updateCompositingBits]() {
      if (!dart.test(this[_needsCompositingBitsUpdate])) return;
      let oldNeedsCompositing = this[_needsCompositing];
      this[_needsCompositing] = false;
      this.visitChildren(dart.fn(child => {
        if (child == null) dart.nullFailed(I[4], 2080, 33, "child");
        child[_updateCompositingBits]();
        if (dart.test(child.needsCompositing)) this[_needsCompositing] = true;
      }, T$.RenderObjectTovoid()));
      if (dart.test(this.isRepaintBoundary) || dart.test(this.alwaysNeedsCompositing)) this[_needsCompositing] = true;
      if (oldNeedsCompositing != this[_needsCompositing]) this.markNeedsPaint();
      this[_needsCompositingBitsUpdate] = false;
    }
    get debugNeedsPaint() {
      let result = null;
      let result$35isSet = false;
      function result$35get() {
        return result$35isSet ? result : dart.throw(new _internal.LateError.localNI("result"));
      }
      dart.fn(result$35get, T$.VoidTobool());
      function result$35set(t17) {
        if (t17 == null) dart.nullFailed(I[4], 2107, 15, "null");
        result$35isSet = true;
        return result = t17;
      }
      dart.fn(result$35set, T$.boolTodynamic());
      if (!dart.test(dart.fn(() => {
        result$35set(this[_needsPaint]);
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 2108, 12, "() {\r\n      result = _needsPaint;\r\n      return true;\r\n    }()");
      return result$35get();
    }
    markNeedsPaint() {
      if (!(this.owner == null || !dart.test(dart.nullCheck(this.owner).debugDoingPaint))) dart.assertFailed(null, I[4], 2137, 12, "owner == null || !owner!.debugDoingPaint");
      if (dart.test(this[_needsPaint])) return;
      this[_needsPaint] = true;
      if (dart.test(this.isRepaintBoundary)) {
        if (!dart.test(dart.fn(() => {
          if (dart.test(debug$0.debugPrintMarkNeedsPaintStacks)) assertions.debugPrintStack({label: "markNeedsPaint() called for " + dart.str(this)});
          return true;
        }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 2142, 14, "() {\r\n        if (debugPrintMarkNeedsPaintStacks)\r\n          debugPrintStack(label: 'markNeedsPaint() called for $this');\r\n        return true;\r\n      }()");
        if (!layer$.OffsetLayer.is(this[_layer])) dart.assertFailed(null, I[4], 2149, 14, "_layer is OffsetLayer");
        if (this.owner != null) {
          dart.nullCheck(this.owner)[_nodesNeedingPaint][$add](this);
          dart.nullCheck(this.owner).requestVisualUpdate();
        }
      } else if (object$.RenderObject.is(this.parent)) {
        let parent = object$.RenderObject.as(dart.nullCheck(this.parent));
        parent.markNeedsPaint();
        if (!parent[$_equals](this.parent)) dart.assertFailed(null, I[4], 2157, 14, "parent == this.parent");
      } else {
        if (!dart.test(dart.fn(() => {
          if (dart.test(debug$0.debugPrintMarkNeedsPaintStacks)) assertions.debugPrintStack({label: "markNeedsPaint() called for " + dart.str(this) + " (root of render tree)"});
          return true;
        }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 2159, 14, "() {\r\n        if (debugPrintMarkNeedsPaintStacks)\r\n          debugPrintStack(label: 'markNeedsPaint() called for $this (root of render tree)');\r\n        return true;\r\n      }()");
        if (this.owner != null) dart.nullCheck(this.owner).requestVisualUpdate();
      }
    }
    [_skippedPaintingOnLayer]() {
      if (!dart.test(this.attached)) dart.assertFailed(null, I[4], 2179, 12, "attached");
      if (!dart.test(this.isRepaintBoundary)) dart.assertFailed(null, I[4], 2180, 12, "isRepaintBoundary");
      if (!dart.test(this[_needsPaint])) dart.assertFailed(null, I[4], 2181, 12, "_needsPaint");
      if (!(this[_layer] != null)) dart.assertFailed(null, I[4], 2182, 12, "_layer != null");
      if (!!dart.test(dart.nullCheck(this[_layer]).attached)) dart.assertFailed(null, I[4], 2183, 12, "!_layer!.attached");
      let node = this.parent;
      while (object$.RenderObject.is(node)) {
        if (dart.test(node.isRepaintBoundary)) {
          if (node[_layer] == null) break;
          if (dart.test(dart.nullCheck(node[_layer]).attached)) break;
          node[_needsPaint] = true;
        }
        node = node.parent;
      }
    }
    scheduleInitialPaint(rootLayer) {
      if (rootLayer == null) dart.nullFailed(I[4], 2203, 44, "rootLayer");
      if (!dart.test(rootLayer.attached)) dart.assertFailed(null, I[4], 2204, 12, "rootLayer.attached");
      if (!dart.test(this.attached)) dart.assertFailed(null, I[4], 2205, 12, "attached");
      if (!!object$.RenderObject.is(this.parent)) dart.assertFailed(null, I[4], 2206, 12, "parent is! RenderObject");
      if (!!dart.test(dart.nullCheck(this.owner)[_debugDoingPaint])) dart.assertFailed(null, I[4], 2207, 12, "!owner!._debugDoingPaint");
      if (!dart.test(this.isRepaintBoundary)) dart.assertFailed(null, I[4], 2208, 12, "isRepaintBoundary");
      if (!(this[_layer] == null)) dart.assertFailed(null, I[4], 2209, 12, "_layer == null");
      this[_layer] = rootLayer;
      if (!dart.test(this[_needsPaint])) dart.assertFailed(null, I[4], 2211, 12, "_needsPaint");
      dart.nullCheck(this.owner)[_nodesNeedingPaint][$add](this);
    }
    replaceRootLayer(rootLayer) {
      if (rootLayer == null) dart.nullFailed(I[4], 2220, 37, "rootLayer");
      if (!dart.test(rootLayer.attached)) dart.assertFailed(null, I[4], 2221, 12, "rootLayer.attached");
      if (!dart.test(this.attached)) dart.assertFailed(null, I[4], 2222, 12, "attached");
      if (!!object$.RenderObject.is(this.parent)) dart.assertFailed(null, I[4], 2223, 12, "parent is! RenderObject");
      if (!!dart.test(dart.nullCheck(this.owner)[_debugDoingPaint])) dart.assertFailed(null, I[4], 2224, 12, "!owner!._debugDoingPaint");
      if (!dart.test(this.isRepaintBoundary)) dart.assertFailed(null, I[4], 2225, 12, "isRepaintBoundary");
      if (!(this[_layer] != null)) dart.assertFailed(null, I[4], 2226, 12, "_layer != null");
      dart.nullCheck(this[_layer]).detach();
      this[_layer] = rootLayer;
      this.markNeedsPaint();
    }
    [_paintWithContext](context, offset) {
      if (context == null) dart.nullFailed(I[4], 2232, 42, "context");
      if (offset == null) dart.nullFailed(I[4], 2232, 58, "offset");
      if (!dart.test(dart.fn(() => {
        if (dart.test(this[_debugDoingThisPaint])) {
          dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("Tried to paint a RenderObject reentrantly."), this.describeForError("The following RenderObject was already being painted when it was " + "painted again"), new assertions.ErrorDescription.new("Since this typically indicates an infinite recursion, it is " + "disallowed.")])));
        }
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 2233, 12, "() {\r\n      if (_debugDoingThisPaint) {\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('Tried to paint a RenderObject reentrantly.'),\r\n          describeForError(\r\n            'The following RenderObject was already being painted when it was '\r\n            'painted again'\r\n          ),\r\n          ErrorDescription(\r\n            'Since this typically indicates an infinite recursion, it is '\r\n            'disallowed.'\r\n          ),\r\n        ]);\r\n      }\r\n      return true;\r\n    }()");
      if (dart.test(this[_needsLayout])) return;
      if (!dart.test(dart.fn(() => {
        if (dart.test(this[_needsCompositingBitsUpdate])) {
          if (object$.RenderObject.is(this.parent)) {
            let parent = object$.RenderObject.as(dart.nullCheck(this.parent));
            let visitedByParent = false;
            parent.visitChildren(dart.fn(child => {
              if (child == null) dart.nullFailed(I[4], 2263, 46, "child");
              if (dart.equals(child, this)) {
                visitedByParent = true;
              }
            }, T$.RenderObjectTovoid()));
            if (!visitedByParent) {
              dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("A RenderObject was not visited by the parent's visitChildren " + "during paint."), parent.describeForError("The parent was"), this.describeForError("The child that was not visited was"), new assertions.ErrorDescription.new("A RenderObject with children must implement visitChildren and " + "call the visitor exactly once for each child; it also should not " + "paint children that were removed with dropChild."), new assertions.ErrorHint.new("This usually indicates an error in the Flutter framework itself.")])));
            }
          }
          dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("Tried to paint a RenderObject before its compositing bits were " + "updated."), this.describeForError("The following RenderObject was marked as having dirty compositing " + "bits at the time that it was painted"), new assertions.ErrorDescription.new("A RenderObject that still has dirty compositing bits cannot be " + "painted because this indicates that the tree has not yet been " + "properly configured for creating the layer tree."), new assertions.ErrorHint.new("This usually indicates an error in the Flutter framework itself.")])));
        }
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 2258, 12, "() {\r\n      if (_needsCompositingBitsUpdate) {\r\n        if (parent is RenderObject) {\r\n          final RenderObject parent = this.parent! as RenderObject;\r\n          bool visitedByParent = false;\r\n          parent.visitChildren((RenderObject child) {\r\n            if (child == this) {\r\n              visitedByParent = true;\r\n            }\r\n          });\r\n          if (!visitedByParent) {\r\n            throw FlutterError.fromParts(<DiagnosticsNode>[\r\n              ErrorSummary(\r\n                \"A RenderObject was not visited by the parent's visitChildren \"\r\n                'during paint.',\r\n              ),\r\n              parent.describeForError(\r\n                'The parent was',\r\n              ),\r\n              describeForError(\r\n                'The child that was not visited was'\r\n              ),\r\n              ErrorDescription(\r\n                'A RenderObject with children must implement visitChildren and '\r\n                'call the visitor exactly once for each child; it also should not '\r\n                'paint children that were removed with dropChild.'\r\n              ),\r\n              ErrorHint(\r\n                'This usually indicates an error in the Flutter framework itself.'\r\n              ),\r\n            ]);\r\n          }\r\n        }\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary(\r\n            'Tried to paint a RenderObject before its compositing bits were '\r\n            'updated.'\r\n          ),\r\n          describeForError(\r\n            'The following RenderObject was marked as having dirty compositing '\r\n            'bits at the time that it was painted',\r\n          ),\r\n          ErrorDescription(\r\n            'A RenderObject that still has dirty compositing bits cannot be '\r\n            'painted because this indicates that the tree has not yet been '\r\n            'properly configured for creating the layer tree.'\r\n          ),\r\n          ErrorHint(\r\n            'This usually indicates an error in the Flutter framework itself.'\r\n          ),\r\n        ]);\r\n      }\r\n      return true;\r\n    }()");
      let debugLastActivePaint = null;
      if (!dart.test(dart.fn(() => {
        this[_debugDoingThisPaint] = true;
        debugLastActivePaint = object$.RenderObject._debugActivePaint;
        object$.RenderObject._debugActivePaint = this;
        if (!(!dart.test(this.isRepaintBoundary) || this[_layer] != null)) dart.assertFailed(null, I[4], 2317, 14, "!isRepaintBoundary || _layer != null");
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 2313, 12, "() {\r\n      _debugDoingThisPaint = true;\r\n      debugLastActivePaint = _debugActivePaint;\r\n      _debugActivePaint = this;\r\n      assert(!isRepaintBoundary || _layer != null);\r\n      return true;\r\n    }()");
      this[_needsPaint] = false;
      try {
        this.paint(context, offset);
        if (!!dart.test(this[_needsLayout])) dart.assertFailed(null, I[4], 2323, 14, "!_needsLayout");
        if (!!dart.test(this[_needsPaint])) dart.assertFailed(null, I[4], 2324, 14, "!_needsPaint");
      } catch (e$) {
        let e = dart.getThrown(e$);
        let stack = dart.stackTrace(e$);
        if (core.Object.is(e)) {
          this[_debugReportException]("paint", e, stack);
        } else
          throw e$;
      }
      if (!dart.test(dart.fn(() => {
        this.debugPaint(context, offset);
        object$.RenderObject._debugActivePaint = debugLastActivePaint;
        this[_debugDoingThisPaint] = false;
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 2328, 12, "() {\r\n      debugPaint(context, offset);\r\n      _debugActivePaint = debugLastActivePaint;\r\n      _debugDoingThisPaint = false;\r\n      return true;\r\n    }()");
    }
    debugPaint(context, offset) {
      if (context == null) dart.nullFailed(I[4], 2344, 35, "context");
      if (offset == null) dart.nullFailed(I[4], 2344, 51, "offset");
    }
    paint(context, offset) {
      if (context == null) dart.nullFailed(I[4], 2363, 30, "context");
      if (offset == null) dart.nullFailed(I[4], 2363, 46, "offset");
    }
    applyPaintTransform(child, transform) {
      object$.RenderObject.as(child);
      if (child == null) dart.nullFailed(I[4], 2370, 51, "child");
      if (transform == null) dart.nullFailed(I[4], 2370, 66, "transform");
      if (!dart.equals(child.parent, this)) dart.assertFailed(null, I[4], 2371, 12, "child.parent == this");
    }
    getTransformTo(ancestor) {
      let ancestorSpecified = ancestor != null;
      if (!dart.test(this.attached)) dart.assertFailed(null, I[4], 2388, 12, "attached");
      if (ancestor == null) {
        let rootNode = dart.nullCheck(this.owner).rootNode;
        if (object$.RenderObject.is(rootNode)) ancestor = rootNode;
      }
      let renderers = T$.JSArrayOfRenderObject().of([]);
      for (let renderer = this; !renderer[$_equals](ancestor); renderer = object$.RenderObject.as(dart.nullCheck(renderer.parent))) {
        if (!(renderer !== null)) dart.assertFailed(null, I[4], 2396, 14, "renderer != null");
        renderers[$add](renderer);
      }
      if (ancestorSpecified) renderers[$add](dart.nullCheck(ancestor));
      let transform = vector_math_64.Matrix4.identity();
      for (let index = dart.notNull(renderers[$length]) - 1; index > 0; index = index - 1) {
        renderers[$_get](index).applyPaintTransform(renderers[$_get](index - 1), transform);
      }
      return transform;
    }
    describeApproximatePaintClip(child) {
      object$.RenderObject.as(child);
      if (child == null) dart.nullFailed(I[4], 2417, 61, "child");
      return null;
    }
    describeSemanticsClip(child) {
      T$.RenderObjectN().as(child);
      return null;
    }
    scheduleInitialSemantics() {
      if (!dart.test(this.attached)) dart.assertFailed(null, I[4], 2456, 12, "attached");
      if (!!object$.RenderObject.is(this.parent)) dart.assertFailed(null, I[4], 2457, 12, "parent is! RenderObject");
      if (!!dart.test(dart.nullCheck(this.owner)[_debugDoingSemantics])) dart.assertFailed(null, I[4], 2458, 12, "!owner!._debugDoingSemantics");
      if (!(this[_semantics] == null)) dart.assertFailed(null, I[4], 2459, 12, "_semantics == null");
      if (!dart.test(this[_needsSemanticsUpdate])) dart.assertFailed(null, I[4], 2460, 12, "_needsSemanticsUpdate");
      if (!(dart.nullCheck(this.owner)[_semanticsOwner] != null)) dart.assertFailed(null, I[4], 2461, 12, "owner!._semanticsOwner != null");
      dart.nullCheck(this.owner)[_nodesNeedingSemantics].add(this);
      dart.nullCheck(this.owner).requestVisualUpdate();
    }
    describeSemanticsConfiguration(config) {
      if (config == null) dart.nullFailed(I[4], 2501, 62, "config");
    }
    sendSemanticsEvent(semanticsEvent) {
      if (semanticsEvent == null) dart.nullFailed(I[4], 2513, 42, "semanticsEvent");
      if (dart.nullCheck(this.owner).semanticsOwner == null) return;
      if (this[_semantics] != null && !dart.test(dart.nullCheck(this[_semantics]).isMergedIntoParent)) {
        dart.nullCheck(this[_semantics]).sendEvent(semanticsEvent);
      } else if (this.parent != null) {
        let renderParent = object$.RenderObject.as(dart.nullCheck(this.parent));
        renderParent.sendSemanticsEvent(semanticsEvent);
      }
    }
    get [_semanticsConfiguration]() {
      if (this[_cachedSemanticsConfiguration] == null) {
        this[_cachedSemanticsConfiguration] = new semantics.SemanticsConfiguration.new();
        this.describeSemanticsConfiguration(dart.nullCheck(this[_cachedSemanticsConfiguration]));
      }
      return dart.nullCheck(this[_cachedSemanticsConfiguration]);
    }
    get debugSemantics() {
      if (!false) {
        return this[_semantics];
      }
      return null;
    }
    clearSemantics() {
      this[_needsSemanticsUpdate] = true;
      this[_semantics] = null;
      this.visitChildren(dart.fn(child => {
        if (child == null) dart.nullFailed(I[4], 2567, 33, "child");
        child.clearSemantics();
      }, T$.RenderObjectTovoid()));
    }
    markNeedsSemanticsUpdate() {
      let t20;
      if (!(!dart.test(this.attached) || !dart.test(dart.nullCheck(this.owner)[_debugDoingSemantics]))) dart.assertFailed(null, I[4], 2578, 12, "!attached || !owner!._debugDoingSemantics");
      if (!dart.test(this.attached) || dart.nullCheck(this.owner)[_semanticsOwner] == null) {
        this[_cachedSemanticsConfiguration] = null;
        return;
      }
      let wasSemanticsBoundary = this[_semantics] != null && (t20 = this[_cachedSemanticsConfiguration], t20 == null ? null : t20.isSemanticBoundary) === true;
      this[_cachedSemanticsConfiguration] = null;
      let isEffectiveSemanticsBoundary = dart.test(this[_semanticsConfiguration].isSemanticBoundary) && wasSemanticsBoundary;
      let node = this;
      while (!dart.test(isEffectiveSemanticsBoundary) && object$.RenderObject.is(node.parent)) {
        if (!node[$_equals](this) && dart.test(node[_needsSemanticsUpdate])) break;
        node[_needsSemanticsUpdate] = true;
        node = object$.RenderObject.as(dart.nullCheck(node.parent));
        isEffectiveSemanticsBoundary = node[_semanticsConfiguration].isSemanticBoundary;
        if (dart.test(isEffectiveSemanticsBoundary) && node[_semantics] == null) {
          return;
        }
      }
      if (!node[$_equals](this) && this[_semantics] != null && dart.test(this[_needsSemanticsUpdate])) {
        dart.nullCheck(this.owner)[_nodesNeedingSemantics].remove(this);
      }
      if (!dart.test(node[_needsSemanticsUpdate])) {
        node[_needsSemanticsUpdate] = true;
        if (this.owner != null) {
          if (!(dart.test(node[_semanticsConfiguration].isSemanticBoundary) || !object$.RenderObject.is(node.parent))) dart.assertFailed(null, I[4], 2621, 16, "node._semanticsConfiguration.isSemanticBoundary || node.parent is! RenderObject");
          dart.nullCheck(this.owner)[_nodesNeedingSemantics].add(node);
          dart.nullCheck(this.owner).requestVisualUpdate();
        }
      }
    }
    [_updateSemantics]() {
      let t21, t20, t20$, t20$0, t20$1, t20$2, t20$3;
      if (!(dart.test(this[_semanticsConfiguration].isSemanticBoundary) || !object$.RenderObject.is(this.parent))) dart.assertFailed(null, I[4], 2630, 12, "_semanticsConfiguration.isSemanticBoundary || parent is! RenderObject");
      if (dart.test(this[_needsLayout])) {
        return;
      }
      let fragment = this[_getSemanticsForParent]({mergeIntoParent: (t20$ = (t20 = this[_semantics], t20 == null ? null : (t21 = t20.parent, t21 == null ? null : t21.isPartOfNodeMerging)), t20$ == null ? false : t20$)});
      if (!object$._InterestingSemanticsFragment.is(fragment)) dart.assertFailed(null, I[4], 2639, 12, "fragment is _InterestingSemanticsFragment");
      let interestingFragment = object$._InterestingSemanticsFragment.as(fragment);
      let result = T$.JSArrayOfSemanticsNode().of([]);
      interestingFragment.compileChildren({parentSemanticsClipRect: (t20$0 = this[_semantics], t20$0 == null ? null : t20$0.parentSemanticsClipRect), parentPaintClipRect: (t20$1 = this[_semantics], t20$1 == null ? null : t20$1.parentPaintClipRect), elevationAdjustment: (t20$3 = (t20$2 = this[_semantics], t20$2 == null ? null : t20$2.elevationAdjustment), t20$3 == null ? 0.0 : t20$3), result: result});
      let node = result[$single];
      if (!(interestingFragment.config == null && dart.equals(node, this[_semantics]))) dart.assertFailed(null, I[4], 2650, 12, "interestingFragment.config == null && node == _semantics");
    }
    [_getSemanticsForParent](opts) {
      let mergeIntoParent = opts && 'mergeIntoParent' in opts ? opts.mergeIntoParent : null;
      if (mergeIntoParent == null) dart.nullFailed(I[4], 2655, 19, "mergeIntoParent");
      if (!(mergeIntoParent != null)) dart.assertFailed(null, I[4], 2657, 12, "mergeIntoParent != null");
      if (!!dart.test(this[_needsLayout])) dart.assertFailed("Updated layout information required for " + dart.str(this) + " to calculate semantics.", I[4], 2658, 12, "!_needsLayout");
      let config = this[_semanticsConfiguration];
      let dropSemanticsOfPreviousSiblings = config.isBlockingSemanticsOfPreviouslyPaintedNodes;
      let producesForkingFragment = !dart.test(config.hasBeenAnnotated) && !dart.test(config.isSemanticBoundary);
      let fragments = T$.JSArrayOf_InterestingSemanticsFragment().of([]);
      let toBeMarkedExplicit = T$.LinkedHashSetOf_InterestingSemanticsFragment().new();
      let childrenMergeIntoParent = dart.test(mergeIntoParent) || dart.test(config.isMergingSemanticsOfDescendants);
      let abortWalk = false;
      this.visitChildrenForSemantics(dart.fn(renderChild => {
        if (renderChild == null) dart.nullFailed(I[4], 2675, 45, "renderChild");
        if (abortWalk || dart.test(this[_needsLayout])) {
          abortWalk = true;
          return;
        }
        let parentFragment = renderChild[_getSemanticsForParent]({mergeIntoParent: childrenMergeIntoParent});
        if (dart.test(parentFragment.abortsWalk)) {
          abortWalk = true;
          return;
        }
        if (dart.test(parentFragment.dropsSemanticsOfPreviousSiblings)) {
          fragments[$clear]();
          toBeMarkedExplicit.clear();
          if (!dart.test(config.isSemanticBoundary)) dropSemanticsOfPreviousSiblings = true;
        }
        for (let fragment of parentFragment.interestingFragments) {
          fragments[$add](fragment);
          fragment.addAncestor(this);
          fragment.addTags(config.tagsForChildren);
          if (dart.test(config.explicitChildNodes) || !object$.RenderObject.is(this.parent)) {
            fragment.markAsExplicit();
            continue;
          }
          if (!dart.test(fragment.hasConfigForParent) || producesForkingFragment) continue;
          if (!dart.test(config.isCompatibleWith(fragment.config))) toBeMarkedExplicit.add(fragment);
          let siblingLength = dart.notNull(fragments[$length]) - 1;
          for (let i = 0; i < siblingLength; i = i + 1) {
            let siblingFragment = fragments[$_get](i);
            if (!dart.test(dart.nullCheck(fragment.config).isCompatibleWith(siblingFragment.config))) {
              toBeMarkedExplicit.add(fragment);
              toBeMarkedExplicit.add(siblingFragment);
            }
          }
        }
      }, T$.RenderObjectTovoid()));
      if (abortWalk) {
        return new object$._AbortingSemanticsFragment.new({owner: this});
      }
      for (let fragment of toBeMarkedExplicit)
        fragment.markAsExplicit();
      this[_needsSemanticsUpdate] = false;
      let result = null;
      if (!object$.RenderObject.is(this.parent)) {
        if (!!dart.test(config.hasBeenAnnotated)) dart.assertFailed(null, I[4], 2728, 14, "!config.hasBeenAnnotated");
        if (!!dart.test(mergeIntoParent)) dart.assertFailed(null, I[4], 2729, 14, "!mergeIntoParent");
        result = new object$._RootSemanticsFragment.new({owner: this, dropsSemanticsOfPreviousSiblings: dropSemanticsOfPreviousSiblings});
      } else if (producesForkingFragment) {
        result = new object$._ContainerSemanticsFragment.new({dropsSemanticsOfPreviousSiblings: dropSemanticsOfPreviousSiblings});
      } else {
        result = new object$._SwitchableSemanticsFragment.new({config: config, mergeIntoParent: mergeIntoParent, owner: this, dropsSemanticsOfPreviousSiblings: dropSemanticsOfPreviousSiblings});
        if (dart.test(config.isSemanticBoundary)) {
          let fragment = object$._SwitchableSemanticsFragment.as(result);
          fragment.markAsExplicit();
        }
      }
      result.addAll(fragments);
      return result;
    }
    visitChildrenForSemantics(visitor) {
      if (visitor == null) dart.nullFailed(I[4], 2764, 54, "visitor");
      this.visitChildren(visitor);
    }
    assembleSemanticsNode(node, config, children) {
      if (node == null) dart.nullFailed(I[4], 2783, 19, "node");
      if (config == null) dart.nullFailed(I[4], 2784, 28, "config");
      if (children == null) dart.nullFailed(I[4], 2785, 29, "children");
      if (!dart.equals(node, this[_semantics])) dart.assertFailed(null, I[4], 2787, 12, "node == _semantics");
      node.updateWith({config: config, childrenInInversePaintOrder: T$.ListOfSemanticsNode().as(children)});
    }
    handleEvent(event, entry) {
      if (event == null) dart.nullFailed(I[4], 2796, 33, "event");
      hit_test.HitTestEntry.as(entry);
      if (entry == null) dart.nullFailed(I[4], 2796, 63, "entry");
    }
    toStringShort() {
      let header = diagnostics.describeIdentity(this);
      if (this[_relayoutBoundary] != null && !dart.equals(this[_relayoutBoundary], this)) {
        let count = 1;
        let target = T$.RenderObjectN().as(this.parent);
        while (target != null && !dart.equals(target, this[_relayoutBoundary])) {
          target = T$.RenderObjectN().as(target.parent);
          count = count + 1;
        }
        header = dart.notNull(header) + (" relayoutBoundary=up" + dart.str(count));
      }
      if (dart.test(this[_needsLayout])) header = dart.notNull(header) + " NEEDS-LAYOUT";
      if (dart.test(this[_needsPaint])) header = dart.notNull(header) + " NEEDS-PAINT";
      if (dart.test(this[_needsCompositingBitsUpdate])) header = dart.notNull(header) + " NEEDS-COMPOSITING-BITS-UPDATE";
      if (!dart.test(this.attached)) header = dart.notNull(header) + " DETACHED";
      return header;
    }
    toString(opts) {
      let minLevel = opts && 'minLevel' in opts ? opts.minLevel : C[14] || CT.C14;
      if (minLevel == null) dart.nullFailed(I[4], 2844, 37, "minLevel");
      return this.toStringShort();
    }
    toStringDeep(opts) {
      let prefixLineOne = opts && 'prefixLineOne' in opts ? opts.prefixLineOne : "";
      if (prefixLineOne == null) dart.nullFailed(I[4], 2851, 12, "prefixLineOne");
      let prefixOtherLines = opts && 'prefixOtherLines' in opts ? opts.prefixOtherLines : "";
      let minLevel = opts && 'minLevel' in opts ? opts.minLevel : C[15] || CT.C15;
      if (minLevel == null) dart.nullFailed(I[4], 2853, 21, "minLevel");
      let debugPreviousActiveLayout = null;
      if (!dart.test(dart.fn(() => {
        debugPreviousActiveLayout = object$.RenderObject._debugActiveLayout;
        object$.RenderObject._debugActiveLayout = null;
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 2856, 12, "() {\r\n      debugPreviousActiveLayout = _debugActiveLayout;\r\n      _debugActiveLayout = null;\r\n      return true;\r\n    }()");
      let result = super.toStringDeep({prefixLineOne: prefixLineOne, prefixOtherLines: prefixOtherLines, minLevel: minLevel});
      if (!dart.test(dart.fn(() => {
        object$.RenderObject._debugActiveLayout = debugPreviousActiveLayout;
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 2866, 12, "() {\r\n      _debugActiveLayout = debugPreviousActiveLayout;\r\n      return true;\r\n    }()");
      return result;
    }
    toStringShallow(opts) {
      let joiner = opts && 'joiner' in opts ? opts.joiner : ", ";
      if (joiner == null) dart.nullFailed(I[4], 2880, 12, "joiner");
      let minLevel = opts && 'minLevel' in opts ? opts.minLevel : C[15] || CT.C15;
      if (minLevel == null) dart.nullFailed(I[4], 2881, 21, "minLevel");
      let debugPreviousActiveLayout = null;
      if (!dart.test(dart.fn(() => {
        debugPreviousActiveLayout = object$.RenderObject._debugActiveLayout;
        object$.RenderObject._debugActiveLayout = null;
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 2884, 12, "() {\r\n      debugPreviousActiveLayout = _debugActiveLayout;\r\n      _debugActiveLayout = null;\r\n      return true;\r\n    }()");
      let result = super.toStringShallow({joiner: joiner, minLevel: minLevel});
      if (!dart.test(dart.fn(() => {
        object$.RenderObject._debugActiveLayout = debugPreviousActiveLayout;
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 2890, 12, "() {\r\n      _debugActiveLayout = debugPreviousActiveLayout;\r\n      return true;\r\n    }()");
      return result;
    }
    debugFillProperties(properties) {
      if (properties == null) dart.nullFailed(I[4], 2899, 56, "properties");
      super.debugFillProperties(properties);
      properties.add(new diagnostics.FlagProperty.new("needsCompositing", {value: this[_needsCompositing], ifTrue: "needs compositing"}));
      properties.add(new (T$.DiagnosticsPropertyOfObjectN()).new("creator", this.debugCreator, {defaultValue: null, level: diagnostics.DiagnosticLevel.debug}));
      properties.add(new (T$.DiagnosticsPropertyOfParentData()).new("parentData", this.parentData, {tooltip: this[_debugCanParentUseSize] === true ? "can use size" : null, missingIfNull: true}));
      properties.add(new (T$.DiagnosticsPropertyOfConstraints()).new("constraints", this[_constraints], {missingIfNull: true}));
      properties.add(new (T$.DiagnosticsPropertyOfContainerLayer()).new("layer", this[_layer], {defaultValue: null}));
      properties.add(new (T$.DiagnosticsPropertyOfSemanticsNode()).new("semantics node", this[_semantics], {defaultValue: null}));
      properties.add(new diagnostics.FlagProperty.new("isBlockingSemanticsOfPreviouslyPaintedNodes", {value: this[_semanticsConfiguration].isBlockingSemanticsOfPreviouslyPaintedNodes, ifTrue: "blocks semantics of earlier render objects below the common boundary"}));
      properties.add(new diagnostics.FlagProperty.new("isSemanticBoundary", {value: this[_semanticsConfiguration].isSemanticBoundary, ifTrue: "semantic boundary"}));
    }
    debugDescribeChildren() {
      return T$.JSArrayOfDiagnosticsNode().of([]);
    }
    showOnScreen(opts) {
      let t20;
      let descendant = opts && 'descendant' in opts ? opts.descendant : null;
      let rect = opts && 'rect' in opts ? opts.rect : null;
      let duration = opts && 'duration' in opts ? opts.duration : C[16] || CT.C16;
      if (duration == null) dart.nullFailed(I[4], 2942, 14, "duration");
      let curve = opts && 'curve' in opts ? opts.curve : C[17] || CT.C17;
      if (curve == null) dart.nullFailed(I[4], 2943, 11, "curve");
      if (object$.RenderObject.is(this.parent)) {
        let renderParent = object$.RenderObject.as(dart.nullCheck(this.parent));
        renderParent.showOnScreen({descendant: (t20 = descendant, t20 == null ? this : t20), rect: rect, duration: duration, curve: curve});
      }
    }
    describeForError(name, opts) {
      if (name == null) dart.nullFailed(I[4], 2965, 43, "name");
      let style = opts && 'style' in opts ? opts.style : C[18] || CT.C18;
      if (style == null) dart.nullFailed(I[4], 2965, 72, "style");
      return this.toDiagnosticsNode({name: name, style: style});
    }
  };
  (object$.RenderObject.new = function() {
    this[parentData] = null;
    this[debugCreator$] = null;
    this[_debugDoingThisResize] = false;
    this[_debugDoingThisLayout] = false;
    this[_debugCanParentUseSize] = null;
    this[_debugMutationsLocked] = false;
    this[_needsLayout] = true;
    this[_relayoutBoundary] = null;
    this[_doingThisLayoutWithCallback] = false;
    this[_constraints] = null;
    this[_debugDoingThisPaint] = false;
    this[_layer] = null;
    this[_needsCompositingBitsUpdate] = false;
    this[__RenderObject__needsCompositing] = null;
    this[__RenderObject__needsCompositing_isSet] = false;
    this[_needsPaint] = true;
    this[_cachedSemanticsConfiguration] = null;
    this[_needsSemanticsUpdate] = true;
    this[_semantics] = null;
    object$.RenderObject.__proto__.new.call(this);
    this[_needsCompositing] = dart.test(this.isRepaintBoundary) || dart.test(this.alwaysNeedsCompositing);
  }).prototype = object$.RenderObject.prototype;
  dart.addTypeTests(object$.RenderObject);
  dart.addTypeCaches(object$.RenderObject);
  object$.RenderObject[dart.implements] = () => [hit_test.HitTestTarget];
  dart.setMethodSignature(object$.RenderObject, () => ({
    __proto__: dart.getMethods(object$.RenderObject.__proto__),
    reassemble: dart.fnType(dart.void, []),
    setupParentData: dart.fnType(dart.void, [dart.nullable(core.Object)]),
    visitChildren: dart.fnType(dart.void, [dart.fnType(dart.void, [object$.RenderObject])]),
    [_debugReportException]: dart.fnType(dart.void, [core.String, core.Object, core.StackTrace]),
    [_debugSubtreeRelayoutRootAlreadyMarkedNeedsLayout]: dart.fnType(core.bool, []),
    markNeedsLayout: dart.fnType(dart.void, []),
    markParentNeedsLayout: dart.fnType(dart.void, []),
    markNeedsLayoutForSizedByParentChange: dart.fnType(dart.void, []),
    [_cleanRelayoutBoundary]: dart.fnType(dart.void, []),
    scheduleInitialLayout: dart.fnType(dart.void, []),
    [_layoutWithoutResize]: dart.fnType(dart.void, []),
    layout: dart.fnType(dart.void, [object$.Constraints], {parentUsesSize: core.bool}, {}),
    debugResetSize: dart.fnType(dart.void, []),
    invokeLayoutCallback: dart.gFnType(T => [dart.void, [dart.fnType(dart.void, [T])]], T => [object$.Constraints]),
    rotate: dart.fnType(dart.void, [], {newAngle: dart.nullable(core.int), oldAngle: dart.nullable(core.int), time: dart.nullable(core.Duration)}, {}),
    debugRegisterRepaintBoundaryPaint: dart.fnType(dart.void, [], {includedChild: core.bool, includedParent: core.bool}, {}),
    markNeedsCompositingBitsUpdate: dart.fnType(dart.void, []),
    [_updateCompositingBits]: dart.fnType(dart.void, []),
    markNeedsPaint: dart.fnType(dart.void, []),
    [_skippedPaintingOnLayer]: dart.fnType(dart.void, []),
    scheduleInitialPaint: dart.fnType(dart.void, [layer$.ContainerLayer]),
    replaceRootLayer: dart.fnType(dart.void, [layer$.OffsetLayer]),
    [_paintWithContext]: dart.fnType(dart.void, [object$.PaintingContext, ui.Offset]),
    debugPaint: dart.fnType(dart.void, [object$.PaintingContext, ui.Offset]),
    paint: dart.fnType(dart.void, [object$.PaintingContext, ui.Offset]),
    applyPaintTransform: dart.fnType(dart.void, [dart.nullable(core.Object), vector_math_64.Matrix4]),
    getTransformTo: dart.fnType(vector_math_64.Matrix4, [dart.nullable(object$.RenderObject)]),
    describeApproximatePaintClip: dart.fnType(dart.nullable(ui.Rect), [dart.nullable(core.Object)]),
    describeSemanticsClip: dart.fnType(dart.nullable(ui.Rect), [dart.nullable(core.Object)]),
    scheduleInitialSemantics: dart.fnType(dart.void, []),
    describeSemanticsConfiguration: dart.fnType(dart.void, [semantics.SemanticsConfiguration]),
    sendSemanticsEvent: dart.fnType(dart.void, [semantics_event.SemanticsEvent]),
    clearSemantics: dart.fnType(dart.void, []),
    markNeedsSemanticsUpdate: dart.fnType(dart.void, []),
    [_updateSemantics]: dart.fnType(dart.void, []),
    [_getSemanticsForParent]: dart.fnType(object$._SemanticsFragment, [], {}, {mergeIntoParent: core.bool}),
    visitChildrenForSemantics: dart.fnType(dart.void, [dart.fnType(dart.void, [object$.RenderObject])]),
    assembleSemanticsNode: dart.fnType(dart.void, [semantics.SemanticsNode, semantics.SemanticsConfiguration, core.Iterable$(semantics.SemanticsNode)]),
    handleEvent: dart.fnType(dart.void, [events.PointerEvent, dart.nullable(core.Object)]),
    showOnScreen: dart.fnType(dart.void, [], {curve: curves.Curve, descendant: dart.nullable(object$.RenderObject), duration: core.Duration, rect: dart.nullable(ui.Rect)}, {}),
    describeForError: dart.fnType(diagnostics.DiagnosticsNode, [core.String], {style: diagnostics.DiagnosticsTreeStyle}, {})
  }));
  dart.setGetterSignature(object$.RenderObject, () => ({
    __proto__: dart.getGetters(object$.RenderObject.__proto__),
    debugDoingThisResize: core.bool,
    debugDoingThisLayout: core.bool,
    debugCanParentUseSize: core.bool,
    [_debugCanPerformMutations]: core.bool,
    owner: dart.nullable(object$.PipelineOwner),
    debugNeedsLayout: core.bool,
    debugDoingThisLayoutWithCallback: core.bool,
    constraints: object$.Constraints,
    sizedByParent: core.bool,
    debugDoingThisPaint: core.bool,
    isRepaintBoundary: core.bool,
    alwaysNeedsCompositing: core.bool,
    layer: dart.nullable(layer$.ContainerLayer),
    debugLayer: dart.nullable(layer$.ContainerLayer),
    [_needsCompositing]: core.bool,
    needsCompositing: core.bool,
    debugNeedsPaint: core.bool,
    [_semanticsConfiguration]: semantics.SemanticsConfiguration,
    debugSemantics: dart.nullable(semantics.SemanticsNode)
  }));
  dart.setSetterSignature(object$.RenderObject, () => ({
    __proto__: dart.getSetters(object$.RenderObject.__proto__),
    layer: dart.nullable(layer$.ContainerLayer),
    [_needsCompositing]: core.bool
  }));
  dart.setLibraryUri(object$.RenderObject, I[5]);
  dart.setFieldSignature(object$.RenderObject, () => ({
    __proto__: dart.getFields(object$.RenderObject.__proto__),
    parentData: dart.fieldType(dart.nullable(object$.ParentData)),
    debugCreator: dart.fieldType(dart.nullable(core.Object)),
    [_debugDoingThisResize]: dart.fieldType(core.bool),
    [_debugDoingThisLayout]: dart.fieldType(core.bool),
    [_debugCanParentUseSize]: dart.fieldType(dart.nullable(core.bool)),
    [_debugMutationsLocked]: dart.fieldType(core.bool),
    [_needsLayout]: dart.fieldType(core.bool),
    [_relayoutBoundary]: dart.fieldType(dart.nullable(object$.RenderObject)),
    [_doingThisLayoutWithCallback]: dart.fieldType(core.bool),
    [_constraints]: dart.fieldType(dart.nullable(object$.Constraints)),
    [_debugDoingThisPaint]: dart.fieldType(core.bool),
    [_layer]: dart.fieldType(dart.nullable(layer$.ContainerLayer)),
    [_needsCompositingBitsUpdate]: dart.fieldType(core.bool),
    [__RenderObject__needsCompositing]: dart.fieldType(dart.nullable(core.bool)),
    [__RenderObject__needsCompositing_isSet]: dart.fieldType(core.bool),
    [_needsPaint]: dart.fieldType(core.bool),
    [_cachedSemanticsConfiguration]: dart.fieldType(dart.nullable(semantics.SemanticsConfiguration)),
    [_needsSemanticsUpdate]: dart.fieldType(core.bool),
    [_semantics]: dart.fieldType(dart.nullable(semantics.SemanticsNode))
  }));
  dart.defineExtensionMethods(object$.RenderObject, ['toString']);
  dart.defineLazy(object$.RenderObject, {
    /*object$.RenderObject._debugActiveLayout*/get _debugActiveLayout() {
      return null;
    },
    set _debugActiveLayout(_) {},
    /*object$.RenderObject.debugCheckingIntrinsics*/get debugCheckingIntrinsics() {
      return false;
    },
    set debugCheckingIntrinsics(_) {},
    /*object$.RenderObject._debugActivePaint*/get _debugActivePaint() {
      return null;
    },
    set _debugActivePaint(_) {}
  }, false);
  var _child = dart.privateName(object$, "_child");
  const _is_RenderObjectWithChildMixin_default = Symbol('_is_RenderObjectWithChildMixin_default');
  object$.RenderObjectWithChildMixin$ = dart.generic(ChildType => {
    var ChildTypeN = () => (ChildTypeN = dart.constFn(dart.nullable(ChildType)))();
    class RenderObjectWithChildMixin extends object$.RenderObject {}
    RenderObjectWithChildMixin[dart.mixinOn] = RenderObject => class RenderObjectWithChildMixin extends RenderObject {
      debugValidateChild(child) {
        if (child == null) dart.nullFailed(I[4], 2985, 40, "child");
        if (!dart.test(dart.fn(() => {
          if (!ChildType.is(child)) {
            dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("A " + dart.str(this[$runtimeType]) + " expected a child of type " + dart.str(dart.wrapType(ChildType)) + " but received a " + "child of type " + dart.str(dart.runtimeType(child)) + "."), new assertions.ErrorDescription.new("RenderObjects expect specific types of children because they " + "coordinate with their children during layout and paint. For " + "example, a RenderSliver cannot be the child of a RenderBox because " + "a RenderSliver does not understand the RenderBox layout protocol."), new assertions.ErrorSpacer.new(), new (T$.DiagnosticsPropertyOfObjectN()).new("The " + dart.str(this[$runtimeType]) + " that expected a " + dart.str(dart.wrapType(ChildType)) + " child was created by", this.debugCreator, {style: diagnostics.DiagnosticsTreeStyle.errorProperty}), new assertions.ErrorSpacer.new(), new (T$.DiagnosticsPropertyOfObjectN()).new("The " + dart.str(dart.runtimeType(child)) + " that did not match the expected child type " + "was created by", child.debugCreator, {style: diagnostics.DiagnosticsTreeStyle.errorProperty})])));
          }
          return true;
        }, T$.VoidTobool())())) dart.assertFailed(null, I[4], 2986, 12, "() {\r\n      if (child is! ChildType) {\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary(\r\n            'A $runtimeType expected a child of type $ChildType but received a '\r\n            'child of type ${child.runtimeType}.'\r\n          ),\r\n          ErrorDescription(\r\n            'RenderObjects expect specific types of children because they '\r\n            'coordinate with their children during layout and paint. For '\r\n            'example, a RenderSliver cannot be the child of a RenderBox because '\r\n            'a RenderSliver does not understand the RenderBox layout protocol.',\r\n          ),\r\n          ErrorSpacer(),\r\n          DiagnosticsProperty<Object?>(\r\n            'The $runtimeType that expected a $ChildType child was created by',\r\n            debugCreator,\r\n            style: DiagnosticsTreeStyle.errorProperty,\r\n          ),\r\n          ErrorSpacer(),\r\n          DiagnosticsProperty<Object?>(\r\n            'The ${child.runtimeType} that did not match the expected child type '\r\n            'was created by',\r\n            child.debugCreator,\r\n            style: DiagnosticsTreeStyle.errorProperty,\r\n          ),\r\n        ]);\r\n      }\r\n      return true;\r\n    }()");
        return true;
      }
      get child() {
        return this[_child];
      }
      set child(value) {
        ChildTypeN().as(value);
        if (this[_child] != null) this.dropChild(dart.nullCheck(this[_child]));
        this[_child] = value;
        if (this[_child] != null) this.adoptChild(dart.nullCheck(this[_child]));
      }
      attach(owner) {
        object$.PipelineOwner.as(owner);
        if (owner == null) dart.nullFailed(I[4], 3031, 29, "owner");
        super.attach(owner);
        if (this[_child] != null) dart.nullCheck(this[_child]).attach(owner);
      }
      detach() {
        super.detach();
        if (this[_child] != null) dart.nullCheck(this[_child]).detach();
      }
      redepthChildren() {
        if (this[_child] != null) this.redepthChild(dart.nullCheck(this[_child]));
      }
      visitChildren(visitor) {
        if (visitor == null) dart.nullFailed(I[4], 3051, 42, "visitor");
        if (this[_child] != null) visitor(dart.nullCheck(this[_child]));
      }
      debugDescribeChildren() {
        return this.child != null ? T$.JSArrayOfDiagnosticsNode().of([dart.nullCheck(this.child).toDiagnosticsNode({name: "child"})]) : T$.JSArrayOfDiagnosticsNode().of([]);
      }
    };
    (RenderObjectWithChildMixin[dart.mixinNew] = function() {
      this[_child] = null;
    }).prototype = RenderObjectWithChildMixin.prototype;
    dart.addTypeTests(RenderObjectWithChildMixin);
    RenderObjectWithChildMixin.prototype[_is_RenderObjectWithChildMixin_default] = true;
    dart.addTypeCaches(RenderObjectWithChildMixin);
    RenderObjectWithChildMixin[dart.implements] = () => [object$.RenderObject];
    dart.setMethodSignature(RenderObjectWithChildMixin, () => ({
      __proto__: dart.getMethods(RenderObjectWithChildMixin.__proto__),
      debugValidateChild: dart.fnType(core.bool, [object$.RenderObject])
    }));
    dart.setGetterSignature(RenderObjectWithChildMixin, () => ({
      __proto__: dart.getGetters(RenderObjectWithChildMixin.__proto__),
      child: dart.nullable(ChildType)
    }));
    dart.setSetterSignature(RenderObjectWithChildMixin, () => ({
      __proto__: dart.getSetters(RenderObjectWithChildMixin.__proto__),
      child: dart.nullable(core.Object)
    }));
    dart.setLibraryUri(RenderObjectWithChildMixin, I[5]);
    dart.setFieldSignature(RenderObjectWithChildMixin, () => ({
      __proto__: dart.getFields(RenderObjectWithChildMixin.__proto__),
      [_child]: dart.fieldType(dart.nullable(ChildType))
    }));
    return RenderObjectWithChildMixin;
  });
  object$.RenderObjectWithChildMixin = object$.RenderObjectWithChildMixin$();
  dart.addTypeTests(object$.RenderObjectWithChildMixin, _is_RenderObjectWithChildMixin_default);
  var _cachedIntrinsicDimensions = dart.privateName(box, "_cachedIntrinsicDimensions");
  var _cachedDryLayoutSizes = dart.privateName(box, "_cachedDryLayoutSizes");
  var _computingThisDryLayout = dart.privateName(box, "_computingThisDryLayout");
  var _size$ = dart.privateName(box, "_size");
  var _cachedBaselines = dart.privateName(box, "_cachedBaselines");
  var _debugActivePointers = dart.privateName(box, "_debugActivePointers");
  var _computeIntrinsicDimension = dart.privateName(box, "_computeIntrinsicDimension");
  var _computeDryLayout = dart.privateName(box, "_computeDryLayout");
  var _owner$ = dart.privateName(box, "_owner");
  var _canBeUsedByParent$ = dart.privateName(box, "_canBeUsedByParent");
  box.RenderBox = class RenderBox extends object$.RenderObject {
    setupParentData(child) {
      object$.RenderObject.as(child);
      if (child == null) dart.nullFailed(I[6], 1356, 47, "child");
      if (!box.BoxParentData.is(child.parentData)) child.parentData = new box.BoxParentData.new();
    }
    [_computeIntrinsicDimension](dimension, argument, computer) {
      if (dimension == null) dart.nullFailed(I[6], 1363, 57, "dimension");
      if (argument == null) dart.nullFailed(I[6], 1363, 75, "argument");
      if (computer == null) dart.nullFailed(I[6], 1363, 92, "computer");
      if (!(dart.test(object$.RenderObject.debugCheckingIntrinsics) || !dart.test(this.debugDoingThisResize))) dart.assertFailed(null, I[6], 1364, 12, "RenderObject.debugCheckingIntrinsics || !debugDoingThisResize");
      let shouldCache = true;
      if (!dart.test(dart.fn(() => {
        if (dart.test(object$.RenderObject.debugCheckingIntrinsics)) shouldCache = false;
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 1366, 12, "() {\r\n      // we don't want the checked-mode intrinsic tests to affect\r\n      // who gets marked dirty, etc.\r\n      if (RenderObject.debugCheckingIntrinsics)\r\n        shouldCache = false;\r\n      return true;\r\n    }()");
      if (shouldCache) {
        this[_cachedIntrinsicDimensions] == null ? this[_cachedIntrinsicDimensions] = new (T$.LinkedMapOf_IntrinsicDimensionsCacheEntry$double()).new() : null;
        return dart.nullCheck(this[_cachedIntrinsicDimensions])[$putIfAbsent](new box._IntrinsicDimensionsCacheEntry.new(dimension, argument), dart.fn(() => computer(argument), T$.VoidTodouble()));
      }
      return computer(argument);
    }
    getMinIntrinsicWidth(height) {
      if (height == null) dart.nullFailed(I[6], 1399, 38, "height");
      if (!dart.test(dart.fn(() => {
        if (height == null) {
          dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("The height argument to getMinIntrinsicWidth was null."), new assertions.ErrorDescription.new("The argument to getMinIntrinsicWidth must not be negative or null."), new assertions.ErrorHint.new("If you do not have a specific height in mind, then pass double.infinity instead.")])));
        }
        if (dart.notNull(height) < 0.0) {
          dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("The height argument to getMinIntrinsicWidth was negative."), new assertions.ErrorDescription.new("The argument to getMinIntrinsicWidth must not be negative or null."), new assertions.ErrorHint.new("If you perform computations on another height before passing it to " + "getMinIntrinsicWidth, consider using math.max() or double.clamp() " + "to force the value into the valid range.")])));
        }
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 1400, 12, "() {\r\n      // `height` has a non-nullable return type, but might be null when\r\n      // running with weak checking, so we need to null check it anyway (and\r\n      // ignore the warning that the null-handling logic is dead code).\r\n      if (height == null) { // ignore: dead_code\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('The height argument to getMinIntrinsicWidth was null.'),\r\n          ErrorDescription('The argument to getMinIntrinsicWidth must not be negative or null.'),\r\n          ErrorHint('If you do not have a specific height in mind, then pass double.infinity instead.'),\r\n        ]);\r\n      }\r\n      if (height < 0.0) {\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('The height argument to getMinIntrinsicWidth was negative.'),\r\n          ErrorDescription('The argument to getMinIntrinsicWidth must not be negative or null.'),\r\n          ErrorHint(\r\n            'If you perform computations on another height before passing it to '\r\n            'getMinIntrinsicWidth, consider using math.max() or double.clamp() '\r\n            'to force the value into the valid range.'\r\n          ),\r\n        ]);\r\n      }\r\n      return true;\r\n    }()");
      return this[_computeIntrinsicDimension](box._IntrinsicDimension.minWidth, height, dart.bind(this, 'computeMinIntrinsicWidth'));
    }
    computeMinIntrinsicWidth(height) {
      if (height == null) dart.nullFailed(I[6], 1529, 42, "height");
      return 0.0;
    }
    getMaxIntrinsicWidth(height) {
      if (height == null) dart.nullFailed(I[6], 1551, 38, "height");
      if (!dart.test(dart.fn(() => {
        if (height == null) {
          dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("The height argument to getMaxIntrinsicWidth was null."), new assertions.ErrorDescription.new("The argument to getMaxIntrinsicWidth must not be negative or null."), new assertions.ErrorHint.new("If you do not have a specific height in mind, then pass double.infinity instead.")])));
        }
        if (dart.notNull(height) < 0.0) {
          dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("The height argument to getMaxIntrinsicWidth was negative."), new assertions.ErrorDescription.new("The argument to getMaxIntrinsicWidth must not be negative or null."), new assertions.ErrorHint.new("If you perform computations on another height before passing it to " + "getMaxIntrinsicWidth, consider using math.max() or double.clamp() " + "to force the value into the valid range.")])));
        }
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 1552, 12, "() {\r\n      // `height` has a non-nullable return type, but might be null when\r\n      // running with weak checking, so we need to null check it anyway (and\r\n      // ignore the warning that the null-handling logic is dead code).\r\n      if (height == null) { // ignore: dead_code\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('The height argument to getMaxIntrinsicWidth was null.'),\r\n          ErrorDescription('The argument to getMaxIntrinsicWidth must not be negative or null.'),\r\n          ErrorHint('If you do not have a specific height in mind, then pass double.infinity instead.'),\r\n        ]);\r\n      }\r\n      if (height < 0.0) {\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('The height argument to getMaxIntrinsicWidth was negative.'),\r\n          ErrorDescription('The argument to getMaxIntrinsicWidth must not be negative or null.'),\r\n          ErrorHint(\r\n            'If you perform computations on another height before passing it to '\r\n            'getMaxIntrinsicWidth, consider using math.max() or double.clamp() '\r\n            'to force the value into the valid range.'\r\n          ),\r\n        ]);\r\n      }\r\n      return true;\r\n    }()");
      return this[_computeIntrinsicDimension](box._IntrinsicDimension.maxWidth, height, dart.bind(this, 'computeMaxIntrinsicWidth'));
    }
    computeMaxIntrinsicWidth(height) {
      if (height == null) dart.nullFailed(I[6], 1616, 42, "height");
      return 0.0;
    }
    getMinIntrinsicHeight(width) {
      if (width == null) dart.nullFailed(I[6], 1637, 39, "width");
      if (!dart.test(dart.fn(() => {
        if (width == null) {
          dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("The width argument to getMinIntrinsicHeight was null."), new assertions.ErrorDescription.new("The argument to getMinIntrinsicHeight must not be negative or null."), new assertions.ErrorHint.new("If you do not have a specific width in mind, then pass double.infinity instead.")])));
        }
        if (dart.notNull(width) < 0.0) {
          dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("The width argument to getMinIntrinsicHeight was negative."), new assertions.ErrorDescription.new("The argument to getMinIntrinsicHeight must not be negative or null."), new assertions.ErrorHint.new("If you perform computations on another width before passing it to " + "getMinIntrinsicHeight, consider using math.max() or double.clamp() " + "to force the value into the valid range.")])));
        }
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 1638, 12, "() {\r\n      // `width` has a non-nullable return type, but might be null when\r\n      // running with weak checking, so we need to null check it anyway (and\r\n      // ignore the warning that the null-handling logic is dead code).\r\n      if (width == null) { // ignore: dead_code\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('The width argument to getMinIntrinsicHeight was null.'),\r\n          ErrorDescription('The argument to getMinIntrinsicHeight must not be negative or null.'),\r\n          ErrorHint('If you do not have a specific width in mind, then pass double.infinity instead.'),\r\n        ]);\r\n      }\r\n      if (width < 0.0) {\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('The width argument to getMinIntrinsicHeight was negative.'),\r\n          ErrorDescription('The argument to getMinIntrinsicHeight must not be negative or null.'),\r\n          ErrorHint(\r\n            'If you perform computations on another width before passing it to '\r\n            'getMinIntrinsicHeight, consider using math.max() or double.clamp() '\r\n            'to force the value into the valid range.'\r\n          ),\r\n        ]);\r\n      }\r\n      return true;\r\n    }()");
      return this[_computeIntrinsicDimension](box._IntrinsicDimension.minHeight, width, dart.bind(this, 'computeMinIntrinsicHeight'));
    }
    computeMinIntrinsicHeight(width) {
      if (width == null) dart.nullFailed(I[6], 1700, 43, "width");
      return 0.0;
    }
    getMaxIntrinsicHeight(width) {
      if (width == null) dart.nullFailed(I[6], 1722, 39, "width");
      if (!dart.test(dart.fn(() => {
        if (width == null) {
          dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("The width argument to getMaxIntrinsicHeight was null."), new assertions.ErrorDescription.new("The argument to getMaxIntrinsicHeight must not be negative or null."), new assertions.ErrorHint.new("If you do not have a specific width in mind, then pass double.infinity instead.")])));
        }
        if (dart.notNull(width) < 0.0) {
          dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("The width argument to getMaxIntrinsicHeight was negative."), new assertions.ErrorDescription.new("The argument to getMaxIntrinsicHeight must not be negative or null."), new assertions.ErrorHint.new("If you perform computations on another width before passing it to " + "getMaxIntrinsicHeight, consider using math.max() or double.clamp() " + "to force the value into the valid range.")])));
        }
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 1723, 12, "() {\r\n      // `width` has a non-nullable return type, but might be null when\r\n      // running with weak checking, so we need to null check it anyway (and\r\n      // ignore the warning that the null-handling logic is dead code).\r\n      if (width == null) { // ignore: dead_code\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('The width argument to getMaxIntrinsicHeight was null.'),\r\n          ErrorDescription('The argument to getMaxIntrinsicHeight must not be negative or null.'),\r\n          ErrorHint('If you do not have a specific width in mind, then pass double.infinity instead.'),\r\n        ]);\r\n      }\r\n      if (width < 0.0) {\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('The width argument to getMaxIntrinsicHeight was negative.'),\r\n          ErrorDescription('The argument to getMaxIntrinsicHeight must not be negative or null.'),\r\n          ErrorHint(\r\n            'If you perform computations on another width before passing it to '\r\n            'getMaxIntrinsicHeight, consider using math.max() or double.clamp() '\r\n            'to force the value into the valid range.'\r\n          ),\r\n        ]);\r\n      }\r\n      return true;\r\n    }()");
      return this[_computeIntrinsicDimension](box._IntrinsicDimension.maxHeight, width, dart.bind(this, 'computeMaxIntrinsicHeight'));
    }
    computeMaxIntrinsicHeight(width) {
      if (width == null) dart.nullFailed(I[6], 1787, 43, "width");
      return 0.0;
    }
    getDryLayout(constraints) {
      if (constraints == null) dart.nullFailed(I[6], 1813, 36, "constraints");
      let shouldCache = true;
      if (!dart.test(dart.fn(() => {
        if (dart.test(object$.RenderObject.debugCheckingIntrinsics)) shouldCache = false;
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 1815, 12, "() {\r\n      // we don't want the checked-mode intrinsic tests to affect\r\n      // who gets marked dirty, etc.\r\n      if (RenderObject.debugCheckingIntrinsics)\r\n        shouldCache = false;\r\n      return true;\r\n    }()");
      if (shouldCache) {
        this[_cachedDryLayoutSizes] == null ? this[_cachedDryLayoutSizes] = new (T$.LinkedMapOfBoxConstraints$Size()).new() : null;
        return dart.nullCheck(this[_cachedDryLayoutSizes])[$putIfAbsent](constraints, dart.fn(() => this[_computeDryLayout](constraints), T$.VoidToSize()));
      }
      return this[_computeDryLayout](constraints);
    }
    [_computeDryLayout](constraints) {
      if (constraints == null) dart.nullFailed(I[6], 1829, 41, "constraints");
      if (!dart.test(dart.fn(() => {
        if (!!dart.test(this[_computingThisDryLayout])) dart.assertFailed(null, I[6], 1831, 14, "!_computingThisDryLayout");
        this[_computingThisDryLayout] = true;
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 1830, 12, "() {\r\n      assert(!_computingThisDryLayout);\r\n      _computingThisDryLayout = true;\r\n      return true;\r\n    }()");
      let result = this.computeDryLayout(constraints);
      if (!dart.test(dart.fn(() => {
        if (!dart.test(this[_computingThisDryLayout])) dart.assertFailed(null, I[6], 1837, 14, "_computingThisDryLayout");
        this[_computingThisDryLayout] = false;
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 1836, 12, "() {\r\n      assert(_computingThisDryLayout);\r\n      _computingThisDryLayout = false;\r\n      return true;\r\n    }()");
      return result;
    }
    computeDryLayout(constraints) {
      if (constraints == null) dart.nullFailed(I[6], 1877, 40, "constraints");
      if (!dart.test(this.debugCannotComputeDryLayout({error: new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("The " + dart.str(object.objectRuntimeType(this, "RenderBox")) + " class does not implement \"computeDryLayout\"."), new assertions.ErrorHint.new("If you are not writing your own RenderBox subclass, then this is not\n" + "your fault. Contact support: https://github.com/flutter/flutter/issues/new?template=2_bug.md")]))}))) dart.assertFailed(null, I[6], 1878, 12, "debugCannotComputeDryLayout(\r\n      error: FlutterError.fromParts(<DiagnosticsNode>[\r\n        ErrorSummary('The ${objectRuntimeType(this, 'RenderBox')} class does not implement \"computeDryLayout\".'),\r\n        ErrorHint(\r\n          'If you are not writing your own RenderBox subclass, then this is not\\n'\r\n          'your fault. Contact support: https://github.com/flutter/flutter/issues/new?template=2_bug.md'\r\n        ),\r\n      ]),\r\n    )");
      return ui.Size.zero;
    }
    debugCannotComputeDryLayout(opts) {
      let reason = opts && 'reason' in opts ? opts.reason : null;
      let error = opts && 'error' in opts ? opts.error : null;
      if (!(reason == null !== (error == null))) dart.assertFailed(null, I[6], 1907, 12, "(reason == null) != (error == null)");
      if (!dart.test(dart.fn(() => {
        if (!dart.test(object$.RenderObject.debugCheckingIntrinsics)) {
          if (reason != null) {
            if (!(error == null)) dart.assertFailed(null, I[6], 1911, 18, "error ==null");
            dart.throw(new assertions.FlutterError.fromParts((() => {
              let t20 = T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("The " + dart.str(object.objectRuntimeType(this, "RenderBox")) + " class does not support dry layout.")]);
              if (reason[$isNotEmpty]) t20[$add](new assertions.ErrorDescription.new(reason));
              return t20;
            })()));
          }
          if (!(error != null)) dart.assertFailed(null, I[6], 1917, 16, "error != null");
          dart.throw(dart.nullCheck(error));
        }
        box.RenderBox._dryLayoutCalculationValid = false;
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 1908, 12, "() {\r\n      if (!RenderObject.debugCheckingIntrinsics) {\r\n        if (reason != null) {\r\n          assert(error ==null);\r\n          throw FlutterError.fromParts(<DiagnosticsNode>[\r\n            ErrorSummary('The ${objectRuntimeType(this, 'RenderBox')} class does not support dry layout.'),\r\n            if (reason.isNotEmpty) ErrorDescription(reason),\r\n          ]);\r\n        }\r\n        assert(error != null);\r\n        throw error!;\r\n      }\r\n      _dryLayoutCalculationValid = false;\r\n      return true;\r\n    }()");
      return true;
    }
    get hasSize() {
      return this[_size$] != null;
    }
    get size() {
      if (!dart.test(this.hasSize)) dart.assertFailed("RenderBox was not laid out: " + dart.str(this.toString()), I[6], 1940, 12, "hasSize");
      if (!dart.test(dart.fn(() => {
        let _size = this[_size$];
        if (box._DebugSize.is(_size)) {
          if (!dart.equals(_size[_owner$], this)) dart.assertFailed(null, I[6], 1944, 16, "_size._owner == this");
          if (object$.RenderObject.debugActiveLayout != null && !dart.test(dart.nullCheck(object$.RenderObject.debugActiveLayout).debugDoingThisLayoutWithCallback)) {
            if (!(dart.test(this.debugDoingThisResize) || dart.test(this.debugDoingThisLayout) || dart.test(this[_computingThisDryLayout]) || dart.equals(object$.RenderObject.debugActiveLayout, this.parent) && dart.test(_size[_canBeUsedByParent$]))) dart.assertFailed("RenderBox.size accessed beyond the scope of resize, layout, or " + "permitted parent access. RenderBox can always access its own size, " + "otherwise, the only object that is allowed to read RenderBox.size " + "is its parent, if they have said they will. It you hit this assert " + "trying to access a child's size, pass \"parentUsesSize: true\" to " + "that child's layout().", I[6], 1948, 13, "debugDoingThisResize || debugDoingThisLayout || _computingThisDryLayout ||\r\n              (RenderObject.debugActiveLayout == parent && _size._canBeUsedByParent)");
          }
          if (!dart.equals(_size, this[_size$])) dart.assertFailed(null, I[6], 1958, 16, "_size == this._size");
        }
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 1941, 12, "() {\r\n      final Size? _size = this._size;\r\n      if (_size is _DebugSize) {\r\n        assert(_size._owner == this);\r\n        if (RenderObject.debugActiveLayout != null &&\r\n            !RenderObject.debugActiveLayout!.debugDoingThisLayoutWithCallback) {\r\n          assert(\r\n            debugDoingThisResize || debugDoingThisLayout || _computingThisDryLayout ||\r\n              (RenderObject.debugActiveLayout == parent && _size._canBeUsedByParent),\r\n            'RenderBox.size accessed beyond the scope of resize, layout, or '\r\n            'permitted parent access. RenderBox can always access its own size, '\r\n            'otherwise, the only object that is allowed to read RenderBox.size '\r\n            'is its parent, if they have said they will. It you hit this assert '\r\n            'trying to access a child\\'s size, pass \"parentUsesSize: true\" to '\r\n            'that child\\'s layout().'\r\n          );\r\n        }\r\n        assert(_size == this._size);\r\n      }\r\n      return true;\r\n    }()");
      return dart.nullCheck(this[_size$]);
    }
    set size(value) {
      if (value == null) dart.nullFailed(I[6], 1969, 17, "value");
      if (!!(dart.test(this.debugDoingThisResize) && dart.test(this.debugDoingThisLayout))) dart.assertFailed(null, I[6], 1970, 12, "!(debugDoingThisResize && debugDoingThisLayout)");
      if (!(dart.test(this.sizedByParent) || !dart.test(this.debugDoingThisResize))) dart.assertFailed(null, I[6], 1971, 12, "sizedByParent || !debugDoingThisResize");
      if (!dart.test(dart.fn(() => {
        if (dart.test(this.sizedByParent) && dart.test(this.debugDoingThisResize) || !dart.test(this.sizedByParent) && dart.test(this.debugDoingThisLayout)) return true;
        if (!!dart.test(this.debugDoingThisResize)) dart.assertFailed(null, I[6], 1976, 14, "!debugDoingThisResize");
        let information = T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("RenderBox size setter called incorrectly.")]);
        if (dart.test(this.debugDoingThisLayout)) {
          if (!dart.test(this.sizedByParent)) dart.assertFailed(null, I[6], 1981, 16, "sizedByParent");
          information[$add](new assertions.ErrorDescription.new("It appears that the size setter was called from performLayout()."));
        } else {
          information[$add](new assertions.ErrorDescription.new("The size setter was called from outside layout (neither performResize() nor performLayout() were being run for this object)."));
          if (this.owner != null && dart.test(dart.nullCheck(this.owner).debugDoingLayout)) information[$add](new assertions.ErrorDescription.new("Only the object itself can set its size. It is a contract violation for other objects to set it."));
        }
        if (dart.test(this.sizedByParent))
          information[$add](new assertions.ErrorDescription.new("Because this RenderBox has sizedByParent set to true, it must set its size in performResize()."));
        else
          information[$add](new assertions.ErrorDescription.new("Because this RenderBox has sizedByParent set to false, it must set its size in performLayout()."));
        dart.throw(new assertions.FlutterError.fromParts(information));
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 1972, 12, "() {\r\n      if ((sizedByParent && debugDoingThisResize) ||\r\n          (!sizedByParent && debugDoingThisLayout))\r\n        return true;\r\n      assert(!debugDoingThisResize);\r\n      final List<DiagnosticsNode> information = <DiagnosticsNode>[\r\n        ErrorSummary('RenderBox size setter called incorrectly.'),\r\n      ];\r\n      if (debugDoingThisLayout) {\r\n        assert(sizedByParent);\r\n        information.add(ErrorDescription('It appears that the size setter was called from performLayout().'));\r\n      } else {\r\n        information.add(ErrorDescription(\r\n          'The size setter was called from outside layout (neither performResize() nor performLayout() were being run for this object).'\r\n        ));\r\n        if (owner != null && owner!.debugDoingLayout)\r\n          information.add(ErrorDescription('Only the object itself can set its size. It is a contract violation for other objects to set it.'));\r\n      }\r\n      if (sizedByParent)\r\n        information.add(ErrorDescription('Because this RenderBox has sizedByParent set to true, it must set its size in performResize().'));\r\n      else\r\n        information.add(ErrorDescription('Because this RenderBox has sizedByParent set to false, it must set its size in performLayout().'));\r\n      throw FlutterError.fromParts(information);\r\n    }()");
      if (!dart.test(dart.fn(() => {
        value = this.debugAdoptSize(value);
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 1996, 12, "() {\r\n      value = debugAdoptSize(value);\r\n      return true;\r\n    }()");
      this[_size$] = value;
      if (!dart.test(dart.fn(() => {
        this.debugAssertDoesMeetConstraints();
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 2001, 12, "() {\r\n      debugAssertDoesMeetConstraints();\r\n      return true;\r\n    }()");
    }
    debugAdoptSize(value) {
      if (value == null) dart.nullFailed(I[6], 2020, 28, "value");
      let result = value;
      if (!dart.test(dart.fn(() => {
        if (box._DebugSize.is(value)) {
          if (!dart.equals(value[_owner$], this)) {
            if (!dart.equals(value[_owner$].parent, this)) {
              dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("The size property was assigned a size inappropriately."), this.describeForError("The following render object"), value[_owner$].describeForError("...was assigned a size obtained from"), new assertions.ErrorDescription.new("However, this second render object is not, or is no longer, a " + "child of the first, and it is therefore a violation of the " + "RenderBox layout protocol to use that size in the layout of the " + "first render object."), new assertions.ErrorHint.new("If the size was obtained at a time where it was valid to read " + "the size (because the second render object above was a child " + "of the first at the time), then it should be adopted using " + "debugAdoptSize at that time."), new assertions.ErrorHint.new("If the size comes from a grandchild or a render object from an " + "entirely different part of the render tree, then there is no " + "way to be notified when the size changes and therefore attempts " + "to read that size are almost certainly a source of bugs. A different " + "approach should be used.")])));
            }
            if (!dart.test(value[_canBeUsedByParent$])) {
              dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("A child's size was used without setting parentUsesSize."), this.describeForError("The following render object"), value[_owner$].describeForError("...was assigned a size obtained from its child"), new assertions.ErrorDescription.new("However, when the child was laid out, the parentUsesSize argument " + "was not set or set to false. Subsequently this transpired to be " + "inaccurate: the size was nonetheless used by the parent.\n" + "It is important to tell the framework if the size will be used or not " + "as several important performance optimizations can be made if the " + "size will not be used by the parent.")])));
            }
          }
        }
        result = new box._DebugSize.new(value, this, this.debugCanParentUseSize);
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 2022, 12, "() {\r\n      if (value is _DebugSize) {\r\n        if (value._owner != this) {\r\n          if (value._owner.parent != this) {\r\n            throw FlutterError.fromParts(<DiagnosticsNode>[\r\n              ErrorSummary('The size property was assigned a size inappropriately.'),\r\n              describeForError('The following render object'),\r\n              value._owner.describeForError('...was assigned a size obtained from'),\r\n              ErrorDescription(\r\n                'However, this second render object is not, or is no longer, a '\r\n                'child of the first, and it is therefore a violation of the '\r\n                'RenderBox layout protocol to use that size in the layout of the '\r\n                'first render object.'\r\n              ),\r\n              ErrorHint(\r\n                'If the size was obtained at a time where it was valid to read '\r\n                'the size (because the second render object above was a child '\r\n                'of the first at the time), then it should be adopted using '\r\n                'debugAdoptSize at that time.'\r\n              ),\r\n              ErrorHint(\r\n                'If the size comes from a grandchild or a render object from an '\r\n                'entirely different part of the render tree, then there is no '\r\n                'way to be notified when the size changes and therefore attempts '\r\n                'to read that size are almost certainly a source of bugs. A different '\r\n                'approach should be used.'\r\n              ),\r\n            ]);\r\n          }\r\n          if (!value._canBeUsedByParent) {\r\n            throw FlutterError.fromParts(<DiagnosticsNode>[\r\n              ErrorSummary(\"A child's size was used without setting parentUsesSize.\"),\r\n              describeForError('The following render object'),\r\n              value._owner.describeForError('...was assigned a size obtained from its child'),\r\n              ErrorDescription(\r\n                'However, when the child was laid out, the parentUsesSize argument '\r\n                'was not set or set to false. Subsequently this transpired to be '\r\n                'inaccurate: the size was nonetheless used by the parent.\\n'\r\n                'It is important to tell the framework if the size will be used or not '\r\n                'as several important performance optimizations can be made if the '\r\n                'size will not be used by the parent.'\r\n              ),\r\n            ]);\r\n          }\r\n        }\r\n      }\r\n      result = _DebugSize(value, this, debugCanParentUseSize);\r\n      return true;\r\n    }()");
      return result;
    }
    get semanticBounds() {
      return ui.Offset.zero['&'](this.size);
    }
    debugResetSize() {
      this.size = this.size;
    }
    static _debugSetDoingBaseline(value) {
      if (value == null) dart.nullFailed(I[6], 2085, 43, "value");
      box.RenderBox._debugDoingBaseline = value;
      return true;
    }
    getDistanceToBaseline(baseline, opts) {
      if (baseline == null) dart.nullFailed(I[6], 2106, 46, "baseline");
      let onlyReal = opts && 'onlyReal' in opts ? opts.onlyReal : false;
      if (onlyReal == null) dart.nullFailed(I[6], 2106, 63, "onlyReal");
      if (!!dart.test(box.RenderBox._debugDoingBaseline)) dart.assertFailed("Please see the documentation for computeDistanceToActualBaseline for the required calling conventions of this method.", I[6], 2107, 12, "!_debugDoingBaseline");
      if (!!dart.test(this.debugNeedsLayout)) dart.assertFailed(null, I[6], 2108, 12, "!debugNeedsLayout");
      if (!dart.test(dart.fn(() => {
        let parent = T$.RenderObjectN().as(this.parent);
        if (dart.test(dart.nullCheck(this.owner).debugDoingLayout)) return dart.equals(object$.RenderObject.debugActiveLayout, parent) && dart.test(dart.nullCheck(parent).debugDoingThisLayout);
        if (dart.test(dart.nullCheck(this.owner).debugDoingPaint)) return dart.equals(object$.RenderObject.debugActivePaint, parent) && dart.test(dart.nullCheck(parent).debugDoingThisPaint) || dart.equals(object$.RenderObject.debugActivePaint, this) && dart.test(this.debugDoingThisPaint);
        if (!dart.equals(parent, this.parent)) dart.assertFailed(null, I[6], 2116, 14, "parent == this.parent");
        return false;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 2109, 12, "() {\r\n      final RenderObject? parent = this.parent as RenderObject?;\r\n      if (owner!.debugDoingLayout)\r\n        return (RenderObject.debugActiveLayout == parent) && parent!.debugDoingThisLayout;\r\n      if (owner!.debugDoingPaint)\r\n        return ((RenderObject.debugActivePaint == parent) && parent!.debugDoingThisPaint) ||\r\n               ((RenderObject.debugActivePaint == this) && debugDoingThisPaint);\r\n      assert(parent == this.parent);\r\n      return false;\r\n    }()");
      if (!dart.test(box.RenderBox._debugSetDoingBaseline(true))) dart.assertFailed(null, I[6], 2119, 12, "_debugSetDoingBaseline(true)");
      let result = this.getDistanceToActualBaseline(baseline);
      if (!dart.test(box.RenderBox._debugSetDoingBaseline(false))) dart.assertFailed(null, I[6], 2121, 12, "_debugSetDoingBaseline(false)");
      if (result == null && !dart.test(onlyReal)) return this.size.height;
      return result;
    }
    getDistanceToActualBaseline(baseline) {
      if (baseline == null) dart.nullFailed(I[6], 2134, 52, "baseline");
      if (!dart.test(box.RenderBox._debugDoingBaseline)) dart.assertFailed("Please see the documentation for computeDistanceToActualBaseline for the required calling conventions of this method.", I[6], 2135, 12, "_debugDoingBaseline");
      this[_cachedBaselines] == null ? this[_cachedBaselines] = new (T$.LinkedMapOfTextBaseline$doubleN()).new() : null;
      dart.nullCheck(this[_cachedBaselines])[$putIfAbsent](baseline, dart.fn(() => this.computeDistanceToActualBaseline(baseline), T$.VoidTodoubleN()));
      return dart.nullCheck(this[_cachedBaselines])[$_get](baseline);
    }
    computeDistanceToActualBaseline(baseline) {
      if (baseline == null) dart.nullFailed(I[6], 2166, 56, "baseline");
      if (!dart.test(box.RenderBox._debugDoingBaseline)) dart.assertFailed("Please see the documentation for computeDistanceToActualBaseline for the required calling conventions of this method.", I[6], 2167, 12, "_debugDoingBaseline");
      return null;
    }
    get constraints() {
      return box.BoxConstraints.as(super.constraints);
    }
    debugAssertDoesMeetConstraints() {
      if (!(this.constraints != null)) dart.assertFailed(null, I[6], 2177, 12, "constraints != null");
      if (!dart.test(dart.fn(() => {
        if (!dart.test(this.hasSize)) {
          let contract = null;
          if (dart.test(this.sizedByParent))
            contract = new assertions.ErrorDescription.new("Because this RenderBox has sizedByParent set to true, it must set its size in performResize().");
          else
            contract = new assertions.ErrorDescription.new("Because this RenderBox has sizedByParent set to false, it must set its size in performLayout().");
          dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("RenderBox did not set its size during layout."), contract, new assertions.ErrorDescription.new("It appears that this did not happen; layout completed, but the size property is still null."), new (T$.DiagnosticsPropertyOfRenderBox()).new("The RenderBox in question is", this, {style: diagnostics.DiagnosticsTreeStyle.errorProperty})])));
        }
        if (!dart.test(dart.nullCheck(this[_size$]).isFinite)) {
          let information = T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new(dart.str(this[$runtimeType]) + " object was given an infinite size during layout."), new assertions.ErrorDescription.new("This probably means that it is a render object that tries to be " + "as big as possible, but it was put inside another render object " + "that allows its children to pick their own size.")]);
          if (!dart.test(this.constraints.hasBoundedWidth)) {
            let node = this;
            while (!dart.test(node.constraints.hasBoundedWidth) && box.RenderBox.is(node.parent))
              node = box.RenderBox.as(dart.nullCheck(node.parent));
            information[$add](node.describeForError("The nearest ancestor providing an unbounded width constraint is"));
          }
          if (!dart.test(this.constraints.hasBoundedHeight)) {
            let node = this;
            while (!dart.test(node.constraints.hasBoundedHeight) && box.RenderBox.is(node.parent))
              node = box.RenderBox.as(dart.nullCheck(node.parent));
            information[$add](node.describeForError("The nearest ancestor providing an unbounded height constraint is"));
          }
          dart.throw(new assertions.FlutterError.fromParts((() => {
            let t21 = T$.ListOfDiagnosticsNode().of(information);
            t21[$add](new (T$.DiagnosticsPropertyOfBoxConstraints()).new("The constraints that applied to the " + dart.str(this[$runtimeType]) + " were", this.constraints, {style: diagnostics.DiagnosticsTreeStyle.errorProperty}));
            t21[$add](new (T$.DiagnosticsPropertyOfSize()).new("The exact size it was given was", this[_size$], {style: diagnostics.DiagnosticsTreeStyle.errorProperty}));
            t21[$add](new assertions.ErrorHint.new("See https://flutter.dev/docs/development/ui/layout/box-constraints for more information."));
            return t21;
          })()));
        }
        if (!dart.test(this.constraints.isSatisfiedBy(dart.nullCheck(this[_size$])))) {
          dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new(dart.str(this[$runtimeType]) + " does not meet its constraints."), new (T$.DiagnosticsPropertyOfBoxConstraints()).new("Constraints", this.constraints, {style: diagnostics.DiagnosticsTreeStyle.errorProperty}), new (T$.DiagnosticsPropertyOfSize()).new("Size", this[_size$], {style: diagnostics.DiagnosticsTreeStyle.errorProperty}), new assertions.ErrorHint.new("If you are not writing your own RenderBox subclass, then this is not " + "your fault. Contact support: https://github.com/flutter/flutter/issues/new?template=2_bug.md")])));
        }
        if (dart.test(debug$0.debugCheckIntrinsicSizes)) {
          if (!!dart.test(object$.RenderObject.debugCheckingIntrinsics)) dart.assertFailed(null, I[6], 2237, 16, "!RenderObject.debugCheckingIntrinsics");
          object$.RenderObject.debugCheckingIntrinsics = true;
          let failures = T$.JSArrayOfDiagnosticsNode().of([]);
          function testIntrinsic($function, name, constraint) {
            if ($function == null) dart.nullFailed(I[6], 2241, 37, "function");
            if (name == null) dart.nullFailed(I[6], 2241, 69, "name");
            if (constraint == null) dart.nullFailed(I[6], 2241, 82, "constraint");
            let result = $function(constraint);
            if (dart.notNull(result) < 0) {
              failures[$add](new assertions.ErrorDescription.new(" * " + dart.str(name) + "(" + dart.str(constraint) + ") returned a negative value: " + dart.str(result)));
            }
            if (!result[$isFinite]) {
              failures[$add](new assertions.ErrorDescription.new(" * " + dart.str(name) + "(" + dart.str(constraint) + ") returned a non-finite value: " + dart.str(result)));
            }
            return result;
          }
          dart.fn(testIntrinsic, T$.FnAndStringAnddoubleTodouble());
          function testIntrinsicsForValues(getMin, getMax, name, constraint) {
            if (getMin == null) dart.nullFailed(I[6], 2252, 45, "getMin");
            if (getMax == null) dart.nullFailed(I[6], 2252, 75, "getMax");
            if (name == null) dart.nullFailed(I[6], 2252, 105, "name");
            if (constraint == null) dart.nullFailed(I[6], 2252, 118, "constraint");
            let min = testIntrinsic(getMin, "getMinIntrinsic" + dart.str(name), constraint);
            let max = testIntrinsic(getMax, "getMaxIntrinsic" + dart.str(name), constraint);
            if (dart.notNull(min) > dart.notNull(max)) {
              failures[$add](new assertions.ErrorDescription.new(" * getMinIntrinsic" + dart.str(name) + "(" + dart.str(constraint) + ") returned a larger value (" + dart.str(min) + ") than getMaxIntrinsic" + dart.str(name) + "(" + dart.str(constraint) + ") (" + dart.str(max) + ")"));
            }
          }
          dart.fn(testIntrinsicsForValues, T$.FnAndFnAndString__Tovoid());
          testIntrinsicsForValues(dart.bind(this, 'getMinIntrinsicWidth'), dart.bind(this, 'getMaxIntrinsicWidth'), "Width", 1 / 0);
          testIntrinsicsForValues(dart.bind(this, 'getMinIntrinsicHeight'), dart.bind(this, 'getMaxIntrinsicHeight'), "Height", 1 / 0);
          if (dart.test(this.constraints.hasBoundedWidth)) testIntrinsicsForValues(dart.bind(this, 'getMinIntrinsicWidth'), dart.bind(this, 'getMaxIntrinsicWidth'), "Width", this.constraints.maxHeight);
          if (dart.test(this.constraints.hasBoundedHeight)) testIntrinsicsForValues(dart.bind(this, 'getMinIntrinsicHeight'), dart.bind(this, 'getMaxIntrinsicHeight'), "Height", this.constraints.maxWidth);
          object$.RenderObject.debugCheckingIntrinsics = false;
          if (dart.test(failures[$isNotEmpty])) {
            dart.throw(new assertions.FlutterError.fromParts((() => {
              let t22 = T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("The intrinsic dimension methods of the " + dart.str(this[$runtimeType]) + " class returned values that violate the intrinsic protocol contract."), new assertions.ErrorDescription.new("The following " + (dart.notNull(failures[$length]) > 1 ? "failures" : "failure") + " was detected:")]);
              t22[$addAll](failures);
              t22[$add](new assertions.ErrorHint.new("If you are not writing your own RenderBox subclass, then this is not\n" + "your fault. Contact support: https://github.com/flutter/flutter/issues/new?template=2_bug.md"));
              return t22;
            })()));
          }
          box.RenderBox._dryLayoutCalculationValid = true;
          object$.RenderObject.debugCheckingIntrinsics = true;
          let dryLayoutSize = null;
          let dryLayoutSize$35isSet = false;
          function dryLayoutSize$35get() {
            return dryLayoutSize$35isSet ? dryLayoutSize : dart.throw(new _internal.LateError.localNI("dryLayoutSize"));
          }
          dart.fn(dryLayoutSize$35get, T$.VoidToSize());
          function dryLayoutSize$35set(t26) {
            if (t26 == null) dart.nullFailed(I[6], 2286, 19, "null");
            dryLayoutSize$35isSet = true;
            return dryLayoutSize = t26;
          }
          dart.fn(dryLayoutSize$35set, T$.SizeTodynamic());
          try {
            dryLayoutSize$35set(this.getDryLayout(this.constraints));
          } finally {
            object$.RenderObject.debugCheckingIntrinsics = false;
          }
          if (dart.test(box.RenderBox._dryLayoutCalculationValid) && !dart.equals(dryLayoutSize$35get(), this.size)) {
            dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("The size given to the " + dart.str(object.objectRuntimeType(this, "RenderBox")) + " class differs from the size computed by computeDryLayout."), new assertions.ErrorDescription.new("The size computed in " + (dart.test(this.sizedByParent) ? "performResize" : "performLayout") + " " + "is " + dart.str(this.size) + ", which is different from " + dart.str(dryLayoutSize$35get()) + ", which was computed by computeDryLayout."), new assertions.ErrorDescription.new("The constraints used were " + dart.str(this.constraints) + "."), new assertions.ErrorHint.new("If you are not writing your own RenderBox subclass, then this is not\n" + "your fault. Contact support: https://github.com/flutter/flutter/issues/new?template=2_bug.md")])));
          }
        }
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 2178, 12, "() {\r\n      if (!hasSize) {\r\n        final DiagnosticsNode contract;\r\n        if (sizedByParent)\r\n          contract = ErrorDescription('Because this RenderBox has sizedByParent set to true, it must set its size in performResize().');\r\n        else\r\n          contract = ErrorDescription('Because this RenderBox has sizedByParent set to false, it must set its size in performLayout().');\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('RenderBox did not set its size during layout.'),\r\n          contract,\r\n          ErrorDescription('It appears that this did not happen; layout completed, but the size property is still null.'),\r\n          DiagnosticsProperty<RenderBox>('The RenderBox in question is', this, style: DiagnosticsTreeStyle.errorProperty),\r\n        ]);\r\n      }\r\n      // verify that the size is not infinite\r\n      if (!_size!.isFinite) {\r\n        final List<DiagnosticsNode> information = <DiagnosticsNode>[\r\n          ErrorSummary('$runtimeType object was given an infinite size during layout.'),\r\n          ErrorDescription(\r\n            'This probably means that it is a render object that tries to be '\r\n            'as big as possible, but it was put inside another render object '\r\n            'that allows its children to pick their own size.'\r\n          ),\r\n        ];\r\n        if (!constraints.hasBoundedWidth) {\r\n          RenderBox node = this;\r\n          while (!node.constraints.hasBoundedWidth && node.parent is RenderBox)\r\n            node = node.parent! as RenderBox;\r\n\r\n          information.add(node.describeForError('The nearest ancestor providing an unbounded width constraint is'));\r\n        }\r\n        if (!constraints.hasBoundedHeight) {\r\n          RenderBox node = this;\r\n          while (!node.constraints.hasBoundedHeight && node.parent is RenderBox)\r\n            node = node.parent! as RenderBox;\r\n\r\n          information.add(node.describeForError('The nearest ancestor providing an unbounded height constraint is'));\r\n        }\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ...information,\r\n          DiagnosticsProperty<BoxConstraints>('The constraints that applied to the $runtimeType were', constraints, style: DiagnosticsTreeStyle.errorProperty),\r\n          DiagnosticsProperty<Size>('The exact size it was given was', _size, style: DiagnosticsTreeStyle.errorProperty),\r\n          ErrorHint('See https://flutter.dev/docs/development/ui/layout/box-constraints for more information.'),\r\n        ]);\r\n     }\r\n      // verify that the size is within the constraints\r\n      if (!constraints.isSatisfiedBy(_size!)) {\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('$runtimeType does not meet its constraints.'),\r\n          DiagnosticsProperty<BoxConstraints>('Constraints', constraints, style: DiagnosticsTreeStyle.errorProperty),\r\n          DiagnosticsProperty<Size>('Size', _size, style: DiagnosticsTreeStyle.errorProperty),\r\n          ErrorHint(\r\n            'If you are not writing your own RenderBox subclass, then this is not '\r\n            'your fault. Contact support: https://github.com/flutter/flutter/issues/new?template=2_bug.md'\r\n          ),\r\n        ]);\r\n      }\r\n      if (debugCheckIntrinsicSizes) {\r\n        // verify that the intrinsics are sane\r\n        assert(!RenderObject.debugCheckingIntrinsics);\r\n        RenderObject.debugCheckingIntrinsics = true;\r\n        final List<DiagnosticsNode> failures = <DiagnosticsNode>[];\r\n\r\n        double testIntrinsic(double function(double extent), String name, double constraint) {\r\n          final double result = function(constraint);\r\n          if (result < 0) {\r\n            failures.add(ErrorDescription(' * $name($constraint) returned a negative value: $result'));\r\n          }\r\n          if (!result.isFinite) {\r\n            failures.add(ErrorDescription(' * $name($constraint) returned a non-finite value: $result'));\r\n          }\r\n          return result;\r\n        }\r\n\r\n        void testIntrinsicsForValues(double getMin(double extent), double getMax(double extent), String name, double constraint) {\r\n          final double min = testIntrinsic(getMin, 'getMinIntrinsic$name', constraint);\r\n          final double max = testIntrinsic(getMax, 'getMaxIntrinsic$name', constraint);\r\n          if (min > max) {\r\n            failures.add(ErrorDescription(' * getMinIntrinsic$name($constraint) returned a larger value ($min) than getMaxIntrinsic$name($constraint) ($max)'));\r\n          }\r\n        }\r\n\r\n        testIntrinsicsForValues(getMinIntrinsicWidth, getMaxIntrinsicWidth, 'Width', double.infinity);\r\n        testIntrinsicsForValues(getMinIntrinsicHeight, getMaxIntrinsicHeight, 'Height', double.infinity);\r\n        if (constraints.hasBoundedWidth)\r\n          testIntrinsicsForValues(getMinIntrinsicWidth, getMaxIntrinsicWidth, 'Width', constraints.maxHeight);\r\n        if (constraints.hasBoundedHeight)\r\n          testIntrinsicsForValues(getMinIntrinsicHeight, getMaxIntrinsicHeight, 'Height', constraints.maxWidth);\r\n\r\n        // TODO(ianh): Test that values are internally consistent in more ways than the above.\r\n\r\n        RenderObject.debugCheckingIntrinsics = false;\r\n        if (failures.isNotEmpty) {\r\n          // TODO(jacobr): consider nesting the failures object so it is collapsible.\r\n          throw FlutterError.fromParts(<DiagnosticsNode>[\r\n            ErrorSummary('The intrinsic dimension methods of the $runtimeType class returned values that violate the intrinsic protocol contract.'),\r\n            ErrorDescription('The following ${failures.length > 1 ? \"failures\" : \"failure\"} was detected:'), // should this be tagged as an error or not?\r\n            ...failures,\r\n            ErrorHint(\r\n              'If you are not writing your own RenderBox subclass, then this is not\\n'\r\n              'your fault. Contact support: https://github.com/flutter/flutter/issues/new?template=2_bug.md'\r\n            ),\r\n          ]);\r\n        }\r\n\r\n        // Checking that getDryLayout computes the same size.\r\n        _dryLayoutCalculationValid = true;\r\n        RenderObject.debugCheckingIntrinsics = true;\r\n        late Size dryLayoutSize;\r\n        try {\r\n          dryLayoutSize = getDryLayout(constraints);\r\n        } finally {\r\n          RenderObject.debugCheckingIntrinsics = false;\r\n        }\r\n        if (_dryLayoutCalculationValid && dryLayoutSize != size) {\r\n          throw FlutterError.fromParts(<DiagnosticsNode>[\r\n            ErrorSummary('The size given to the ${objectRuntimeType(this, 'RenderBox')} class differs from the size computed by computeDryLayout.'),\r\n            ErrorDescription(\r\n              'The size computed in ${sizedByParent ? 'performResize' : 'performLayout'} '\r\n              'is $size, which is different from $dryLayoutSize, which was computed by computeDryLayout.'\r\n            ),\r\n            ErrorDescription(\r\n              'The constraints used were $constraints.',\r\n            ),\r\n            ErrorHint(\r\n              'If you are not writing your own RenderBox subclass, then this is not\\n'\r\n              'your fault. Contact support: https://github.com/flutter/flutter/issues/new?template=2_bug.md'\r\n            ),\r\n          ]);\r\n        }\r\n      }\r\n      return true;\r\n    }()");
    }
    markNeedsLayout() {
      let t28, t28$, t28$0;
      if (this[_cachedBaselines] != null && dart.test(dart.nullCheck(this[_cachedBaselines])[$isNotEmpty]) || this[_cachedIntrinsicDimensions] != null && dart.test(dart.nullCheck(this[_cachedIntrinsicDimensions])[$isNotEmpty]) || this[_cachedDryLayoutSizes] != null && dart.test(dart.nullCheck(this[_cachedDryLayoutSizes])[$isNotEmpty])) {
        t28 = this[_cachedBaselines];
        t28 == null ? null : t28[$clear]();
        t28$ = this[_cachedIntrinsicDimensions];
        t28$ == null ? null : t28$[$clear]();
        t28$0 = this[_cachedDryLayoutSizes];
        t28$0 == null ? null : t28$0[$clear]();
        if (object$.RenderObject.is(this.parent)) {
          this.markParentNeedsLayout();
          return;
        }
      }
      super.markNeedsLayout();
    }
    performResize() {
      this.size = this.computeDryLayout(this.constraints);
      if (!dart.test(this.size.isFinite)) dart.assertFailed(null, I[6], 2343, 12, "size.isFinite");
    }
    performLayout() {
      if (!dart.test(dart.fn(() => {
        if (!dart.test(this.sizedByParent)) {
          dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new(dart.str(this[$runtimeType]) + " did not implement performLayout()."), new assertions.ErrorHint.new("RenderBox subclasses need to either override performLayout() to " + "set a size and lay out any children, or, set sizedByParent to true " + "so that performResize() sizes the render object.")])));
        }
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 2348, 12, "() {\r\n      if (!sizedByParent) {\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('$runtimeType did not implement performLayout().'),\r\n          ErrorHint(\r\n            'RenderBox subclasses need to either override performLayout() to '\r\n            'set a size and lay out any children, or, set sizedByParent to true '\r\n            'so that performResize() sizes the render object.'\r\n          ),\r\n        ]);\r\n      }\r\n      return true;\r\n    }()");
    }
    hitTest(result, opts) {
      if (result == null) dart.nullFailed(I[6], 2387, 33, "result");
      let position = opts && 'position' in opts ? opts.position : null;
      if (position == null) dart.nullFailed(I[6], 2387, 59, "position");
      if (!dart.test(dart.fn(() => {
        if (!dart.test(this.hasSize)) {
          if (dart.test(this.debugNeedsLayout)) {
            dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("Cannot hit test a render box that has never been laid out."), this.describeForError("The hitTest() method was called on this RenderBox"), new assertions.ErrorDescription.new("Unfortunately, this object's geometry is not known at this time, " + "probably because it has never been laid out. " + "This means it cannot be accurately hit-tested."), new assertions.ErrorHint.new("If you are trying " + "to perform a hit test during the layout phase itself, make sure " + "you only hit test nodes that have completed layout (e.g. the node's " + "children, after their layout() method has been called).")])));
          }
          dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("Cannot hit test a render box with no size."), this.describeForError("The hitTest() method was called on this RenderBox"), new assertions.ErrorDescription.new("Although this node is not marked as needing layout, " + "its size is not set."), new assertions.ErrorHint.new("A RenderBox object must have an " + "explicit size before it can be hit-tested. Make sure " + "that the RenderBox in question sets its size during layout.")])));
        }
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 2388, 12, "() {\r\n      if (!hasSize) {\r\n        if (debugNeedsLayout) {\r\n          throw FlutterError.fromParts(<DiagnosticsNode>[\r\n            ErrorSummary('Cannot hit test a render box that has never been laid out.'),\r\n            describeForError('The hitTest() method was called on this RenderBox'),\r\n            ErrorDescription(\r\n              \"Unfortunately, this object's geometry is not known at this time, \"\r\n              'probably because it has never been laid out. '\r\n              'This means it cannot be accurately hit-tested.'\r\n            ),\r\n            ErrorHint(\r\n              'If you are trying '\r\n              'to perform a hit test during the layout phase itself, make sure '\r\n              \"you only hit test nodes that have completed layout (e.g. the node's \"\r\n              'children, after their layout() method has been called).'\r\n            ),\r\n          ]);\r\n        }\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('Cannot hit test a render box with no size.'),\r\n          describeForError('The hitTest() method was called on this RenderBox'),\r\n          ErrorDescription(\r\n            'Although this node is not marked as needing layout, '\r\n            'its size is not set.'\r\n          ),\r\n          ErrorHint(\r\n            'A RenderBox object must have an '\r\n            'explicit size before it can be hit-tested. Make sure '\r\n            'that the RenderBox in question sets its size during layout.'\r\n          ),\r\n        ]);\r\n      }\r\n      return true;\r\n    }()");
      if (dart.test(dart.nullCheck(this[_size$]).contains(position))) {
        if (dart.test(this.hitTestChildren(result, {position: position})) || dart.test(this.hitTestSelf(position))) {
          result.add(new box.BoxHitTestEntry.new(this, position));
          return true;
        }
      }
      return false;
    }
    hitTestSelf(position) {
      if (position == null) dart.nullFailed(I[6], 2446, 27, "position");
      return false;
    }
    hitTestChildren(result, opts) {
      if (result == null) dart.nullFailed(I[6], 2472, 41, "result");
      let position = opts && 'position' in opts ? opts.position : null;
      if (position == null) dart.nullFailed(I[6], 2472, 67, "position");
      return false;
    }
    applyPaintTransform(child, transform) {
      object$.RenderObject.as(child);
      if (child == null) dart.nullFailed(I[6], 2485, 41, "child");
      if (transform == null) dart.nullFailed(I[6], 2485, 56, "transform");
      if (!(child != null)) dart.assertFailed(null, I[6], 2486, 12, "child != null");
      if (!dart.equals(child.parent, this)) dart.assertFailed(null, I[6], 2487, 12, "child.parent == this");
      if (!dart.test(dart.fn(() => {
        if (!box.BoxParentData.is(child.parentData)) {
          dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new(dart.str(this[$runtimeType]) + " does not implement applyPaintTransform."), this.describeForError("The following " + dart.str(this[$runtimeType]) + " object"), child.describeForError("...did not use a BoxParentData class for the parentData field of the following child"), new assertions.ErrorDescription.new("The " + dart.str(this[$runtimeType]) + " class inherits from RenderBox."), new assertions.ErrorHint.new("The default applyPaintTransform implementation provided by RenderBox assumes that the " + "children all use BoxParentData objects for their parentData field. " + "Since " + dart.str(this[$runtimeType]) + " does not in fact use that ParentData class for its children, it must " + "provide an implementation of applyPaintTransform that supports the specific ParentData " + "subclass used by its children (which apparently is " + dart.str(dart.runtimeType(child.parentData)) + ").")])));
        }
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 2488, 12, "() {\r\n      if (child.parentData is! BoxParentData) {\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('$runtimeType does not implement applyPaintTransform.'),\r\n          describeForError('The following $runtimeType object'),\r\n          child.describeForError('...did not use a BoxParentData class for the parentData field of the following child'),\r\n          ErrorDescription('The $runtimeType class inherits from RenderBox.'),\r\n          ErrorHint(\r\n            'The default applyPaintTransform implementation provided by RenderBox assumes that the '\r\n            'children all use BoxParentData objects for their parentData field. '\r\n            'Since $runtimeType does not in fact use that ParentData class for its children, it must '\r\n            'provide an implementation of applyPaintTransform that supports the specific ParentData '\r\n            'subclass used by its children (which apparently is ${child.parentData.runtimeType}).'\r\n          ),\r\n        ]);\r\n      }\r\n      return true;\r\n    }()");
      let childParentData = box.BoxParentData.as(dart.nullCheck(child.parentData));
      let offset = childParentData.offset;
      transform.translate(offset.dx, offset.dy);
    }
    globalToLocal(point, opts) {
      if (point == null) dart.nullFailed(I[6], 2525, 31, "point");
      let ancestor = opts && 'ancestor' in opts ? opts.ancestor : null;
      let transform = this.getTransformTo(ancestor);
      let det = transform.invert();
      if (det === 0.0) return ui.Offset.zero;
      let n = vector_math_64.Vector3.new(0.0, 0.0, 1.0);
      let i = transform.perspectiveTransform(vector_math_64.Vector3.new(0.0, 0.0, 0.0));
      let d = transform.perspectiveTransform(vector_math_64.Vector3.new(0.0, 0.0, 1.0))['-'](i);
      let s = transform.perspectiveTransform(vector_math_64.Vector3.new(point.dx, point.dy, 0.0));
      let p = s['-'](d['*'](dart.notNull(n.dot(s)) / dart.notNull(n.dot(d))));
      return new ui.Offset.new(p.x, p.y);
    }
    localToGlobal(point, opts) {
      if (point == null) dart.nullFailed(I[6], 2560, 31, "point");
      let ancestor = opts && 'ancestor' in opts ? opts.ancestor : null;
      return matrix_utils.MatrixUtils.transformPoint(this.getTransformTo(ancestor), point);
    }
    get paintBounds() {
      return ui.Offset.zero['&'](this.size);
    }
    handleEvent(event, entry) {
      if (event == null) dart.nullFailed(I[6], 2597, 33, "event");
      box.BoxHitTestEntry.as(entry);
      if (entry == null) dart.nullFailed(I[6], 2597, 56, "entry");
      super.handleEvent(event, entry);
    }
    debugHandleEvent(event, entry) {
      if (event == null) dart.nullFailed(I[6], 2618, 38, "event");
      if (entry == null) dart.nullFailed(I[6], 2618, 58, "entry");
      if (!dart.test(dart.fn(() => {
        if (dart.test(debug$0.debugPaintPointersEnabled)) {
          if (events.PointerDownEvent.is(event)) {
            this[_debugActivePointers] = dart.notNull(this[_debugActivePointers]) + 1;
          } else if (events.PointerUpEvent.is(event) || events.PointerCancelEvent.is(event)) {
            this[_debugActivePointers] = dart.notNull(this[_debugActivePointers]) - 1;
          }
          this.markNeedsPaint();
        }
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 2619, 12, "() {\r\n      if (debugPaintPointersEnabled) {\r\n        if (event is PointerDownEvent) {\r\n          _debugActivePointers += 1;\r\n        } else if (event is PointerUpEvent || event is PointerCancelEvent) {\r\n          _debugActivePointers -= 1;\r\n        }\r\n        markNeedsPaint();\r\n      }\r\n      return true;\r\n    }()");
      return true;
    }
    debugPaint(context, offset) {
      if (context == null) dart.nullFailed(I[6], 2634, 35, "context");
      if (offset == null) dart.nullFailed(I[6], 2634, 51, "offset");
      if (!dart.test(dart.fn(() => {
        if (dart.test(debug$0.debugPaintSizeEnabled)) this.debugPaintSize(context, offset);
        if (dart.test(debug$0.debugPaintBaselinesEnabled)) this.debugPaintBaselines(context, offset);
        if (dart.test(debug$0.debugPaintPointersEnabled)) this.debugPaintPointers(context, offset);
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 2635, 12, "() {\r\n      if (debugPaintSizeEnabled)\r\n        debugPaintSize(context, offset);\r\n      if (debugPaintBaselinesEnabled)\r\n        debugPaintBaselines(context, offset);\r\n      if (debugPaintPointersEnabled)\r\n        debugPaintPointers(context, offset);\r\n      return true;\r\n    }()");
    }
    debugPaintSize(context, offset) {
      if (context == null) dart.nullFailed(I[6], 2650, 39, "context");
      if (offset == null) dart.nullFailed(I[6], 2650, 55, "offset");
      if (!dart.test(dart.fn(() => {
        let t28;
        let paint = (t28 = ui.Paint.new(), (() => {
          t28.style = ui.PaintingStyle.stroke;
          t28.strokeWidth = 1.0;
          t28.color = C[19] || CT.C19;
          return t28;
        })());
        context.canvas.drawRect(offset['&'](this.size).deflate(0.5), paint);
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 2651, 12, "() {\r\n      final Paint paint = Paint()\r\n       ..style = PaintingStyle.stroke\r\n       ..strokeWidth = 1.0\r\n       ..color = const Color(0xFF00FFFF);\r\n      context.canvas.drawRect((offset & size).deflate(0.5), paint);\r\n      return true;\r\n    }()");
    }
    debugPaintBaselines(context, offset) {
      if (context == null) dart.nullFailed(I[6], 2665, 44, "context");
      if (offset == null) dart.nullFailed(I[6], 2665, 60, "offset");
      if (!dart.test(dart.fn(() => {
        let t28;
        let paint = (t28 = ui.Paint.new(), (() => {
          t28.style = ui.PaintingStyle.stroke;
          t28.strokeWidth = 0.25;
          return t28;
        })());
        let path = null;
        let baselineI = this.getDistanceToBaseline(ui.TextBaseline.ideographic, {onlyReal: true});
        if (baselineI != null) {
          paint.color = C[20] || CT.C20;
          path = ui.Path.new();
          path.moveTo(offset.dx, dart.notNull(offset.dy) + dart.notNull(baselineI));
          path.lineTo(dart.notNull(offset.dx) + dart.notNull(this.size.width), dart.notNull(offset.dy) + dart.notNull(baselineI));
          context.canvas.drawPath(path, paint);
        }
        let baselineA = this.getDistanceToBaseline(ui.TextBaseline.alphabetic, {onlyReal: true});
        if (baselineA != null) {
          paint.color = C[21] || CT.C21;
          path = ui.Path.new();
          path.moveTo(offset.dx, dart.notNull(offset.dy) + dart.notNull(baselineA));
          path.lineTo(dart.notNull(offset.dx) + dart.notNull(this.size.width), dart.notNull(offset.dy) + dart.notNull(baselineA));
          context.canvas.drawPath(path, paint);
        }
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 2666, 12, "() {\r\n      final Paint paint = Paint()\r\n       ..style = PaintingStyle.stroke\r\n       ..strokeWidth = 0.25;\r\n      Path path;\r\n      // ideographic baseline\r\n      final double? baselineI = getDistanceToBaseline(TextBaseline.ideographic, onlyReal: true);\r\n      if (baselineI != null) {\r\n        paint.color = const Color(0xFFFFD000);\r\n        path = Path();\r\n        path.moveTo(offset.dx, offset.dy + baselineI);\r\n        path.lineTo(offset.dx + size.width, offset.dy + baselineI);\r\n        context.canvas.drawPath(path, paint);\r\n      }\r\n      // alphabetic baseline\r\n      final double? baselineA = getDistanceToBaseline(TextBaseline.alphabetic, onlyReal: true);\r\n      if (baselineA != null) {\r\n        paint.color = const Color(0xFF00FF00);\r\n        path = Path();\r\n        path.moveTo(offset.dx, offset.dy + baselineA);\r\n        path.lineTo(offset.dx + size.width, offset.dy + baselineA);\r\n        context.canvas.drawPath(path, paint);\r\n      }\r\n      return true;\r\n    }()");
    }
    debugPaintPointers(context, offset) {
      if (context == null) dart.nullFailed(I[6], 2701, 43, "context");
      if (offset == null) dart.nullFailed(I[6], 2701, 59, "offset");
      if (!dart.test(dart.fn(() => {
        let t28;
        if (dart.notNull(this[_debugActivePointers]) > 0) {
          let paint = (t28 = ui.Paint.new(), (() => {
            t28.color = new ui.Color.new((48059 | (67108864 * dart.notNull(this.depth) & 4278190080) >>> 0) >>> 0);
            return t28;
          })());
          context.canvas.drawRect(offset['&'](this.size), paint);
        }
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[6], 2702, 12, "() {\r\n      if (_debugActivePointers > 0) {\r\n        final Paint paint = Paint()\r\n         ..color = Color(0x00BBBB | ((0x04000000 * depth) & 0xFF000000));\r\n        context.canvas.drawRect(offset & size, paint);\r\n      }\r\n      return true;\r\n    }()");
    }
    debugFillProperties(properties) {
      if (properties == null) dart.nullFailed(I[6], 2713, 56, "properties");
      super.debugFillProperties(properties);
      properties.add(new (T$.DiagnosticsPropertyOfSize()).new("size", this[_size$], {missingIfNull: true}));
    }
  };
  (box.RenderBox.new = function() {
    this[_cachedIntrinsicDimensions] = null;
    this[_cachedDryLayoutSizes] = null;
    this[_computingThisDryLayout] = false;
    this[_size$] = null;
    this[_cachedBaselines] = null;
    this[_debugActivePointers] = 0;
    box.RenderBox.__proto__.new.call(this);
    ;
  }).prototype = box.RenderBox.prototype;
  dart.addTypeTests(box.RenderBox);
  dart.addTypeCaches(box.RenderBox);
  dart.setMethodSignature(box.RenderBox, () => ({
    __proto__: dart.getMethods(box.RenderBox.__proto__),
    [_computeIntrinsicDimension]: dart.fnType(core.double, [box._IntrinsicDimension, core.double, dart.fnType(core.double, [core.double])]),
    getMinIntrinsicWidth: dart.fnType(core.double, [core.double]),
    computeMinIntrinsicWidth: dart.fnType(core.double, [core.double]),
    getMaxIntrinsicWidth: dart.fnType(core.double, [core.double]),
    computeMaxIntrinsicWidth: dart.fnType(core.double, [core.double]),
    getMinIntrinsicHeight: dart.fnType(core.double, [core.double]),
    computeMinIntrinsicHeight: dart.fnType(core.double, [core.double]),
    getMaxIntrinsicHeight: dart.fnType(core.double, [core.double]),
    computeMaxIntrinsicHeight: dart.fnType(core.double, [core.double]),
    getDryLayout: dart.fnType(ui.Size, [box.BoxConstraints]),
    [_computeDryLayout]: dart.fnType(ui.Size, [box.BoxConstraints]),
    computeDryLayout: dart.fnType(ui.Size, [box.BoxConstraints]),
    debugCannotComputeDryLayout: dart.fnType(core.bool, [], {error: dart.nullable(assertions.FlutterError), reason: dart.nullable(core.String)}, {}),
    debugAdoptSize: dart.fnType(ui.Size, [ui.Size]),
    getDistanceToBaseline: dart.fnType(dart.nullable(core.double), [ui.TextBaseline], {onlyReal: core.bool}, {}),
    getDistanceToActualBaseline: dart.fnType(dart.nullable(core.double), [ui.TextBaseline]),
    computeDistanceToActualBaseline: dart.fnType(dart.nullable(core.double), [ui.TextBaseline]),
    debugAssertDoesMeetConstraints: dart.fnType(dart.void, []),
    performResize: dart.fnType(dart.void, []),
    performLayout: dart.fnType(dart.void, []),
    hitTest: dart.fnType(core.bool, [box.BoxHitTestResult], {}, {position: ui.Offset}),
    hitTestSelf: dart.fnType(core.bool, [ui.Offset]),
    hitTestChildren: dart.fnType(core.bool, [box.BoxHitTestResult], {}, {position: ui.Offset}),
    globalToLocal: dart.fnType(ui.Offset, [ui.Offset], {ancestor: dart.nullable(object$.RenderObject)}, {}),
    localToGlobal: dart.fnType(ui.Offset, [ui.Offset], {ancestor: dart.nullable(object$.RenderObject)}, {}),
    debugHandleEvent: dart.fnType(core.bool, [events.PointerEvent, hit_test.HitTestEntry]),
    debugPaintSize: dart.fnType(dart.void, [object$.PaintingContext, ui.Offset]),
    debugPaintBaselines: dart.fnType(dart.void, [object$.PaintingContext, ui.Offset]),
    debugPaintPointers: dart.fnType(dart.void, [object$.PaintingContext, ui.Offset])
  }));
  dart.setGetterSignature(box.RenderBox, () => ({
    __proto__: dart.getGetters(box.RenderBox.__proto__),
    hasSize: core.bool,
    size: ui.Size,
    semanticBounds: ui.Rect,
    constraints: box.BoxConstraints,
    paintBounds: ui.Rect
  }));
  dart.setSetterSignature(box.RenderBox, () => ({
    __proto__: dart.getSetters(box.RenderBox.__proto__),
    size: ui.Size
  }));
  dart.setLibraryUri(box.RenderBox, I[7]);
  dart.setFieldSignature(box.RenderBox, () => ({
    __proto__: dart.getFields(box.RenderBox.__proto__),
    [_cachedIntrinsicDimensions]: dart.fieldType(dart.nullable(core.Map$(box._IntrinsicDimensionsCacheEntry, core.double))),
    [_cachedDryLayoutSizes]: dart.fieldType(dart.nullable(core.Map$(box.BoxConstraints, ui.Size))),
    [_computingThisDryLayout]: dart.fieldType(core.bool),
    [_size$]: dart.fieldType(dart.nullable(ui.Size)),
    [_cachedBaselines]: dart.fieldType(dart.nullable(core.Map$(ui.TextBaseline, dart.nullable(core.double)))),
    [_debugActivePointers]: dart.fieldType(core.int)
  }));
  dart.defineLazy(box.RenderBox, {
    /*box.RenderBox._dryLayoutCalculationValid*/get _dryLayoutCalculationValid() {
      return true;
    },
    set _dryLayoutCalculationValid(_) {},
    /*box.RenderBox._debugDoingBaseline*/get _debugDoingBaseline() {
      return false;
    },
    set _debugDoingBaseline(_) {}
  }, false);
  const RenderObject_RenderObjectWithChildMixin$36 = class RenderObject_RenderObjectWithChildMixin extends object$.RenderObject {};
  (RenderObject_RenderObjectWithChildMixin$36.new = function() {
    object$.RenderObjectWithChildMixin$(box.RenderBox)[dart.mixinNew].call(this);
    RenderObject_RenderObjectWithChildMixin$36.__proto__.new.call(this);
  }).prototype = RenderObject_RenderObjectWithChildMixin$36.prototype;
  dart.applyMixin(RenderObject_RenderObjectWithChildMixin$36, object$.RenderObjectWithChildMixin$(box.RenderBox));
  view.RenderView = class RenderView extends RenderObject_RenderObjectWithChildMixin$36 {
    get automaticSystemUiAdjustment() {
      return this[automaticSystemUiAdjustment];
    }
    set automaticSystemUiAdjustment(value) {
      this[automaticSystemUiAdjustment] = value;
    }
    get size() {
      return this[_size];
    }
    get configuration() {
      return this[_configuration];
    }
    set configuration(value) {
      if (value == null) dart.nullFailed(I[2], 77, 39, "value");
      if (!(value != null)) dart.assertFailed(null, I[2], 78, 12, "value != null");
      if (dart.equals(this.configuration, value)) return;
      this[_configuration] = value;
      this.replaceRootLayer(this[_updateMatricesAndCreateNewRootLayer]());
      if (!(this[_rootTransform] != null)) dart.assertFailed(null, I[2], 83, 12, "_rootTransform != null");
      this.markNeedsLayout();
    }
    prepareInitialFrame() {
      if (!(this.owner != null)) dart.assertFailed(null, I[2], 119, 12, "owner != null");
      if (!(this[_rootTransform] == null)) dart.assertFailed(null, I[2], 120, 12, "_rootTransform == null");
      this.scheduleInitialLayout();
      this.scheduleInitialPaint(this[_updateMatricesAndCreateNewRootLayer]());
      if (!(this[_rootTransform] != null)) dart.assertFailed(null, I[2], 123, 12, "_rootTransform != null");
    }
    [_updateMatricesAndCreateNewRootLayer]() {
      this[_rootTransform] = this.configuration.toMatrix();
      let rootLayer = new layer$.TransformLayer.new({transform: this[_rootTransform]});
      rootLayer.attach(this);
      if (!(this[_rootTransform] != null)) dart.assertFailed(null, I[2], 132, 12, "_rootTransform != null");
      return rootLayer;
    }
    debugAssertDoesMeetConstraints() {
      if (!false) dart.assertFailed(null, I[2], 139, 50, "false");
    }
    performResize() {
      if (!false) dart.assertFailed(null, I[2], 143, 12, "false");
    }
    performLayout() {
      if (!(this[_rootTransform] != null)) dart.assertFailed(null, I[2], 148, 12, "_rootTransform != null");
      this[_size] = this.configuration.size;
      if (!dart.test(this[_size].isFinite)) dart.assertFailed(null, I[2], 150, 12, "_size.isFinite");
      if (this.child != null) dart.nullCheck(this.child).layout(new box.BoxConstraints.tight(this[_size]));
    }
    rotate(opts) {
      let oldAngle = opts && 'oldAngle' in opts ? opts.oldAngle : null;
      let newAngle = opts && 'newAngle' in opts ? opts.newAngle : null;
      let time = opts && 'time' in opts ? opts.time : null;
      if (!false) dart.assertFailed(null, I[2], 158, 12, "false");
    }
    hitTest(result, opts) {
      if (result == null) dart.nullFailed(I[2], 171, 30, "result");
      let position = opts && 'position' in opts ? opts.position : null;
      if (position == null) dart.nullFailed(I[2], 171, 56, "position");
      if (this.child != null) dart.nullCheck(this.child).hitTest(new box.BoxHitTestResult.wrap(result), {position: position});
      result.add(new hit_test.HitTestEntry.new(this));
      return true;
    }
    hitTestMouseTrackers(position) {
      if (position == null) dart.nullFailed(I[2], 184, 45, "position");
      if (!(position != null)) dart.assertFailed(null, I[2], 185, 12, "position != null");
      let result = new box.BoxHitTestResult.new();
      this.hitTest(result, {position: position});
      return result;
    }
    get isRepaintBoundary() {
      return true;
    }
    paint(context, offset) {
      if (context == null) dart.nullFailed(I[2], 198, 30, "context");
      if (offset == null) dart.nullFailed(I[2], 198, 46, "offset");
      if (this.child != null) context.paintChild(dart.nullCheck(this.child), offset);
    }
    applyPaintTransform(child, transform) {
      box.RenderBox.as(child);
      if (child == null) dart.nullFailed(I[2], 204, 38, "child");
      if (transform == null) dart.nullFailed(I[2], 204, 53, "transform");
      if (!(this[_rootTransform] != null)) dart.assertFailed(null, I[2], 205, 12, "_rootTransform != null");
      transform.multiply(dart.nullCheck(this[_rootTransform]));
      super.applyPaintTransform(child, transform);
    }
    compositeFrame() {
      developer.Timeline.startSync("Compositing", {arguments: debug.timelineArgumentsIndicatingLandmarkEvent});
      try {
        let builder = ui.SceneBuilder.new();
        let scene = dart.nullCheck(this.layer).buildScene(builder);
        if (dart.test(this.automaticSystemUiAdjustment)) this[_updateSystemChrome]();
        this[_window].render(scene);
        scene.dispose();
        if (!dart.test(dart.fn(() => {
          if (dart.test(debug$0.debugRepaintRainbowEnabled) || dart.test(debug$0.debugRepaintTextRainbowEnabled)) debug$0.debugCurrentRepaintColor = debug$0.debugCurrentRepaintColor.withHue((dart.notNull(debug$0.debugCurrentRepaintColor.hue) + 2.0)[$modulo](360.0));
          return true;
        }, T$.VoidTobool())())) dart.assertFailed(null, I[2], 222, 14, "() {\r\n        if (debugRepaintRainbowEnabled || debugRepaintTextRainbowEnabled)\r\n          debugCurrentRepaintColor = debugCurrentRepaintColor.withHue((debugCurrentRepaintColor.hue + 2.0) % 360.0);\r\n        return true;\r\n      }()");
      } finally {
        developer.Timeline.finishSync();
      }
    }
    [_updateSystemChrome]() {
      let t0, t0$, t0$0, t0$1, t0$2, t0$3;
      let bounds = this.paintBounds;
      let top = new ui.Offset.new(bounds.center.dx, dart.notNull(this[_window].padding.top) / 2.0);
      let bottom = new ui.Offset.new(bounds.center.dx, dart.notNull(bounds.bottom) - 1.0 - dart.notNull(this[_window].padding.bottom) / 2.0);
      let upperOverlayStyle = dart.nullCheck(this.layer).find(system_chrome.SystemUiOverlayStyle, top);
      let lowerOverlayStyle = null;
      switch (platform.defaultTargetPlatform) {
        case C[7] || CT.C7:
        {
          lowerOverlayStyle = dart.nullCheck(this.layer).find(system_chrome.SystemUiOverlayStyle, bottom);
          break;
        }
        case C[8] || CT.C8:
        case C[9] || CT.C9:
        case C[10] || CT.C10:
        case C[11] || CT.C11:
        case C[12] || CT.C12:
        {
          break;
        }
        default:
        {
          dart.throw(new _internal.ReachabilityError.new("`null` encountered as case in a switch expression with a non-nullable enum type."));
        }
      }
      if (upperOverlayStyle != null || lowerOverlayStyle != null) {
        let overlayStyle = new system_chrome.SystemUiOverlayStyle.new({statusBarBrightness: (t0 = upperOverlayStyle, t0 == null ? null : t0.statusBarBrightness), statusBarIconBrightness: (t0$ = upperOverlayStyle, t0$ == null ? null : t0$.statusBarIconBrightness), statusBarColor: (t0$0 = upperOverlayStyle, t0$0 == null ? null : t0$0.statusBarColor), systemNavigationBarColor: (t0$1 = lowerOverlayStyle, t0$1 == null ? null : t0$1.systemNavigationBarColor), systemNavigationBarDividerColor: (t0$2 = lowerOverlayStyle, t0$2 == null ? null : t0$2.systemNavigationBarDividerColor), systemNavigationBarIconBrightness: (t0$3 = lowerOverlayStyle, t0$3 == null ? null : t0$3.systemNavigationBarIconBrightness)});
        system_chrome.SystemChrome.setSystemUIOverlayStyle(overlayStyle);
      }
    }
    get paintBounds() {
      return ui.Offset.zero['&'](this.size['*'](this.configuration.devicePixelRatio));
    }
    get semanticBounds() {
      if (!(this[_rootTransform] != null)) dart.assertFailed(null, I[2], 307, 12, "_rootTransform != null");
      return matrix_utils.MatrixUtils.transformRect(dart.nullCheck(this[_rootTransform]), ui.Offset.zero['&'](this.size));
    }
    debugFillProperties(properties) {
      if (properties == null) dart.nullFailed(I[2], 312, 56, "properties");
      if (!dart.test(dart.fn(() => {
        properties.add(diagnostics.DiagnosticsNode.message("debug mode enabled - " + dart.str(true ? "Web" : io.Platform.operatingSystem)));
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[2], 316, 12, "() {\r\n      properties.add(DiagnosticsNode.message('debug mode enabled - ${kIsWeb ? 'Web' :  Platform.operatingSystem}'));\r\n      return true;\r\n    }()");
      properties.add(new (T$.DiagnosticsPropertyOfSize()).new("window size", this[_window].physicalSize, {tooltip: "in physical pixels"}));
      properties.add(new diagnostics.DoubleProperty.new("device pixel ratio", this[_window].devicePixelRatio, {tooltip: "physical pixels per logical pixel"}));
      properties.add(new (T$.DiagnosticsPropertyOfViewConfiguration()).new("configuration", this.configuration, {tooltip: "in logical pixels"}));
      if (dart.test(this[_window].platformDispatcher.semanticsEnabled)) properties.add(diagnostics.DiagnosticsNode.message("semantics enabled"));
    }
  };
  (view.RenderView.new = function(opts) {
    let child = opts && 'child' in opts ? opts.child : null;
    let configuration = opts && 'configuration' in opts ? opts.configuration : null;
    if (configuration == null) dart.nullFailed(I[2], 58, 32, "configuration");
    let window = opts && 'window' in opts ? opts.window : null;
    if (window == null) dart.nullFailed(I[2], 59, 29, "window");
    this[_size] = ui.Size.zero;
    this[automaticSystemUiAdjustment] = true;
    this[_rootTransform] = null;
    if (!(configuration != null)) dart.assertFailed(null, I[2], 60, 15, "configuration != null");
    this[_configuration] = configuration;
    this[_window] = window;
    view.RenderView.__proto__.new.call(this);
    this.child = child;
  }).prototype = view.RenderView.prototype;
  dart.addTypeTests(view.RenderView);
  dart.addTypeCaches(view.RenderView);
  dart.setMethodSignature(view.RenderView, () => ({
    __proto__: dart.getMethods(view.RenderView.__proto__),
    prepareInitialFrame: dart.fnType(dart.void, []),
    [_updateMatricesAndCreateNewRootLayer]: dart.fnType(layer$.TransformLayer, []),
    debugAssertDoesMeetConstraints: dart.fnType(dart.void, []),
    performResize: dart.fnType(dart.void, []),
    performLayout: dart.fnType(dart.void, []),
    hitTest: dart.fnType(core.bool, [hit_test.HitTestResult], {}, {position: ui.Offset}),
    hitTestMouseTrackers: dart.fnType(hit_test.HitTestResult, [ui.Offset]),
    compositeFrame: dart.fnType(dart.void, []),
    [_updateSystemChrome]: dart.fnType(dart.void, [])
  }));
  dart.setGetterSignature(view.RenderView, () => ({
    __proto__: dart.getGetters(view.RenderView.__proto__),
    size: ui.Size,
    configuration: view.ViewConfiguration,
    paintBounds: ui.Rect,
    semanticBounds: ui.Rect
  }));
  dart.setSetterSignature(view.RenderView, () => ({
    __proto__: dart.getSetters(view.RenderView.__proto__),
    configuration: view.ViewConfiguration
  }));
  dart.setLibraryUri(view.RenderView, I[3]);
  dart.setFieldSignature(view.RenderView, () => ({
    __proto__: dart.getFields(view.RenderView.__proto__),
    [_size]: dart.fieldType(ui.Size),
    [_configuration]: dart.fieldType(view.ViewConfiguration),
    [_window]: dart.finalFieldType(ui.FlutterView),
    automaticSystemUiAdjustment: dart.fieldType(core.bool),
    [_rootTransform]: dart.fieldType(dart.nullable(vector_math_64.Matrix4))
  }));
  var _lastSession = dart.privateName(mouse_cursor, "_lastSession");
  var _handleDeviceUpdateMouseCursor = dart.privateName(mouse_cursor, "_handleDeviceUpdateMouseCursor");
  var _findFirstCursor = dart.privateName(mouse_cursor, "_findFirstCursor");
  var _mouseStates = dart.privateName(mouse_tracking, "_mouseStates");
  var _debugDuringDeviceUpdate = dart.privateName(mouse_tracking, "_debugDuringDeviceUpdate");
  var _monitorMouseConnection = dart.privateName(mouse_tracking, "_monitorMouseConnection");
  var _deviceUpdatePhase = dart.privateName(mouse_tracking, "_deviceUpdatePhase");
  var _hitTestResultToAnnotations = dart.privateName(mouse_tracking, "_hitTestResultToAnnotations");
  var _findAnnotations = dart.privateName(mouse_tracking, "_findAnnotations");
  mouse_tracking.BaseMouseTracker = class BaseMouseTracker extends change_notifier.ChangeNotifier {
    get mouseIsConnected() {
      return this[_mouseStates][$isNotEmpty];
    }
    [_monitorMouseConnection](task) {
      if (task == null) dart.nullFailed(I[9], 298, 45, "task");
      let mouseWasConnected = this.mouseIsConnected;
      task();
      if (mouseWasConnected != this.mouseIsConnected) this.notifyListeners();
    }
    [_deviceUpdatePhase](task) {
      if (task == null) dart.nullFailed(I[9], 310, 40, "task");
      if (!!dart.test(this[_debugDuringDeviceUpdate])) dart.assertFailed(null, I[9], 311, 12, "!_debugDuringDeviceUpdate");
      if (!dart.test(dart.fn(() => {
        this[_debugDuringDeviceUpdate] = true;
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[9], 312, 12, "() {\r\n      _debugDuringDeviceUpdate = true;\r\n      return true;\r\n    }()");
      task();
      if (!dart.test(dart.fn(() => {
        this[_debugDuringDeviceUpdate] = false;
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[9], 317, 12, "() {\r\n      _debugDuringDeviceUpdate = false;\r\n      return true;\r\n    }()");
    }
    static _shouldMarkStateDirty(state, event) {
      if (event == null) dart.nullFailed(I[9], 324, 70, "event");
      if (state == null) return true;
      if (!(event != null)) dart.assertFailed(null, I[9], 327, 12, "event != null");
      let lastEvent = state.latestEvent;
      if (!(event.device == lastEvent.device)) dart.assertFailed(null, I[9], 329, 12, "event.device == lastEvent.device");
      if (!(events.PointerAddedEvent.is(event) === events.PointerRemovedEvent.is(lastEvent))) dart.assertFailed(null, I[9], 332, 12, "(event is PointerAddedEvent) == (lastEvent is PointerRemovedEvent)");
      if (events.PointerSignalEvent.is(event)) return false;
      return events.PointerAddedEvent.is(lastEvent) || events.PointerRemovedEvent.is(event) || !dart.equals(lastEvent.position, event.position);
    }
    [_hitTestResultToAnnotations](result) {
      if (result == null) dart.nullFailed(I[9], 342, 92, "result");
      if (!(result != null)) dart.assertFailed(null, I[9], 343, 12, "result != null");
      let annotations = T$.LinkedHashMapOfMouseTrackerAnnotation$Matrix4().as(new (T$.LinkedMapOfMouseTrackerAnnotation$Matrix4()).new());
      for (let entry of result.path) {
        if (mouse_tracking.MouseTrackerAnnotation.is(entry.target)) {
          annotations[$_set](mouse_tracking.MouseTrackerAnnotation.as(entry.target), dart.nullCheck(entry.transform));
        }
      }
      return annotations;
    }
    [_findAnnotations](state, hitTest) {
      if (state == null) dart.nullFailed(I[9], 359, 79, "state");
      if (hitTest == null) dart.nullFailed(I[9], 359, 116, "hitTest");
      if (!(state != null)) dart.assertFailed(null, I[9], 360, 12, "state != null");
      if (!(hitTest != null)) dart.assertFailed(null, I[9], 361, 12, "hitTest != null");
      let globalPosition = state.latestEvent.position;
      let device = state.device;
      if (!dart.test(this[_mouseStates][$containsKey](device))) return T$.LinkedHashMapOfMouseTrackerAnnotation$Matrix4().as(new (T$.LinkedMapOfMouseTrackerAnnotation$Matrix4()).new());
      return this[_hitTestResultToAnnotations](hitTest(globalPosition));
    }
    handleDeviceUpdate(details) {
      if (details == null) dart.nullFailed(I[9], 391, 53, "details");
      if (!dart.test(this[_debugDuringDeviceUpdate])) dart.assertFailed(null, I[9], 392, 12, "_debugDuringDeviceUpdate");
    }
    updateWithEvent(event, getResult) {
      if (event == null) dart.nullFailed(I[9], 404, 37, "event");
      if (getResult == null) dart.nullFailed(I[9], 404, 71, "getResult");
      if (!(event != null)) dart.assertFailed(null, I[9], 405, 12, "event != null");
      let result = events.PointerRemovedEvent.is(event) ? new hit_test.HitTestResult.new() : getResult();
      if (!(result != null)) dart.assertFailed(null, I[9], 407, 12, "result != null");
      if (event.kind != ui.PointerDeviceKind.mouse) return;
      if (events.PointerSignalEvent.is(event)) return;
      let device = event.device;
      let existingState = this[_mouseStates][$_get](device);
      if (!dart.test(mouse_tracking.BaseMouseTracker._shouldMarkStateDirty(existingState, event))) return;
      this[_monitorMouseConnection](dart.fn(() => {
        this[_deviceUpdatePhase](dart.fn(() => {
          let t28;
          if (existingState == null) {
            if (!!events.PointerRemovedEvent.is(event)) dart.assertFailed(null, I[9], 423, 18, "event is! PointerRemovedEvent");
            this[_mouseStates][$_set](device, new mouse_tracking._MouseState.new({initialEvent: event}));
          } else {
            if (!!events.PointerAddedEvent.is(event)) dart.assertFailed(null, I[9], 426, 18, "event is! PointerAddedEvent");
            if (events.PointerRemovedEvent.is(event)) this[_mouseStates][$remove](event.device);
          }
          let targetState = (t28 = this[_mouseStates][$_get](device), t28 == null ? dart.nullCheck(existingState) : t28);
          let lastEvent = targetState.replaceLatestEvent(event);
          let nextAnnotations = events.PointerRemovedEvent.is(event) ? T$.LinkedHashMapOfMouseTrackerAnnotation$Matrix4().as(new (T$.LinkedMapOfMouseTrackerAnnotation$Matrix4()).new()) : this[_hitTestResultToAnnotations](result);
          let lastAnnotations = targetState.replaceAnnotations(nextAnnotations);
          this.handleDeviceUpdate(new mouse_tracking.MouseTrackerUpdateDetails.byPointerEvent({lastAnnotations: lastAnnotations, nextAnnotations: nextAnnotations, previousEvent: lastEvent, triggeringEvent: event}));
        }, T$.VoidTovoid()));
      }, T$.VoidTovoid()));
    }
    updateAllDevices(hitTest) {
      if (hitTest == null) dart.nullFailed(I[9], 459, 55, "hitTest");
      this[_deviceUpdatePhase](dart.fn(() => {
        for (let dirtyState of this[_mouseStates][$values]) {
          let lastEvent = dirtyState.latestEvent;
          let nextAnnotations = this[_findAnnotations](dirtyState, hitTest);
          let lastAnnotations = dirtyState.replaceAnnotations(nextAnnotations);
          this.handleDeviceUpdate(new mouse_tracking.MouseTrackerUpdateDetails.byNewFrame({lastAnnotations: lastAnnotations, nextAnnotations: nextAnnotations, previousEvent: lastEvent}));
        }
      }, T$.VoidTovoid()));
    }
  };
  (mouse_tracking.BaseMouseTracker.new = function() {
    this[_mouseStates] = new (T$.IdentityMapOfint$_MouseState()).new();
    this[_debugDuringDeviceUpdate] = false;
    mouse_tracking.BaseMouseTracker.__proto__.new.call(this);
    ;
  }).prototype = mouse_tracking.BaseMouseTracker.prototype;
  dart.addTypeTests(mouse_tracking.BaseMouseTracker);
  dart.addTypeCaches(mouse_tracking.BaseMouseTracker);
  dart.setMethodSignature(mouse_tracking.BaseMouseTracker, () => ({
    __proto__: dart.getMethods(mouse_tracking.BaseMouseTracker.__proto__),
    [_monitorMouseConnection]: dart.fnType(dart.void, [dart.fnType(dart.void, [])]),
    [_deviceUpdatePhase]: dart.fnType(dart.void, [dart.fnType(dart.void, [])]),
    [_hitTestResultToAnnotations]: dart.fnType(collection.LinkedHashMap$(mouse_tracking.MouseTrackerAnnotation, vector_math_64.Matrix4), [hit_test.HitTestResult]),
    [_findAnnotations]: dart.fnType(collection.LinkedHashMap$(mouse_tracking.MouseTrackerAnnotation, vector_math_64.Matrix4), [mouse_tracking._MouseState, dart.fnType(hit_test.HitTestResult, [ui.Offset])]),
    handleDeviceUpdate: dart.fnType(dart.void, [mouse_tracking.MouseTrackerUpdateDetails]),
    updateWithEvent: dart.fnType(dart.void, [events.PointerEvent, dart.fnType(hit_test.HitTestResult, [])]),
    updateAllDevices: dart.fnType(dart.void, [dart.fnType(hit_test.HitTestResult, [ui.Offset])])
  }));
  dart.setGetterSignature(mouse_tracking.BaseMouseTracker, () => ({
    __proto__: dart.getGetters(mouse_tracking.BaseMouseTracker.__proto__),
    mouseIsConnected: core.bool
  }));
  dart.setLibraryUri(mouse_tracking.BaseMouseTracker, I[10]);
  dart.setFieldSignature(mouse_tracking.BaseMouseTracker, () => ({
    __proto__: dart.getFields(mouse_tracking.BaseMouseTracker.__proto__),
    [_mouseStates]: dart.finalFieldType(core.Map$(core.int, mouse_tracking._MouseState)),
    [_debugDuringDeviceUpdate]: dart.fieldType(core.bool)
  }));
  mouse_cursor.MouseTrackerCursorMixin = class MouseTrackerCursorMixin extends mouse_tracking.BaseMouseTracker {};
  mouse_cursor.MouseTrackerCursorMixin[dart.mixinOn] = BaseMouseTracker => class MouseTrackerCursorMixin extends BaseMouseTracker {
    debugDeviceActiveCursor(device) {
      if (device == null) dart.nullFailed(I[8], 26, 44, "device");
      let result = null;
      if (!dart.test(dart.fn(() => {
        let t28;
        result = (t28 = this[_lastSession][$_get](device), t28 == null ? null : t28.cursor);
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[8], 28, 12, "() {\r\n      result = _lastSession[device]?.cursor;\r\n      return true;\r\n    }()");
      return result;
    }
    handleDeviceUpdate(details) {
      if (details == null) dart.nullFailed(I[8], 37, 53, "details");
      super.handleDeviceUpdate(details);
      this[_handleDeviceUpdateMouseCursor](details);
    }
    [_findFirstCursor](annotations) {
      let t28;
      if (annotations == null) dart.nullFailed(I[8], 50, 65, "annotations");
      t28 = mouse_cursor._DeferringMouseCursor.firstNonDeferred(annotations[$map](mouse_cursor.MouseCursor, dart.fn(annotation => {
        if (annotation == null) dart.nullFailed(I[8], 52, 47, "annotation");
        return annotation.cursor;
      }, T$.MouseTrackerAnnotationToMouseCursor())));
      return t28 == null ? mouse_cursor.SystemMouseCursors.basic : t28;
    }
    [_handleDeviceUpdateMouseCursor](details) {
      let t28, t28$;
      if (details == null) dart.nullFailed(I[8], 57, 65, "details");
      let device = details.device;
      if (events.PointerRemovedEvent.is(details.triggeringEvent)) {
        this[_lastSession][$remove](device);
        return;
      }
      let lastSession = this[_lastSession][$_get](device);
      let nextCursor = this[_findFirstCursor](details.nextAnnotations[$keys]);
      if (dart.equals((t28 = lastSession, t28 == null ? null : t28.cursor), nextCursor)) return;
      let nextSession = nextCursor.createSession(device);
      this[_lastSession][$_set](device, nextSession);
      t28$ = lastSession;
      t28$ == null ? null : t28$.dispose();
      nextSession.activate();
    }
  };
  (mouse_cursor.MouseTrackerCursorMixin[dart.mixinNew] = function() {
    this[_lastSession] = new (T$.IdentityMapOfint$MouseCursorSession()).new();
  }).prototype = mouse_cursor.MouseTrackerCursorMixin.prototype;
  dart.addTypeTests(mouse_cursor.MouseTrackerCursorMixin);
  dart.addTypeCaches(mouse_cursor.MouseTrackerCursorMixin);
  mouse_cursor.MouseTrackerCursorMixin[dart.implements] = () => [mouse_tracking.BaseMouseTracker];
  dart.setMethodSignature(mouse_cursor.MouseTrackerCursorMixin, () => ({
    __proto__: dart.getMethods(mouse_cursor.MouseTrackerCursorMixin.__proto__),
    debugDeviceActiveCursor: dart.fnType(dart.nullable(mouse_cursor.MouseCursor), [core.int]),
    [_findFirstCursor]: dart.fnType(mouse_cursor.MouseCursor, [core.Iterable$(mouse_tracking.MouseTrackerAnnotation)]),
    [_handleDeviceUpdateMouseCursor]: dart.fnType(dart.void, [mouse_tracking.MouseTrackerUpdateDetails])
  }));
  dart.setLibraryUri(mouse_cursor.MouseTrackerCursorMixin, I[11]);
  dart.setFieldSignature(mouse_cursor.MouseTrackerCursorMixin, () => ({
    __proto__: dart.getFields(mouse_cursor.MouseTrackerCursorMixin.__proto__),
    [_lastSession]: dart.finalFieldType(core.Map$(core.int, mouse_cursor.MouseCursorSession))
  }));
  var cursor$ = dart.privateName(mouse_cursor, "MouseCursorSession.cursor");
  var device$ = dart.privateName(mouse_cursor, "MouseCursorSession.device");
  mouse_cursor.MouseCursorSession = class MouseCursorSession extends core.Object {
    get cursor() {
      return this[cursor$];
    }
    set cursor(value) {
      super.cursor = value;
    }
    get device() {
      return this[device$];
    }
    set device(value) {
      super.device = value;
    }
  };
  (mouse_cursor.MouseCursorSession.new = function(cursor, device) {
    if (cursor == null) dart.nullFailed(I[8], 101, 27, "cursor");
    if (device == null) dart.nullFailed(I[8], 101, 40, "device");
    this[cursor$] = cursor;
    this[device$] = device;
    if (!(cursor != null)) dart.assertFailed(null, I[8], 102, 14, "cursor != null");
    if (!(device != null)) dart.assertFailed(null, I[8], 103, 14, "device != null");
    ;
  }).prototype = mouse_cursor.MouseCursorSession.prototype;
  dart.addTypeTests(mouse_cursor.MouseCursorSession);
  dart.addTypeCaches(mouse_cursor.MouseCursorSession);
  dart.setLibraryUri(mouse_cursor.MouseCursorSession, I[11]);
  dart.setFieldSignature(mouse_cursor.MouseCursorSession, () => ({
    __proto__: dart.getFields(mouse_cursor.MouseCursorSession.__proto__),
    cursor: dart.finalFieldType(mouse_cursor.MouseCursor),
    device: dart.finalFieldType(core.int)
  }));
  const Object_Diagnosticable$36 = class Object_Diagnosticable extends core.Object {};
  (Object_Diagnosticable$36.new = function() {
  }).prototype = Object_Diagnosticable$36.prototype;
  dart.applyMixin(Object_Diagnosticable$36, diagnostics.Diagnosticable);
  mouse_cursor.MouseCursor = class MouseCursor extends Object_Diagnosticable$36 {
    toString(opts) {
      let minLevel = opts && 'minLevel' in opts ? opts.minLevel : C[14] || CT.C14;
      if (minLevel == null) dart.nullFailed(I[8], 226, 36, "minLevel");
      let debugDescription = this.debugDescription;
      if (dart.notNull(minLevel.index) >= dart.notNull(diagnostics.DiagnosticLevel.info.index) && debugDescription != null) return debugDescription;
      return super.toString({minLevel: minLevel});
    }
  };
  (mouse_cursor.MouseCursor.new = function() {
    ;
  }).prototype = mouse_cursor.MouseCursor.prototype;
  dart.addTypeTests(mouse_cursor.MouseCursor);
  dart.addTypeCaches(mouse_cursor.MouseCursor);
  dart.setLibraryUri(mouse_cursor.MouseCursor, I[11]);
  dart.defineExtensionMethods(mouse_cursor.MouseCursor, ['toString']);
  dart.defineLazy(mouse_cursor.MouseCursor, {
    /*mouse_cursor.MouseCursor.defer*/get defer() {
      return C[22] || CT.C22;
    },
    /*mouse_cursor.MouseCursor.uncontrolled*/get uncontrolled() {
      return C[23] || CT.C23;
    }
  }, false);
  mouse_cursor._DeferringMouseCursor = class _DeferringMouseCursor extends mouse_cursor.MouseCursor {
    createSession(device) {
      if (device == null) dart.nullFailed(I[8], 263, 40, "device");
      if (!false) dart.assertFailed("_DeferringMouseCursor can 